<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Firmar Documento PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f4f4;
      overflow: hidden; /* Evitar scroll en el body */
    }

    header {
      background: #2c3e50;
      color: white;
      padding: 0.5rem; /* Reducido padding */
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header h2 {
        margin-top: 0.15rem;
        margin-bottom: 0.3rem; /* Reducido espacio */
        font-size: 1.1rem; /* Más pequeño */
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.3rem; /* Reducido */
      gap: 0.25rem; /* Espacio reducido */
      width: 100%;
    }

    .toolbar-btn {
      background: #3498db;
      border: none;
      padding: 0.4rem 0.7rem; /* Reducido padding */
      margin: 0.15rem; /* Reducido margen */
      color: white;
      font-size: 0.8rem; /* Más pequeño */
      border-radius: 3px; /* Bordes más sutiles */
      cursor: pointer;
      transition: background-color 0.3s ease;
      flex-grow: 1;
      flex-basis: auto;
      min-width: 90px; /* Ajustado ancho mínimo */
    }
    .toolbar-btn:hover {
        background-color: #2980b9;
    }

    #pdf-viewer {
      width: 100vw;
      /* La altura se ajusta dinámicamente con JS */
      overflow: hidden;
      background: #fff;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none;
    }

    #pdf-canvas {
      cursor: grab;
      /* El tamaño se establece por JS */
      image-rendering: -webkit-optimize-contrast; /* Intentar mejorar nitidez en WebKit */
      image-rendering: crisp-edges; /* Para otros navegadores */
    }

    #page-info {
      text-align: center;
      margin-top: 0.15rem; /* Reducido */
      margin-bottom: 0.15rem; /* Reducido */
      font-size: 0.75rem; /* Más pequeño */
    }

    #zoom-slider-container {
      position: fixed;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.08); /* Ligeramente más sutil */
      padding: 4px; /* Reducido */
      border-radius: 6px; /* Reducido */
      z-index: 9999;
    }

    #zoom-slider {
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 16px; /* Más delgado */
      height: 100px; /* Más corto */
      transform: rotate(180deg);
    }

    input[type="file"]#file-input {
      padding: 0.4rem; /* Reducido */
      border-radius: 3px;
      border: 1px solid #ccc;
      background-color: #fff;
      color: #333;
      cursor: pointer;
      font-size: 0.75rem; /* Más pequeño */
      width: 100%;
      max-width: 260px; /* Ajustado */
      margin: 0.15rem;
    }
    input[type="file"]#file-input::file-selector-button {
        background: #5dade2;
        color: white;
        border: none;
        padding: 0.4rem 0.7rem; /* Reducido */
        border-radius: 3px;
        cursor: pointer;
        margin-right: 6px; /* Reducido */
    }

    .signature-box {
      position: absolute;
      border: 2px dashed #3498db;
      background-color: rgba(52, 152, 219, 0.15);
      cursor: move;
      z-index: 100;
      touch-action: none;
    }

    .signature-box-controls {
      position: absolute;
      top: -32px; /* Ajustado */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px; /* Ajustado */
      padding: 2px; /* Ajustado */
      background-color: rgba(255, 255, 255, 0.85);
      border-radius: 5px; /* Ajustado */
      box-shadow: 0 1px 4px rgba(0,0,0,0.15); /* Sutil */
    }

    .signature-box-btn {
      width: 26px; /* Ajustado */
      height: 26px; /* Ajustado */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px; /* Ajustado */
      border: none;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    }
    .signature-box-btn.confirm { background-color: #2ecc71; color: white; }
    .signature-box-btn.cancel { background-color: #e74c3c; color: white; }

    .resize-handle {
      position: absolute;
      width: 10px; /* Más pequeño */
      height: 10px; /* Más pequeño */
      background-color: #3498db;
      border: 1px solid white; /* Más sutil */
      border-radius: 50%;
      z-index: 101;
    }
    .resize-handle.nw { top: -5px; left: -5px; cursor: nwse-resize; }
    .resize-handle.ne { top: -5px; right: -5px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; cursor: nwse-resize; }

    .signature-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 10px;
    }

    .signature-container {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      width: 100%;
      max-width: 500px;
      height: auto;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }

    .signature-canvas-container {
      flex-grow: 1;
      border: 1px solid #b0bec5;
      margin-bottom: 10px;
      position: relative;
      min-height: 180px;
      border-radius: 4px;
      overflow: hidden;
    }

    #signature-canvas {
      width: 100%;
      height: 100%;
      background-color: #ffffff;
      cursor: crosshair;
      touch-action: none;
    }

    .signature-controls {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .signature-control-btn {
      padding: 10px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      flex-grow: 1;
      min-width: 90px;
      text-align: center;
      transition: background-color 0.2s ease;
    }
    .signature-control-btn.cancel { background-color: #ef5350; color: white; }
    .signature-control-btn.clear { background-color: #ffab40; color: white; }
    .signature-control-btn.confirm { background-color: #4caf50; color: white; }
    .signature-control-btn:hover { filter: brightness(110%); }


    .embedded-signature {
      position: absolute;
      z-index: 99;
      pointer-events: none;
      transform-origin: top left;
    }

    .message-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 15px;
    }
    .message-modal-content {
        background-color: white;
        padding: 20px 25px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        max-width: 400px;
        width: 100%;
    }
    .message-modal-content p {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1rem;
        color: #333;
    }
    .message-modal-content button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 25px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.95rem;
        transition: background-color 0.2s ease;
    }
    .message-modal-content button:hover {
        background-color: #2980b9;
    }

  </style>
</head>
<body>
  <header>
    <h2>Firmar Documento PDF</h2>
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" />
      <button class="toolbar-btn" onclick="prevPage()">⬅️ Anterior</button>
      <button class="toolbar-btn" onclick="nextPage()">➡️ Siguiente</button>
      <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
      <button class="toolbar-btn" onclick="downloadPDF()">📂 Guardar</button>
      </div>
    <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
  </header>

  <div id="pdf-viewer">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <div id="zoom-slider-container">
    <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
  </div>

  <script>
    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1;
    let canvas = document.getElementById('pdf-canvas');
    let context = canvas.getContext('2d');
    const pdfViewer = document.getElementById('pdf-viewer');
    let rendering = false;
    
    let isDraggingPdf = false;
    let startPos = { x: 0, y: 0 };
    let translatePos = { x: 0, y: 0 };
    let isZoomed = false;
    
    let embeddedSignatures = [];
    let isDraggingBox = false; 
    let signatureBoxDragOffset = { x: 0, y: 0 }; 

    let pinchState = {
        active: false,
        initialDistance: 0,
        lastScale: 1,
        pdfPointX: 0, 
        pdfPointY: 0, 
        screenCenterX: 0,
        screenCenterY: 0
    };

    function showMessage(message) {
        const existingModal = document.querySelector('.message-modal');
        if (existingModal) existingModal.remove();
        const modal = document.createElement('div');
        modal.className = 'message-modal';
        const content = document.createElement('div');
        content.className = 'message-modal-content';
        content.innerHTML = `<p>${message}</p><button>OK</button>`;
        modal.appendChild(content);
        document.body.appendChild(modal);
        content.querySelector('button').onclick = () => modal.remove();
    }

    document.getElementById('file-input').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'application/pdf') {
        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                 pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            }
            const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;
            currentPage = 1;
            translatePos = { x: 0, y: 0 };
            scale = 1;
            document.getElementById('zoom-slider').value = scale;
            document.getElementById('total-pages').textContent = totalPages;
            embeddedSignatures = [];
            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
            if (signatureBox) {
                signatureBox.remove();
                signatureBox = null;
            }
            renderPage(currentPage);
          } catch (err) {
            showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
            console.error("Error loading PDF:", err);
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file) {
        showMessage('Por favor, selecciona un archivo PDF.');
      }
    });

    function renderPage(num) {
      if (!pdfDoc || rendering) return;
      rendering = true;
      pdfDoc.getPage(num).then(page => {
        const dpr = window.devicePixelRatio || 1;
        const viewport = page.getViewport({ scale: scale * dpr }); // Scale viewport by DPR
        
        canvas.width = viewport.width;  // Set canvas bitmap size to scaled viewport
        canvas.height = viewport.height;

        // Set canvas CSS size to logical scale (undo DPR for display)
        canvas.style.width = `${viewport.width / dpr}px`;
        canvas.style.height = `${viewport.height / dpr}px`;

        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);

        // Center canvas (based on CSS size) if smaller than viewer
        if (cssCanvasWidth < viewerWidth) {
            canvas.style.left = `${(viewerWidth - cssCanvasWidth) / 2}px`;
        } else {
            canvas.style.left = '0px';
        }
        if (cssCanvasHeight < viewerHeight) {
            canvas.style.top = `${(viewerHeight - cssCanvasHeight) / 2}px`;
        } else {
            canvas.style.top = '0px';
        }
        canvas.style.position = 'absolute';

        // Context is already scaled by DPR because canvas.width/height is DPR-scaled
        const renderContext = { 
            canvasContext: context, 
            viewport: page.getViewport({ scale: scale * dpr }) // Re-get viewport for render context
        };
        
        const renderTask = page.render(renderContext);
        
        renderTask.promise.then(() => {
          rendering = false;
          document.getElementById('current-page').textContent = num;
          isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
          updateCanvasTransform();
          repositionSignatures();
        }).catch(err => {
            rendering = false;
            console.error("Error rendering page:", err);
            showMessage("Error al renderizar la página del PDF.");
        });
      }).catch(err => {
          rendering = false;
          console.error("Error getting page:", err);
          showMessage("Error al obtener la página del PDF.");
      });
    }

    function updateCanvasTransform() {
        canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
        repositionSignatures();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (pinchState.active) return;
      const cssCanvasWidth = parseFloat(canvas.style.width);
      const cssCanvasHeight = parseFloat(canvas.style.height);
      if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
      if (e.target !== canvas) return;

      isDraggingPdf = true;
      startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
      canvas.style.cursor = 'grabbing';
    });
    
    pdfViewer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            isDraggingPdf = false; 
            isResizing = false; 
            isDraggingBox = false;
            pinchState.active = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            pinchState.lastScale = scale;

            const viewerRect = pdfViewer.getBoundingClientRect();
            pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
            pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
            
            const canvasRect = canvas.getBoundingClientRect(); // Use CSS dimensions for screen point
            const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
            const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;

            pinchState.pdfPointX = pdfPointScreenX / scale; // Point on PDF, logical scale
            pinchState.pdfPointY = pdfPointScreenY / scale;

        } else if (e.touches.length === 1 && !pinchState.active) {
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            if ((!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) || e.target !== canvas) {
                 isDraggingPdf = false; return;
            }
            isDraggingPdf = true;
            const touch = e.touches[0];
            startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
        }
    }, { passive: false });


    function handlePdfMove(clientX, clientY) {
        if (!isDraggingPdf) return;
        
        let newTranslateX = clientX - startPos.x;
        let newTranslateY = clientY - startPos.y;
        
        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        // Use CSS dimensions for panning constraints
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);

        const overpanMargin = 30;

        if (cssCanvasWidth > viewerWidth) {
            const minX = viewerWidth - cssCanvasWidth - overpanMargin;
            const maxX = overpanMargin;
            newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
        } else {
            newTranslateX = 0;
        }

        if (cssCanvasHeight > viewerHeight) {
            const minY = viewerHeight - cssCanvasHeight - overpanMargin;
            const maxY = overpanMargin;
            newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
        } else {
            newTranslateY = 0;
        }
        
        translatePos.x = newTranslateX;
        translatePos.y = newTranslateY;
        updateCanvasTransform();
    }

    function handlePinchMove(touch1, touch2) {
        if (!pinchState.active || pinchState.initialDistance === 0) return;

        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
        newScale = Math.min(3.0, Math.max(0.5, newScale));

        scale = newScale; // Update global logical scale

        const viewerRect = pdfViewer.getBoundingClientRect();
        // canvas.offsetLeft/Top are CSS pixel offsets from parent (pdfViewer)
        translatePos.x = (pinchState.screenCenterX - viewerRect.left - canvas.offsetLeft) - (pinchState.pdfPointX * scale);
        translatePos.y = (pinchState.screenCenterY - viewerRect.top - canvas.offsetTop) - (pinchState.pdfPointY * scale);
        
        document.getElementById('zoom-slider').value = scale.toFixed(1);
        renderPage(currentPage); 
    }

    window.addEventListener('mousemove', (e) => {
        if (isDraggingPdf && !pinchState.active) handlePdfMove(e.clientX, e.clientY);
        if (isResizing) handleResizeMove(e.clientX, e.clientY);
        if (isDraggingBox) handleBoxDragMove(e.clientX, e.clientY);
    });

    window.addEventListener('touchmove', (e) => {
        if (pinchState.active && e.touches.length === 2) {
            e.preventDefault(); 
            handlePinchMove(e.touches[0], e.touches[1]);
        } else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) {
            const touch = e.touches[0];
            handlePdfMove(touch.clientX, touch.clientY);
        } else if (isResizing && e.touches.length === 1 && !pinchState.active) {
            e.preventDefault();
            const touch = e.touches[0];
            handleResizeMove(touch.clientX, touch.clientY);
        } else if (isDraggingBox && e.touches.length === 1 && !pinchState.active) {
            e.preventDefault();
            const touch = e.touches[0];
            handleBoxDragMove(touch.clientX, touch.clientY);
        }
    }, { passive: false });

    window.addEventListener('mouseup', () => {
        if (isDraggingPdf) {
            isDraggingPdf = false;
            canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default';
        }
        if (isDraggingBox) isDraggingBox = false;
        if (isResizing) { isResizing = false; resizeHandleType = null;}
    });
    window.addEventListener('touchend', (e) => {
        if (isDraggingPdf) isDraggingPdf = false;
        if (isDraggingBox) isDraggingBox = false;
        if (isResizing) { isResizing = false; resizeHandleType = null; }
        if (pinchState.active && e.touches.length < 2) pinchState.active = false;
    });

    function nextPage() {
      if (!pdfDoc || currentPage >= totalPages) return;
      currentPage++;
      translatePos = { x: 0, y: 0 };
      renderPage(currentPage);
    }

    function prevPage() {
      if (!pdfDoc || currentPage <= 1) return;
      currentPage--;
      translatePos = { x: 0, y: 0 };
      renderPage(currentPage);
    }

    document.getElementById('zoom-slider').addEventListener('input', function () {
      if (!pdfDoc) return;
      const oldScale = scale;
      scale = parseFloat(this.value);
      
      const viewerRect = pdfViewer.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();

      // Center of the viewer in screen coordinates
      const screenCenterX = viewerRect.left + viewerRect.width / 2;
      const screenCenterY = viewerRect.top + viewerRect.height / 2;

      // Point on PDF (unscaled) currently at the center of the viewer
      const pdfPointX = (screenCenterX - canvasRect.left) / oldScale;
      const pdfPointY = (screenCenterY - canvasRect.top) / oldScale;
      
      // Calculate new translatePos to keep this pdfPoint at the center of the viewer
      // after canvas.offsetLeft/Top might change due to re-centering in renderPage
      // This needs to be applied *after* renderPage sets the new canvas.offsetLeft/Top.
      // For simplicity, we'll calculate the expected new canvas.offsetLeft/Top
      const expectedCssCanvasWidth = (page.getViewport({scale: scale}).width / (window.devicePixelRatio||1));
      const expectedCssCanvasHeight = (page.getViewport({scale: scale}).height / (window.devicePixelRatio||1));
      
      let expectedCanvasOffsetLeft = 0;
      if (expectedCssCanvasWidth < viewerRect.width) {
          expectedCanvasOffsetLeft = (viewerRect.width - expectedCssCanvasWidth) / 2;
      }
      let expectedCanvasOffsetTop = 0;
      if (expectedCssCanvasHeight < viewerRect.height) {
          expectedCanvasOffsetTop = (viewerRect.height - expectedCssCanvasHeight) / 2;
      }
      
      translatePos.x = (screenCenterX - viewerRect.left - expectedCanvasOffsetLeft) - (pdfPointX * scale);
      translatePos.y = (screenCenterY - viewerRect.top - expectedCanvasOffsetTop) - (pdfPointY * scale);

      renderPage(currentPage);
      pinchState.lastScale = scale;
    });

    pdfViewer.addEventListener('wheel', function (e) {
      if (!pdfDoc) return;
      e.preventDefault();
      
      const oldScale = scale;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      let newScale = parseFloat((scale + delta).toFixed(1));
      newScale = Math.min(3.0, Math.max(0.5, newScale));
      
      if (newScale === oldScale) return;

      const viewerRect = pdfViewer.getBoundingClientRect();
      const mouseXViewer = e.clientX - viewerRect.left; 
      const mouseYViewer = e.clientY - viewerRect.top; 

      const canvasRect = canvas.getBoundingClientRect();
      const mouseXOnCanvas = e.clientX - canvasRect.left;
      const mouseYOnCanvas = e.clientY - canvasRect.top;

      const pdfPointX = mouseXOnCanvas / oldScale;
      const pdfPointY = mouseYOnCanvas / oldScale;

      scale = newScale;

      // After renderPage, canvas.offsetLeft/Top will be set based on new CSS size
      // We need to predict these to set translatePos correctly.
      const page = pdfDoc.getPage(currentPage); // Assuming pdfDoc and currentPage are valid
      const dpr = window.devicePixelRatio || 1;
      const tempViewport = page.getViewport({ scale: scale * dpr });
      const expectedCssWidth = tempViewport.width / dpr;
      const expectedCssHeight = tempViewport.height / dpr;

      let expectedCanvasLeft = 0;
      if (expectedCssWidth < viewerRect.width) {
          expectedCanvasLeft = (viewerRect.width - expectedCssWidth) / 2;
      }
      let expectedCanvasTop = 0;
      if (expectedCssHeight < viewerRect.height) {
          expectedCanvasTop = (viewerRect.height - expectedCssHeight) / 2;
      }
      
      translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
      translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);

      document.getElementById('zoom-slider').value = scale.toFixed(1);
      renderPage(currentPage);
    }, { passive: false });

    async function downloadPDF() {
        if (!pdfDoc) {
            showMessage("Carga un PDF primero.");
            return;
        }
        const { jsPDF } = window.jspdf;
        const newPdfDocGen = new jsPDF();
        while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }
        
        showMessage("Preparando PDF para descarga...");

        for (let i = 1; i <= totalPages; i++) {
            const page = await pdfDoc.getPage(i);
            // For download, use a fixed high scale for quality, ignore current view scale/DPR
            const downloadScale = 2.0; 
            const viewport = page.getViewport({ scale: downloadScale }); 

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;

            await page.render({ canvasContext: tempCtx, viewport }).promise;

            embeddedSignatures.filter(sig => sig.page === i).forEach(sigInfo => {
                const img = new Image();
                img.src = sigInfo.dataURL;
                // sigInfo.x,y,width,height are unscaled PDF units. Scale them by downloadScale.
                const x = sigInfo.x * downloadScale; 
                const y = sigInfo.y * downloadScale;
                const width = sigInfo.width * downloadScale;
                const height = sigInfo.height * downloadScale;
                tempCtx.drawImage(img, x, y, width, height);
            });
            
            const imgData = tempCanvas.toDataURL('image/jpeg', 0.9); // Slightly higher quality for download
            
            newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
            newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
        }
        
        newPdfDocGen.save('documento-firmado.pdf');
        showMessage("PDF guardado.");
    }

    let signatureBox = null;
    let isResizing = false;
    let resizeHandleType = null;
    let startBoxPos = { x: 0, y: 0 };
    let startBoxSize = { width: 0, height: 0 };
    let startPointerPos = { x: 0, y: 0 }; 

    let signatureModal = null;
    let signaturePadCanvas = null; 
    let signaturePadCtx = null;
    let isDrawingOnPad = false;
    let lastDrawPadPos = { x: 0, y: 0 };

    function addSignatureBox() {
      if (!pdfDoc) {
        showMessage("Por favor, carga un documento PDF primero.");
        return;
      }
      if (signatureBox) { signatureBox.remove(); }
      signatureBox = document.createElement('div');
      signatureBox.className = 'signature-box';
      signatureBox.style.width = '150px'; 
      signatureBox.style.height = '75px';
      const viewerRect = pdfViewer.getBoundingClientRect();
      signatureBox.style.left = `${(viewerRect.width - 150) / 2}px`;
      signatureBox.style.top = `${(viewerRect.height - 75) / 2}px`;
      const controls = document.createElement('div');
      controls.className = 'signature-box-controls';
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-box-btn confirm';
      confirmBtn.innerHTML = '✔️';
      confirmBtn.title = 'Confirmar posición y firmar';
      confirmBtn.onclick = openSignatureModal;
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-box-btn cancel';
      cancelBtn.innerHTML = '❌';
      cancelBtn.title = 'Cancelar firma';
      cancelBtn.onclick = () => { signatureBox.remove(); signatureBox = null; };
      controls.appendChild(confirmBtn);
      controls.appendChild(cancelBtn);
      signatureBox.appendChild(controls);
      addResizeHandles(signatureBox);
      setupBoxDragEvents(signatureBox);
      pdfViewer.appendChild(signatureBox);
    }

    function addResizeHandles(box) {
      const handles = ['nw', 'ne', 'sw', 'se'];
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        box.appendChild(handle);
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          initResize(e.clientX, e.clientY, pos, box);
        });
        handle.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          if (e.touches.length === 1) {
            e.preventDefault();
            initResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
          }
        }, { passive: false });
      });
    }

    function initResize(clientX, clientY, handlePos, box) {
        isResizing = true;
        resizeHandleType = handlePos;
        startBoxPos = { x: box.offsetLeft, y: box.offsetTop };
        startBoxSize = { width: box.offsetWidth, height: box.offsetHeight };
        startPointerPos = { x: clientX, y: clientY };
        isDraggingPdf = false; 
        isDraggingBox = false; 
        pinchState.active = false;
    }
    
    function handleResizeMove(clientX, clientY) {
        if (!isResizing || !resizeHandleType || !signatureBox) return;
        const deltaX = clientX - startPointerPos.x;
        const deltaY = clientY - startPointerPos.y;
        let newWidth = startBoxSize.width;
        let newHeight = startBoxSize.height;
        let newLeft = startBoxPos.x;
        let newTop = startBoxPos.y;
        const minWidth = 50;
        const minHeight = 30;
        const viewerRect = pdfViewer.getBoundingClientRect();
        if (resizeHandleType.includes('w')) { newWidth = Math.max(minWidth, startBoxSize.width - deltaX); newLeft = startBoxPos.x + (startBoxSize.width - newWidth); }
        if (resizeHandleType.includes('e')) { newWidth = Math.max(minWidth, startBoxSize.width + deltaX); }
        if (resizeHandleType.includes('n')) { newHeight = Math.max(minHeight, startBoxSize.height - deltaY); newTop = startBoxPos.y + (startBoxSize.height - newHeight); }
        if (resizeHandleType.includes('s')) { newHeight = Math.max(minHeight, startBoxSize.height + deltaY); }
        if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
        if (newTop < 0) { newHeight += newTop; newTop = 0; }
        if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
        if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }
        newWidth = Math.max(minWidth, newWidth);
        newHeight = Math.max(minHeight, newHeight);
        signatureBox.style.width = `${newWidth}px`;
        signatureBox.style.height = `${newHeight}px`;
        signatureBox.style.left = `${newLeft}px`;
        signatureBox.style.top = `${newTop}px`;
    }

    function setupBoxDragEvents(box) {
        function initBoxDrag(clientX, clientY) {
            isDraggingBox = true;
            const viewerRect = pdfViewer.getBoundingClientRect();
            signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
            signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;
            isDraggingPdf = false; 
            isResizing = false; 
            pinchState.active = false;
        }
        box.addEventListener('mousedown', (e) => {
            if (e.target === box) { 
                e.stopPropagation();
                initBoxDrag(e.clientX, e.clientY);
            }
        });
        box.addEventListener('touchstart', (e) => {
            if (e.target === box && e.touches.length === 1) {
                e.stopPropagation();
                e.preventDefault();
                initBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
    }
    
    function handleBoxDragMove(clientX, clientY) {
        if (!isDraggingBox || !signatureBox) return;
        const viewerRect = pdfViewer.getBoundingClientRect();
        let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
        let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;
        newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBox.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBox.offsetHeight));
        signatureBox.style.left = `${newLeft}px`;
        signatureBox.style.top = `${newTop}px`;
    }

    function openSignatureModal() {
      if (!signatureBox) return;
      signatureModal = document.createElement('div');
      signatureModal.className = 'signature-modal';
      const container = document.createElement('div');
      container.className = 'signature-container';
      const canvasContainer = document.createElement('div');
      canvasContainer.className = 'signature-canvas-container';
      signaturePadCanvas = document.createElement('canvas'); 
      signaturePadCanvas.id = 'signature-canvas'; 
      canvasContainer.appendChild(signaturePadCanvas);
      container.appendChild(canvasContainer);
      signaturePadCtx = signaturePadCanvas.getContext('2d');
      const controls = document.createElement('div');
      controls.className = 'signature-controls';
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-control-btn cancel';
      cancelBtn.textContent = '❌ Cancelar';
      cancelBtn.onclick = () => { signatureModal.remove(); signatureModal = null; };
      const clearBtn = document.createElement('button');
      clearBtn.className = 'signature-control-btn clear';
      clearBtn.textContent = '↩️ Limpiar';
      clearBtn.onclick = () => { signaturePadCtx.clearRect(0, 0, signaturePadCanvas.width, signaturePadCanvas.height); };
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-control-btn confirm';
      confirmBtn.textContent = '✔️ Firmar';
      confirmBtn.onclick = embedSignature;
      controls.appendChild(cancelBtn);
      controls.appendChild(clearBtn);
      controls.appendChild(confirmBtn);
      container.appendChild(controls);
      signatureModal.appendChild(container);
      document.body.appendChild(signatureModal);
      requestAnimationFrame(() => { 
        const rect = canvasContainer.getBoundingClientRect();
        signaturePadCanvas.width = rect.width; 
        signaturePadCanvas.height = rect.height; 
        signaturePadCtx.lineWidth = 2; 
        signaturePadCtx.lineCap = 'round';
        signaturePadCtx.strokeStyle = '#000000';
      });
      setupSignaturePadDrawingEvents();
    }

    function setupSignaturePadDrawingEvents() {
      function getPadPosition(e) {
        const rect = signaturePadCanvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
          x: (clientX - rect.left) * (signaturePadCanvas.width / rect.width),
          y: (clientY - rect.top) * (signaturePadCanvas.height / rect.height)
        };
      }
      function startPadDraw(e) {
        e.preventDefault(); 
        isDrawingOnPad = true;
        lastDrawPadPos = getPadPosition(e);
      }
      function drawOnPad(e) {
        if (!isDrawingOnPad) return;
        e.preventDefault();
        const currentPos = getPadPosition(e);
        signaturePadCtx.beginPath();
        signaturePadCtx.moveTo(lastDrawPadPos.x, lastDrawPadPos.y);
        signaturePadCtx.lineTo(currentPos.x, currentPos.y);
        signaturePadCtx.stroke();
        lastDrawPadPos = currentPos;
      }
      function stopPadDraw() { isDrawingOnPad = false; }
      signaturePadCanvas.addEventListener('mousedown', startPadDraw);
      signaturePadCanvas.addEventListener('mousemove', drawOnPad);
      signaturePadCanvas.addEventListener('mouseup', stopPadDraw);
      signaturePadCanvas.addEventListener('mouseout', stopPadDraw);
      signaturePadCanvas.addEventListener('touchstart', startPadDraw, { passive: false });
      signaturePadCanvas.addEventListener('touchmove', drawOnPad, { passive: false });
      signaturePadCanvas.addEventListener('touchend', stopPadDraw);
    }

    function embedSignature() {
        if (!signatureBox || !signaturePadCanvas || signaturePadCtx.canvas.toDataURL() === document.createElement('canvas').toDataURL()) {
            showMessage("Por favor, dibuja una firma primero.");
            return;
        }
        const dataURL = signaturePadCanvas.toDataURL('image/png');
        const signatureImgElement = document.createElement('img');
        signatureImgElement.className = 'embedded-signature';
        signatureImgElement.src = dataURL;

        // Calculate signature position relative to the unscaled PDF page
        const boxCssLeft = signatureBox.offsetLeft; // Relative to pdfViewer
        const boxCssTop = signatureBox.offsetTop;   // Relative to pdfViewer
        
        // Canvas's CSS offset within pdfViewer (due to centering)
        const canvasCssOffsetLeft = canvas.offsetLeft;
        const canvasCssOffsetTop = canvas.offsetTop;

        // Signature box's position relative to the *displayed* (scaled and translated) PDF canvas content
        const sigBoxRelativeToDisplayedCanvasX = boxCssLeft - canvasCssOffsetLeft - translatePos.x;
        const sigBoxRelativeToDisplayedCanvasY = boxCssTop - canvasCssOffsetTop - translatePos.y;

        // Convert to unscaled PDF page coordinates
        const sigPageX = sigBoxRelativeToDisplayedCanvasX / scale;
        const sigPageY = sigBoxRelativeToDisplayedCanvasY / scale;
        const sigPageWidth = signatureBox.offsetWidth / scale;
        const sigPageHeight = signatureBox.offsetHeight / scale;

        const signatureInfo = {
            element: signatureImgElement, page: currentPage,
            x: sigPageX, y: sigPageY, width: sigPageWidth, height: sigPageHeight,
            dataURL: dataURL
        };
        embeddedSignatures.push(signatureInfo);
        pdfViewer.appendChild(signatureImgElement);
        signatureBox.remove(); signatureBox = null;
        if (signatureModal) { signatureModal.remove(); signatureModal = null; }
        repositionSignatures();
    }

    function repositionSignatures() {
        if (!pdfViewer) return;
        const viewerRect = pdfViewer.getBoundingClientRect();
        const pdfCanvasRect = canvas.getBoundingClientRect(); 

        const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
        const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;

        embeddedSignatures.forEach(sig => {
            if (sig.element) {
                if (sig.page === currentPage) {
                    const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                    const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                    const displayWidth = sig.width * scale;
                    const displayHeight = sig.height * scale;
                    sig.element.style.left = `${displayX}px`;
                    sig.element.style.top = `${displayY}px`;
                    sig.element.style.width = `${displayWidth}px`;
                    sig.element.style.height = `${displayHeight}px`;
                    sig.element.style.display = 'block';
                } else {
                    sig.element.style.display = 'none';
                }
            }
        });
    }

    function adjustViewerHeightAndRender() {
        const headerElement = document.querySelector('header');
        if (headerElement && pdfViewer) {
            const headerHeight = headerElement.offsetHeight;
            pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
        }
        if (pdfDoc) { renderPage(currentPage); }
    }

    window.addEventListener('load', adjustViewerHeightAndRender);
    window.addEventListener('resize', adjustViewerHeightAndRender);

  </script>
</body>
</html>
