<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Firmar Documento PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* ... (Tu CSS completo existente) ... */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #e9ecef;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        .container {
            background-color: #ffffff;
            padding: 25px 30px;
            border-radius: 0.3rem;
            box-shadow: 0 0.5rem 1rem rgba(0,0,0,.15);
            max-width: 450px;
            width: 100%;
        }
        h1 {
            color: #343a40;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4rem;
            font-weight: 500;
        }
        p {
            color: #495057;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        #qr-code-display { /* Contenedor del QR */
            margin: 15px auto;
            border: 1px solid #dee2e6;
            padding: 8px;
            background-color: #fff;
            display: inline-block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            width: 166px; /* Para QR de 150px + padding */
            height: 166px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #qr-code-display img { /* Estilo para la imagen del QR */
            max-width: 100%;
            max-height: 100%;
        }
        .url-section {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .url-section p { /* "Enlace para firmar:" */
            margin-bottom: 5px;
            font-weight: 500;
            color: #212529;
            font-size: 0.85rem;
        }
        #shareable-url-input {
            padding: 0.4rem 0.6rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            background-color: #f8f9fa;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            margin-bottom: 10px; /* Espacio antes del mensaje de estado */
        }
        #status-message {
            margin-top: 15px;
            font-weight: bold;
            font-size: 0.9rem;
        }
        /* Aquí empieza el CSS del segundo script */
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #e9ecef;
            overflow: hidden; /* Evita el scroll en el body, el visor lo manejará */
        }

        header {
            background: #343a40;
            color: white;
            padding: 0.5rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative; /* Para z-index si fuera necesario */
            z-index: 1000; /* Asegura que el header esté sobre el visor */
        }

        header h2 {
            margin-top: 0.2rem;
            margin-bottom: 0.5rem;
            font-size: 1.15rem;
            font-weight: 500;
        }

        .navigation-toolbar {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 380px; /* Limita el ancho para mejor apariencia */
            margin: 0 auto 0.5rem auto; /* Centrado y espacio inferior */
        }

        #page-info {
            margin: 0 0.8rem;
            font-size: 0.8rem;
            white-space: nowrap;
            color: #adb5bd; /* Un color más suave para la información de página */
        }

        #toolbar {
            display: flex;
            flex-wrap: wrap; /* Permite que los botones pasen a la siguiente línea si no caben */
            justify-content: center;
            align-items: center;
            gap: 0.3rem; /* Espacio pequeño entre botones */
            width: 100%;
        }

        .toolbar-btn {
            background: #007bff;
            border: none;
            padding: 0.45rem 0.8rem; /* Ajuste de padding */
            margin: 0.15rem; /* Margen pequeño */
            color: white;
            font-size: 0.8rem; /* Tamaño de fuente reducido para botones */
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            flex-grow: 0; /* No crecer */
            flex-basis: auto; /* Basado en contenido */
        }
        .toolbar-btn:hover {
            background-color: #0056b3;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25); /* Sombra de foco sutil */
        }
        .toolbar-btn.page-nav-btn {
            min-width: auto; /* Ancho automático */
            padding: 0.4rem 0.7rem; /* Padding específico para botones de página */
            background-color: #495057; /* Color diferente para navegación de página */
        }
        .toolbar-btn.page-nav-btn:hover {
            background-color: #343a40;
            box-shadow: 0 0 0 0.2rem rgba(108,117,125,.25);
        }


        #pdf-viewer {
            width: 100vw;
            /* height será ajustado por JS para ocupar el espacio restante */
            overflow: hidden; /* El canvas interno puede ser más grande */
            background: #f8f9fa; /* Un fondo ligeramente diferente al body */
            position: relative; /* Para posicionar el canvas y otros elementos internos */
            display: flex; /* Para centrar el canvas si es más pequeño que el visor */
            justify-content: center;
            align-items: center;
            touch-action: none; /* Previene acciones táctiles por defecto como scroll/zoom en el visor mismo */
        }

        .page-usage-counter {
            position: absolute;
            top: 8px; /* Espaciado desde la parte superior del visor */
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 0.7rem; /* Pequeño para no ser intrusivo */
            border-radius: 0.2rem;
            z-index: 50; /* Sobre el canvas, debajo de modales */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        #current-page-visits {
            left: 8px;
        }
        #total-page-views {
            right: 8px;
        }


        #pdf-canvas {
            cursor: grab; /* Indica que se puede arrastrar */
            image-rendering: -webkit-optimize-contrast; /* Mejora la nitidez en Chrome/Safari */
            image-rendering: crisp-edges; /* Mejora la nitidez en Firefox */
            box-shadow: 0 0 10px rgba(0,0,0,0.1); /* Sombra sutil para dar profundidad */
        }

        #zoom-slider-container {
            position: fixed; /* Fijo en la pantalla */
            right: 8px; /* Pegado a la derecha */
            top: 50%; /* Centrado verticalmente */
            transform: translateY(-50%);
            background: rgba(52, 58, 64, 0.8); /* Fondo semitransparente */
            padding: 6px;
            border-radius: 0.25rem;
            z-index: 9999; /* Encima de casi todo */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        #zoom-slider {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 16px; /* Ancho del slider vertical */
            height: 100px; /* Altura del slider */
            transform: rotate(180deg); /* Para que el mínimo esté abajo */
        }

        /* Estilo para el input de archivo */
        input[type="file"]#file-input {
            padding: 0.4rem;
            border-radius: 0.25rem;
            border: 1px solid #ced4da;
            background-color: #fff;
            color: #495057;
            cursor: pointer;
            font-size: 0.75rem; /* Tamaño de fuente más pequeño */
            max-width: 240px; /* Evita que sea demasiado ancho */
            margin: 0.15rem; /* Margen consistente con otros botones */
        }
        input[type="file"]#file-input::file-selector-button { /* Estilo del botón interno del input file */
            background: #6c757d;
            color: white;
            border: none;
            padding: 0.4rem 0.7rem;
            border-radius: 0.2rem;
            cursor: pointer;
            margin-right: 8px; /* Espacio entre el botón y el texto del archivo */
        }

        /* Estilos para el cuadro de firma interactivo */
        .signature-box {
            position: absolute;
            border: 1px solid #007bff; /* Borde azul distintivo */
            background-color: rgba(0, 123, 255, 0.08); /* Fondo azul muy sutil */
            cursor: move; /* Cursor por defecto cuando es arrastrable */
            z-index: 100; /* Encima del canvas PDF, debajo de modales */
            touch-action: none; /* Importante para el arrastre táctil */
            border-radius: 3px;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.35), 0 1px 4px rgba(0,0,0,0.15); /* Para mayor visibilidad */
        }
        .signature-box.position-confirmed {
            cursor: default; /* Cursor cuando la posición está bloqueada */
            border: 1px dashed #6c757d; /* Borde discontinuo gris */
            background-color: transparent; /* o rgba(0, 123, 255, 0.02) para un leve tinte */
            box-shadow: none; /* Sin sombra activa */
        }


        .signature-box-controls {
            position: absolute;
            top: -38px; /* Posicionado encima del cuadro */
            left: 50%;
            transform: translateX(-50%); /* Centrado horizontalmente */
            display: flex;
            gap: 8px; /* Espacio entre botones de control */
            padding: 5px;
            background-color: #fff; /* Fondo para los controles */
            border-radius: 0.25rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        .signature-box-btn {
            width: 30px; /* Botones circulares */
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px; /* Tamaño del ícono/emoji */
            border: none;
            color: white;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s ease;
        }
        .signature-box-btn:hover {
            transform: scale(1.1); /* Efecto de zoom al pasar el mouse */
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
        .signature-box-btn.confirm { background-color: #28a745; } /* Verde */
        .signature-box-btn.cancel { background-color: #dc3545; } /* Rojo */
        .signature-box-btn.edit { background-color: #ffc107; color: #212529; } /* Amarillo, texto oscuro */
        .signature-box-btn.draw { background-color: #007bff; } /* Azul */


        .resize-handle {
            position: absolute;
            width: 12px; /* Mayor área táctil */
            height: 12px;
            background-color: #fff; /* Color de fondo del manejador */
            border: 2px solid #007bff; /* Borde para visibilidad */
            border-radius: 50%; /* Circular */
            z-index: 101; /* Encima del signature-box */
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

        /* Estilos para el modal de firma */
        .signature-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Overlay más oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Muy alto para estar sobre todo */
            padding: 10px; /* Espacio por si el modal es muy grande */
        }

        .signature-container {
            background-color: #ffffff; /* Fondo blanco */
            padding: 25px; /* Más padding */
            border-radius: 0.3rem; /* Radio de borde consistente */
            width: 100%;
            max-width: 550px; /* Ancho máximo para pantallas grandes */
            height: auto;
            max-height: 90vh; /* Asegura que quepa en la vista */
            display: flex;
            flex-direction: column;
            box-shadow: 0 0.5rem 1rem rgba(0,0,0,.15); /* Sombra más suave */
        }

        .signature-canvas-container {
            flex-grow: 1; /* Permite que el canvas tome el espacio disponible */
            border: 1px solid #ced4da; /* Borde estándar */
            margin-bottom: 20px; /* Espacio antes de los controles */
            position: relative; /* Para el canvas interno */
            min-height: 200px; /* Área mínima de dibujo */
            border-radius: 0.25rem; /* Bordes redondeados */
            overflow: hidden; /* Recorta el canvas si se desborda */
            background-color: #fff; /* Asegura fondo blanco si el canvas es transparente */
        }

        #signature-canvas {
            width: 100%;
            height: 100%;
            background-color: transparent; /* Deja que el CSS controle el fondo */
            cursor: crosshair;
            touch-action: none; /* Para dibujar en dispositivos táctiles */
        }

        .signature-controls {
            display: flex;
            justify-content: space-between; /* Distribuye los botones */
            flex-wrap: wrap; /* Envuelve los botones en pantallas pequeñas */
            gap: 10px; /* Espacio entre botones */
        }

        .signature-control-btn {
            padding: 0.6rem 1rem; /* Padding cómodo */
            border: none;
            border-radius: 0.25rem; /* Radio de borde consistente */
            cursor: pointer;
            font-size: 0.9rem;
            flex-grow: 1; /* Permite que los botones crezcan */
            min-width: 100px; /* Ancho mínimo para legibilidad */
            text-align: center;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            font-weight: 500; /* Texto ligeramente más grueso */
        }
        .signature-control-btn:hover {
            transform: translateY(-2px); /* Efecto sutil de elevación */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Sombra más suave al pasar el mouse */
        }
        .signature-control-btn.cancel { background-color: #dc3545; color: white; }
        .signature-control-btn.clear { background-color: #ffc107; color: #212529; } /* Texto más oscuro para amarillo */
        .signature-control-btn.confirm { background-color: #28a745; color: white; }


        /* Estilo para la imagen de firma ya incrustada en el PDF viewer */
        .embedded-signature {
            position: absolute;
            z-index: 99; /* Debajo del signature-box pero encima del canvas PDF */
            pointer-events: none; /* Permite que los clics pasen al PDF si es necesario */
            transform-origin: top left; /* Asegura que el escalado sea desde la esquina superior izquierda */
        }

        /* Estilos para el modal de mensajes genérico */
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000; /* Encima de todo, incluso el modal de firma */
            padding: 15px;
        }
        .message-modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 0.3rem;
            text-align: center;
            box-shadow: 0 0.5rem 1rem rgba(0,0,0,.175);
            max-width: 400px; /* Limita el ancho del modal */
            width: 100%;
        }
        .message-modal-content p {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1rem;
            color: #212529; /* Texto más oscuro para mejor legibilidad */
            white-space: pre-wrap; /* Para respetar saltos de línea \n */
        }
        .message-modal-content button, .message-modal-content input { /* Estilo común para botón e input en modal */
            background-color: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1.25rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.95rem;
            transition: background-color 0.2s ease;
            display: block; /* Ocupa todo el ancho */
            width: 100%;
            margin-top: 10px; /* Espacio si hay varios elementos */
        }
        .message-modal-content button:hover {
            background-color: #0056b3;
        }
        .message-modal-content input { /* Estilo específico para input si es necesario */
            background-color: #fff;
            color: #495057;
            border: 1px solid #ced4da;
            margin-bottom: 10px;
            text-align: left;
            cursor: text;
        }

        /* Estilo para el área de firma de Usuario B */
        .user-b-signature-area {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.08);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 98; /* Encima del PDF, debajo de otros controles si los hubiera */
        }
        .user-b-signature-area span {
            color:#007bff;
            font-size:0.9em;
            padding:5px;
        }

    </style>
</head>
<body>
    <header>
        <h2>Firmar Documento PDF</h2>
        <div class="navigation-toolbar">
            <button class="toolbar-btn page-nav-btn" onclick="prevPage()">⬅️ Anterior</button>
            <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
            <button class="toolbar-btn page-nav-btn" onclick="nextPage()">➡️ Siguiente</button>
        </div>
        <div id="toolbar">
            <input type="file" id="file-input" accept="application/pdf" />
            <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
            <button class="toolbar-btn" id="save-pdf-btn" onclick="downloadPDF()">📂 Guardar</button> <button class="toolbar-btn" id="share-pdf-btn" onclick="sharePDF()">📤 Compartir</button>
            <button class="toolbar-btn" id="check-signatures-btn" onclick="checkSignaturesStatus()" style="display: none;">🔍 Verificar Firmas</button>
        </div>
    </header>

    <div id="pdf-viewer">
        <canvas id="pdf-canvas"></canvas>
        <div id="current-page-visits" class="page-usage-counter" title="Visitas a esta página">P: 0</div>
        <div id="total-page-views" class="page-usage-counter" title="Total vistas de página">T: 0</div>
    </div>

    <div id="zoom-slider-container">
        <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
    </div>

    <script>
        // --- Configuración de Supabase ---
        const SUPABASE_URL = 'https://clkxkehypxmcqxcalmwn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa3hrZWh5cHhtY3F4Y2FsbXduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzNzgxMjIsImV4cCI6MjA2Mzk1NDEyMn0.eINgBpLReFf_PJmdsM2SVSD9QmuGs4FJe6jcJkp9wCg';

        let supabaseClient = null;

        function showMessage(message, isUrl = false, urlToCopy = '') {
            const existingModal = document.querySelector('.message-modal');
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.className = 'message-modal';
            const content = document.createElement('div');
            content.className = 'message-modal-content';
            let htmlContent = `<p>${message.replace(/\n/g, '<br>')}</p>`;
            if (isUrl && urlToCopy) {
                htmlContent += `<input type="text" value="${urlToCopy}" id="shareable-url-input" readonly style="width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">`;
                htmlContent += `<button id="copy-url-btn">Copiar URL</button>`;
            }
            htmlContent += `<button id="ok-message-btn" style="margin-top: ${isUrl && urlToCopy ? '5px' : '0'};">OK</button>`;
            content.innerHTML = htmlContent;
            modal.appendChild(content);
            document.body.appendChild(modal);
            content.querySelector('#ok-message-btn').onclick = () => modal.remove();
            if (isUrl && urlToCopy) {
                const copyBtn = content.querySelector('#copy-url-btn');
                const urlInput = content.querySelector('#shareable-url-input');
                copyBtn.onclick = () => {
                    urlInput.select();
                    urlInput.setSelectionRange(0, 99999);
                    try {
                        if (navigator.clipboard && window.isSecureContext) {
                            navigator.clipboard.writeText(urlToCopy).then(() => {
                                copyBtn.textContent = '¡Copiado!';
                                setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                            }).catch(err => { 
                                console.warn('navigator.clipboard.writeText falló, intentando execCommand:', err);
                                if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                                copyBtn.textContent = '¡Copiado (fallback)!';
                                setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                            });
                        } else { 
                            if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                            copyBtn.textContent = '¡Copiado (fallback)!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        }
                    } catch (err) {
                        console.error('Error al copiar URL:', err);
                        showMessage('Error al copiar. Por favor, copia manualmente.');
                    }
                };
            }
        }
        
        try {
            if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'TU_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'TU_SUPABASE_ANON_KEY') {
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    global: {
                        fetch: fetch // Esto ayuda con problemas de CORS en entornos locales.
                    }
                });
                console.info("Cliente de Supabase inicializado correctamente.");
            } else {
                const placeholderErrorMsg = "Configuración Incompleta: Supabase URL o Anon Key son incorrectas.\n\nLa función de compartir no funcionará.";
                console.warn(placeholderErrorMsg);
                if (typeof showMessage === 'function') { 
                    showMessage(placeholderErrorMsg);
                }
                supabaseClient = null; 
            }
        } catch (error) {
            console.error("Error CRÍTICO inicializando Supabase:", error);
            let detail = (error && error.message) ? error.message : (typeof error === 'string' ? error : "Error desconocido.");
            const initErrorMsg = `Error CRÍTICO al inicializar Supabase:\n\n${detail}\n\nLa función de compartir no funcionará.`;
            if (typeof showMessage === 'function') { 
                showMessage(initErrorMsg);
            }
            supabaseClient = null;
        }

        let pdfDoc = null;
        let originalFileName = 'documento.pdf';
        let originalPdfFileBlob = null; 
        let currentPage = 1;
        let totalPages = 0;
        let scale = 1;
        let canvas = document.getElementById('pdf-canvas');
        let context = canvas.getContext('2d');
        const pdfViewer = document.getElementById('pdf-viewer');
        let rendering = false;

        let isDraggingPdf = false;
        let startPos = { x: 0, y: 0 };
        let translatePos = { x: 0, y: 0 };
        let isZoomed = false;

        let embeddedSignatures = []; // Contiene las firmas incrustadas del Usuario A y B
        let signatureBoxEl = null; 
        let activeSignatureBoxInfo = null; 
        let isDraggingSigBox = false;
        let isResizingSigBox = false;
        let signatureBoxDragOffset = { x: 0, y: 0 };
        let resizeHandleTypeSigBox = null;
        let startBoxPosSigBox = { x: 0, y: 0 };
        let startBoxSizeSigBox = { width: 0, height: 0 };
        let startPointerPosSigBox = { x: 0, y: 0 };

        let signatureModalEl = null;
        let signaturePadCanvasEl = null;
        let signaturePadCtxEl = null;
        let isDrawingOnPadEl = false;
        let lastDrawPadPosEl = { x: 0, y: 0 };

        let pinchState = {
            active: false, initialDistance: 0, lastScale: 1,
            pdfPointX: 0, pdfPointY: 0,
            screenCenterX: 0, screenCenterY: 0
        };

        let pageVisitCounts = {};
        let totalPageViewsSession = 0;

        let sharedDocIdForUserA = null; // Variable crucial para el Usuario A
        let markerDataForUserB = null; // Variable crucial para el Usuario B


        document.getElementById('file-input').addEventListener('change', function () {
            const file = this.files[0];
            if (file && file.type === 'application/pdf') {
                originalFileName = file.name;
                originalPdfFileBlob = file; 
                
                // Limpiar el ID de documento compartido si se carga un nuevo PDF
                sharedDocIdForUserA = null;
                // Al cargar un nuevo PDF, cerramos cualquier listener Realtime anterior
                if (realtimeSubscription) {
                    realtimeSubscription.unsubscribe();
                    realtimeSubscription = null;
                    console.log("Realtime: Suscripción anterior cerrada debido a nueva carga de PDF.");
                }

                const checkBtn = document.getElementById('check-signatures-btn');
                if (checkBtn) checkBtn.style.display = 'none';
                markerDataForUserB = null; 
                const userBArea = document.getElementById('user-b-sig-area');
                if(userBArea) userBArea.remove();

                const reader = new FileReader();
                reader.onload = async function (e) {
                    try {
                        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                        }
                        const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
                        pdfDoc = await loadingTask.promise;
                        totalPages = pdfDoc.numPages;
                        currentPage = 1;
                        translatePos = { x: 0, y: 0 }; 
                        scale = 1; 
                        document.getElementById('zoom-slider').value = scale;
                        document.getElementById('total-pages').textContent = totalPages;
                        document.getElementById('current-page').textContent = currentPage;
                        
                        embeddedSignatures = [];
                        document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
                        if (signatureBoxEl) {
                            console.log("[file-input] Removing existing signatureBoxEl due to new file load.");
                            signatureBoxEl.remove();
                            signatureBoxEl = null; 
                        }
                        activeSignatureBoxInfo = null; 
                        pageVisitCounts = {};
                        totalPageViewsSession = 0;
                        updatePageUsageCounters(); 
                        renderPage(currentPage);
                    } catch (err) {
                        showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
                        console.error("Error loading PDF:", err);
                        pdfDoc = null; 
                        originalPdfFileBlob = null;
                    }
                };
                reader.readAsArrayBuffer(file);
            } else if (file) {
                showMessage('Por favor, selecciona un archivo PDF.');
                originalPdfFileBlob = null;
            }
                this.value = null; 
        });

        function updatePageUsageCounters() {
            if (!pdfDoc) return;
            pageVisitCounts[currentPage] = (pageVisitCounts[currentPage] || 0) + 1;
            totalPageViewsSession++;
            document.getElementById('current-page-visits').textContent = `P${currentPage}: ${pageVisitCounts[currentPage]}`;
            document.getElementById('total-page-views').textContent = `T: ${totalPageViewsSession}`;
        }

        async function renderPage(num) { 
            if (!pdfDoc || rendering) return;
            rendering = true;
            
            // Ocultar el área de firma de Usuario B si existe y no estamos en la página correcta
            const userBArea = document.getElementById('user-b-sig-area');
            if(userBArea) {
                if (markerDataForUserB && markerDataForUserB.page === num) {
                    userBArea.style.display = 'flex'; // Mostrar si estamos en la página de su marcador
                } else {
                    userBArea.style.display = 'none'; // Ocultar si no estamos en la página de su marcador
                }
            }
            
            updatePageUsageCounters(); 
            
            try {
                const page = await pdfDoc.getPage(num);
                const dpr = window.devicePixelRatio || 1; 
                const viewportForRender = page.getViewport({ scale: scale * dpr }); 
                canvas.width = viewportForRender.width;
                canvas.height = viewportForRender.height;
                
                const viewportCss = page.getViewport({ scale: scale });
                canvas.style.width = `${viewportCss.width}px`;
                canvas.style.height = `${viewportCss.height}px`;
                
                const viewerWidth = pdfViewer.clientWidth;
                const viewerHeight = pdfViewer.clientHeight;
                const cssCanvasWidth = viewportCss.width;
                const cssCanvasHeight = viewportCss.height;

                canvas.style.left = (cssCanvasWidth < viewerWidth) ? `${(viewerWidth - cssCanvasWidth) / 2}px` : '0px';
                canvas.style.top = (cssCanvasHeight < viewerHeight) ? `${(viewerHeight - cssCanvasHeight) / 2}px` : '0px';
                canvas.style.position = 'absolute'; 
                
                const renderContext = { canvasContext: context, viewport: viewportForRender };
                await page.render(renderContext).promise;

                rendering = false;
                document.getElementById('current-page').textContent = num;
                isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
                updateCanvasTransform(); 

            } catch (err) {
                rendering = false; 
                console.error("Error en renderPage:", err); 
                showMessage("Error al renderizar la página del PDF.");
            }
        }

        function updateCanvasTransform() {
            canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
            repositionSignatures(); 
            repositionActiveSignatureBox(); 
            if (markerDataForUserB && markerDataForUserB.page === currentPage && pdfDoc && !rendering) { 
                displayMarkerForUserB(markerDataForUserB);
            }
        }
        
        canvas.addEventListener('mousedown', (e) => {
            if (isDraggingSigBox || isResizingSigBox || pinchState.active) return; 
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
            if (e.target !== canvas && e.target !== pdfViewer) return; 
            isDraggingPdf = true;
            startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
            canvas.style.cursor = 'grabbing';
        });

        pdfViewer.addEventListener('touchstart', (e) => {
            if (signatureBoxEl && (e.target === signatureBoxEl || signatureBoxEl.contains(e.target))) {
                return;
            }
            const userBArea = document.getElementById('user-b-sig-area');
            if (userBArea && (e.target === userBArea || userBArea.contains(e.target))) {
                return; 
            }

            if (isDraggingSigBox || isResizingSigBox) return; 
            if (e.touches.length === 2) { 
                e.preventDefault(); 
                isDraggingPdf = false; 
                pinchState.active = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                pinchState.lastScale = scale; 
                const viewerRect = pdfViewer.getBoundingClientRect();
                pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
                pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                const canvasRect = canvas.getBoundingClientRect();
                const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
                const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;
                
                pinchState.pdfPointX = pdfPointScreenX / scale; 
                pinchState.pdfPointY = pdfPointScreenY / scale;

            } else if (e.touches.length === 1 && !pinchState.active) { 
                const cssCanvasWidth = parseFloat(canvas.style.width);
                const cssCanvasHeight = parseFloat(canvas.style.height);
                if ((cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight && scale === 1) || (e.target !== canvas && e.target !== pdfViewer)) {
                    isDraggingPdf = false; return;
                }
                isDraggingPdf = true;
                const touch = e.touches[0];
                startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
            }
        }, { passive: false }); 

        function handlePdfMove(clientX, clientY) {
            if (!isDraggingPdf) return;
            let newTranslateX = clientX - startPos.x;
            let newTranslateY = clientY - startPos.y;
            const viewerWidth = pdfViewer.clientWidth;
            const viewerHeight = pdfViewer.clientHeight;
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            const overpanMargin = 30; 
            
            if (cssCanvasWidth > viewerWidth) {
                const minX = viewerWidth - cssCanvasWidth - overpanMargin; 
                const maxX = overpanMargin; 
                newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
            } else {
                newTranslateX = (viewerWidth - cssCanvasWidth) / 2; 
            }

            if (cssCanvasHeight > viewerHeight) {
                const minY = viewerHeight - cssCanvasHeight - overpanMargin; 
                const maxY = overpanMargin; 
                newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
            } else {
                newTranslateY = (viewerHeight - cssCanvasHeight) / 2; 
            }
            translatePos.x = newTranslateX;
            translatePos.y = newTranslateY;
            updateCanvasTransform();
        }

        async function handlePinchMove(touch1, touch2) { 
            if (!pinchState.active || pinchState.initialDistance === 0 || !pdfDoc) return;
            const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
            newScale = Math.min(3.0, Math.max(0.5, parseFloat(newScale.toFixed(2)))); 
            
            if (Math.abs(newScale - scale) < 0.01 && newScale !== 0.5 && newScale !== 3.0) return; 
            
            const oldScale = scale;
            scale = newScale;
            
            const viewerRect = pdfViewer.getBoundingClientRect(); 
            let baseCanvasX = 0;
            let baseCanvasY = 0;
            
            try {
                const page = await pdfDoc.getPage(currentPage);
                const viewportCss = page.getViewport({scale: scale});
                if (viewportCss.width < viewerRect.width) {
                    baseCanvasX = (viewerRect.width - viewportCss.width) / 2;
                }
                if (viewportCss.height < viewerRect.height) {
                    baseCanvasY = (viewerRect.height - viewportCss.height) / 2;
                }
                
                translatePos.x = (pinchState.screenCenterX - viewerRect.left - baseCanvasX) - (pinchState.pdfPointX * scale);
                translatePos.y = (pinchState.screenCenterY - viewerRect.top - baseCanvasY) - (pinchState.pdfPointY * scale);
                
                document.getElementById('zoom-slider').value = scale.toFixed(1);
                await renderPage(currentPage); 
            } catch(err) {
                console.error("Error en handlePinchMove al obtener página:", err);
                scale = oldScale; 
            }
        }

        function nextPage() {
            if (!pdfDoc || currentPage >= totalPages) return;
            currentPage++;
            translatePos = { x: 0, y: 0 }; 
            renderPage(currentPage);
        }

        function prevPage() {
            if (!pdfDoc || currentPage <= 1) return;
            currentPage--;
            translatePos = { x: 0, y: 0 }; 
            renderPage(currentPage);
        }

        document.getElementById('zoom-slider').addEventListener('input', async function () {
            if (!pdfDoc) return;
            const oldScale = scale;
            scale = parseFloat(this.value);
            
            const viewerRect = pdfViewer.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect(); 
            
            const screenCenterX = viewerRect.left + viewerRect.width / 2;
            const screenCenterY = viewerRect.top + viewerRect.height / 2;
            
            const pdfPointX = (screenCenterX - canvasRect.left) / oldScale;
            const pdfPointY = (screenCenterY - canvasRect.top) / oldScale;
            
            const page = await pdfDoc.getPage(currentPage);
            const newViewportCss = page.getViewport({scale: scale}); 
            
            let expectedCanvasLeft = 0;
            if (newViewportCss.width < viewerRect.width) {
                expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
            }
            let expectedCanvasTop = 0;
            if (newViewportCss.height < viewerRect.height) {
                expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
            }
            
            translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
            translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
            
            document.getElementById('zoom-slider').value = scale.toFixed(1);
            await renderPage(currentPage); 
            pinchState.lastScale = scale; 
        });

        pdfViewer.addEventListener('wheel', async function (e) {
            if (!pdfDoc) return;
            e.preventDefault(); 
            const oldScale = scale;
            const delta = e.deltaY > 0 ? -0.1 : 0.1; 
            let newScale = parseFloat((scale + delta).toFixed(2));
            newScale = Math.min(3.0, Math.max(0.5, newScale)); 
            
            if (Math.abs(newScale - oldScale) < 0.01 && newScale !==0.5 && newScale !== 3.0) return; 
            
            const viewerRect = pdfViewer.getBoundingClientRect();
            const mouseXViewer = e.clientX - viewerRect.left; 
            const mouseYViewer = e.clientY - viewerRect.top; 
            
            const canvasRect = canvas.getBoundingClientRect(); 
            const mouseXOnCanvas = e.clientX - canvasRect.left; 
            const mouseYOnCanvas = e.clientY - canvasRect.top; 
            
            const pdfPointX = mouseXOnCanvas / oldScale;
            const pdfPointY = mouseYOnCanvas / oldScale;
            
            scale = newScale; 
            
            const page = await pdfDoc.getPage(currentPage);
            const newViewportCss = page.getViewport({ scale: scale }); 
            
            let expectedCanvasLeft = 0;
            if (newViewportCss.width < viewerRect.width) {
                expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
            }
            let expectedCanvasTop = 0;
            if (newViewportCss.height < viewerRect.height) {
                expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
            }
            
            translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
            translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
            
            document.getElementById('zoom-slider').value = scale.toFixed(1);
            await renderPage(currentPage); 
        }, { passive: false }); 

        async function getProcessedPdfBlob() {
            if (!pdfDoc) {
                showMessage("Carga un PDF primero.");
                return null;
            }
            const { jsPDF } = window.jspdf; 
            const newPdfDocGen = new jsPDF(); 
            while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }
            
            for (let i = 1; i <= totalPages; i++) {
                const page = await pdfDoc.getPage(i);
                const downloadScale = 2.0; 
                const viewport = page.getViewport({ scale: downloadScale });
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                // Incluir firmas del Usuario A y B
                const signaturesForPage = embeddedSignatures.filter(sig => sig.page === i);
                for (const sigInfo of signaturesForPage) {
                    const img = new Image();
                    try {
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = (errEvent) => {
                                console.error("Error cargando imagen de firma para PDF:", sigInfo.dataURL, errEvent);
                                const syntheticError = new Error("Fallo al cargar imagen de firma: " + sigInfo.dataURL.substring(0,50) + "...");
                                syntheticError.event = errEvent;
                                reject(syntheticError);
                            };
                            img.src = sigInfo.dataURL;
                        });
                        // Coordenadas de la firma en la página (ya están en unidades PDF con el escalado original)
                        const x = sigInfo.x * downloadScale;
                        const y = sigInfo.y * downloadScale;
                        const width = sigInfo.width * downloadScale;
                        const height = sigInfo.height * downloadScale;
                        tempCtx.drawImage(img, x, y, width, height);
                    } catch (imgLoadError) {
                        console.error("Saltando firma debido a error de carga:", imgLoadError);
                    }
                }
                
                const imgData = tempCanvas.toDataURL('image/jpeg', 0.9); 
                newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
                newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
            }
            return newPdfDocGen.output('blob');
        }

        async function downloadPDF() {
            showMessage("Preparando PDF para descarga...");
            const pdfBlob = await getProcessedPdfBlob();
            if (pdfBlob) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(pdfBlob);
                link.download = originalFileName.replace(/\.pdf$/i, '-firmado.pdf') || 'documento-firmado.pdf';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href); 
                showMessage("PDF guardado.");
            } else {
                if(pdfDoc) showMessage("No se pudo generar el PDF para descargar.");
            }
        }

        async function sharePDF() {
            console.log('[sharePDF] INICIO. Estado de signatureBoxEl:', signatureBoxEl, '- Tipo:', typeof signatureBoxEl, '- activeSignatureBoxInfo:', activeSignatureBoxInfo);
            if (signatureBoxEl && typeof signatureBoxEl.classList !== 'undefined') {
                console.log('[sharePDF] signatureBoxEl.classList:', signatureBoxEl.classList);
                console.log('[sharePDF] ¿Está signatureBoxEl en el DOM?:', document.body.contains(signatureBoxEl));
            } else if (signatureBoxEl) {
                console.warn('[sharePDF] signatureBoxEl existe pero no tiene classList. Es:', signatureBoxEl);
            }

            if (!pdfDoc) {
                showMessage("Carga un PDF primero para compartir.");
                return;
            }
            if (!supabaseClient) {
                showMessage("Fallo en Supabase: La función de compartir no está disponible.");
                return;
            }
            if (!originalPdfFileBlob) {
                showMessage("El archivo PDF original no está disponible. Por favor, recarga el PDF.");
                return;
            }

            let markerToShare = null;

            if (signatureBoxEl && signatureBoxEl.classList.contains('position-confirmed') && activeSignatureBoxInfo && activeSignatureBoxInfo.element === signatureBoxEl) {
                console.log("[sharePDF] Usando CUADRO CONFIRMADO (estático) y activeSignatureBoxInfo.");
                
                if (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages) {
                    console.error("[sharePDF] La página del cuadro de firma confirmado (" + activeSignatureBoxInfo.page + ") es inválida.");
                    showMessage("Error: La página registrada para el cuadro de firma confirmado es inválida. Intente editar y confirmar de nuevo el cuadro en una página válida.");
                    return;
                }
                markerToShare = {
                    page: activeSignatureBoxInfo.page,
                    x_coord: activeSignatureBoxInfo.x,
                    y_coord: activeSignatureBoxInfo.y,
                    width_val: activeSignatureBoxInfo.width,
                    height_val: activeSignatureBoxInfo.height,
                    status: 'pending_user_b_signature'
                };
                console.log("[sharePDF] CORRECTO - markerToShare definido desde cuadro CONFIRMADO (estático):", markerToShare);
                
            } else {
                console.warn("[sharePDF] No se cumplió la condición para compartir el cuadro confirmado (estático).");
                if (!signatureBoxEl) console.warn("  - signatureBoxEl es null.");
                else if (!signatureBoxEl.classList.contains('position-confirmed')) console.warn("  - signatureBoxEl existe pero NO está confirmado (es azul). Se requiere el cuadro estático (borde discontinuo).");
                else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) console.warn("  - signatureBoxEl está confirmado, pero activeSignatureBoxInfo es inválido o no coincide.");
            }


            if (!markerToShare) {
                let reason = "No se encontró un cuadro de firma confirmado (estático) para compartir."; 
                
                if (!signatureBoxEl) {
                    reason = "No hay ningún cuadro de firma en la página. Debe añadir uno (✍️) y luego confirmarlo (✔️).";
                } else if (!signatureBoxEl.classList.contains('position-confirmed')) {
                    reason = "El cuadro de firma actual es azul (editable). Primero debe confirmarlo (con ✔️) para que se vuelva de borde discontinuo y pueda ser compartido.";
                } else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) {
                    reason = "El cuadro de firma está confirmado, pero hay una inconsistencia con sus datos internos. Intente editarlo (✏️) y confirmarlo (✔️) de nuevo.";
                } else { 
                    if (activeSignatureBoxInfo && (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages)) {
                                reason = "La página registrada para el cuadro de firma confirmado es inválida.";
                    } else {
                                reason = "No se pudo preparar el cuadro de firma confirmado para compartir por una razón desconocida.";
                    }
                }
                
                console.error("SharePDF: FALLO AL PREPARAR MARCADOR. Razón: " + reason, 
                                "signatureBoxEl:", signatureBoxEl, 
                                "activeSignatureBoxInfo:", activeSignatureBoxInfo);
                
                showMessage("Para compartir con Usuario B:\n1. Usa '✍️ Añadir Firma' (aparece cuadro azul).\n2. Posiciona y dimensiona el cuadro azul.\n3. Haz clic en ✔️ sobre el cuadro azul para confirmarlo (se volverá de borde discontinuo).\n4. SOLO ENTONCES, presiona '📤 Compartir'.\n\n" +
                                    "AYUDA: El cuadro que se comparte es el de borde discontinuo (estático). Si solo ves el cuadro azul, primero confírmalo.\n\n" +
                                    "(Diagnóstico: " + reason.split('(')[0].trim() + ")");
                return;
            }
            
            showMessage("Preparando documento para compartir..."); // Este mensaje se mostrará brevemente
            const documentId = `doc_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
            sharedDocIdForUserA = documentId; // Se establece para la sesión actual del Usuario A
            const sanitizedFileName = originalFileName.replace(/[^a-zA-Z0-9._-]/g, '_');
            const originalPdfStoragePath = `documents/${documentId}/${sanitizedFileName}`;

            try {
                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs')
                    .upload(originalPdfStoragePath, originalPdfFileBlob, {
                        cacheControl: '3600',
                        upsert: false
                    });
                if (uploadError) {
                    console.error("Error subiendo PDF original a Storage:", uploadError);
                    throw new Error(`Error al subir PDF original: ${uploadError.message || JSON.stringify(uploadError)}`);
                }
                console.log("PDF original subido, path:", uploadData.path);

                const markerForDb = {
                    doc_id: documentId,
                    marker_id: `marker_userb_${Date.now()}`,
                    pdf_storage_path: uploadData.path, 
                    ...markerToShare
                };
                console.log("[sharePDF] Intentando insertar en signature_markers:", markerForDb);
                const { error: markersError } = await supabaseClient
                    .from('signature_markers')
                    .insert([markerForDb]);
                
                if (markersError) {
                    console.error("Raw Supabase insert error (signature_markers):", markersError);
                    throw new Error(`Error al guardar marcador: ${markersError.message || 'No message property, ver consola para objeto de error completo.'}`);
                }
                console.log("Información del marcador para Usuario B guardada.");

                // ----- INICIO DE LA MODIFICACIÓN PARA ABRIR NUEVA PESTAÑA -----
                // URL que el Usuario B usará para firmar (la misma que antes)
                const signingPageUrlForUserB = `${window.location.origin}${window.location.pathname}?doc_id=${documentId}&mode=sign_for_user_b`;

                // Nombre de tu página generadora de enlaces/QR (asegúrate que este archivo exista en tu proyecto)
                const generatorPageFileName = 'generador_enlace_firma.html'; 

                // Construir la URL para la página generadora
                // Esto asume que 'generador_enlace_firma.html' está en el mismo directorio que 'index.html'
                const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
                const generatorPageUrl = `${window.location.origin}${basePath}${generatorPageFileName}?signUrl=${encodeURIComponent(signingPageUrlForUserB)}&docId=${encodeURIComponent(documentId)}`;
                
                // Guardar el ID del documento compartido en localStorage para Usuario A (opcional, para restaurar estado si vuelve)
                if (typeof Storage !== "undefined") {
                    localStorage.setItem('lastSharedDocIdForUserA', documentId);
                }

                // Abrir la página generadora en una nueva pestaña/ventana
                const newShareWindow = window.open(generatorPageUrl, '_blank');

                if (newShareWindow) {
                    newShareWindow.focus(); // Intenta traer la nueva pestaña al frente
                    // Mensaje en la página original (index.html) informando al usuario
                    showMessage("Generando enlace para compartir en una nueva pestaña...\nEsta se cerrará automáticamente después de unos segundos.");
                } else {
                    // En caso de que el navegador bloquee el pop-up
                    showMessage("No se pudo abrir la nueva pestaña para compartir.\nPor favor, revisa si tu navegador está bloqueando ventanas emergentes e inténtalo de nuevo.");
                }
                
                const checkBtn = document.getElementById('check-signatures-btn');
                if (checkBtn) checkBtn.style.display = 'inline-block'; // Usuario A puede querer verificar firmas después

                // Después de compartir, configuramos el listener Realtime para este documento
                setupRealtimeListener();

                // ----- FIN DE LA MODIFICACIÓN PARA ABRIR NUEVA PESTAÑA -----

            } catch (error) { 
                console.error("Excepción detallada en sharePDF (operaciones Supabase):", error);
                let specificMessage = "Error desconocido durante la operación de compartir.";
                if (error && error.message) {
                    specificMessage = error.message; 
                }

                if (specificMessage.includes("No message property, ver consola para objeto de error completo")) {
                    specificMessage += " (El objeto de error original de Supabase no tuvo una propiedad 'message' directa. Revisa la consola del navegador donde dice 'Raw Supabase insert error').";
                }

                let userMessage = `Error al compartir: ${specificMessage}\n\n`;
                
                if (error && error.message && (error.message.includes("guardar marcador") || error.message.includes("signature_markers") || error.message.includes("No message property"))) {
                    userMessage += "POSIBLES CAUSAS DEL FALLO AL GUARDAR MARCADOR:\n" +
                                        "1. Políticas de Seguridad a Nivel de Fila (RLS) en la tabla 'signature_markers' que impiden la inserción. Debes permitir inserciones para el rol 'anon'.\n" +
                                        "2. La tabla 'signature_markers' o sus columnas no están definidas correctamente en Supabase (nombres, tipos de datos, restricciones NOT NULL como 'id', 'created_at', etc.).\n" +
                                        "    Columnas esperadas: doc_id (text), marker_id (text, primary key), pdf_storage_path (text), page (int), x_coord (numeric), y_coord (numeric), width_val (numeric), height_val (numeric), status (text).\n" +
                                        "3. Problema de conexión o con el servicio de Supabase.\n\n" +
                                        "ACCIÓN: Revisa la configuración de tu tabla 'signature_markers' en Supabase Studio (Editor de Tablas y Políticas RLS). Verifica también los Logs de la Base de Datos en Supabase. La consola del navegador tiene más detalles del error original (busca 'Raw Supabase insert error').";
                } else if (error && error.message && (error.message.includes("subir PDF original") || error.message.includes("Storage"))) {
                    userMessage += "POSIBLES CAUSAS DEL FALLO AL SUBIR PDF:\n" +
                                        "1. El bucket 'pdfs' no existe en Supabase Storage.\n" +
                                        "2. Políticas de acceso al bucket 'pdfs' que impiden la subida.\n\n" +
                                        "ACCIÓN: Revisa la configuración de tu bucket 'pdfs' en Supabase Storage.";
                }
                showMessage(userMessage);
            }
        }

        function addSignatureBox() {
            console.log('[addSignatureBox] Llamada. Estado actual de signatureBoxEl:', signatureBoxEl);
            if (!pdfDoc) {
                showMessage("Por favor, carga un documento PDF primero.");
                return;
            }
            // Asegúrate de que el cuadro de usuario B no esté activo si Usuario A intenta añadir su firma
            const userBArea = document.getElementById('user-b-sig-area');
            if (userBArea) {
                userBArea.remove(); // Eliminar el marcador de Usuario B si existe
                markerDataForUserB = null; // Limpiar los datos del marcador de Usuario B
            }

            if (signatureBoxEl) { 
                console.log('[addSignatureBox] Hay un signatureBoxEl existente, se removerá.');
                try {
                    signatureBoxEl.remove();
                } catch(e) {
                    console.warn('[addSignatureBox] Error al remover signatureBoxEl existente del DOM:', e);
                }
            }
            signatureBoxEl = null; 
            activeSignatureBoxInfo = null; 

            try {
                signatureBoxEl = document.createElement('div'); 
                signatureBoxEl.className = 'signature-box';
                signatureBoxEl.style.width = '150px'; 
                signatureBoxEl.style.height = '75px';
                
                const viewerRect = pdfViewer.getBoundingClientRect();
                if (!pdfViewer || (viewerRect.width === 0 && viewerRect.height === 0 && !pdfViewer.offsetParent)) { 
                    console.error("[addSignatureBox] pdfViewer no está disponible, no tiene dimensiones o no está visible.");
                    showMessage("Error: El visor de PDF no está listo para añadir una firma.");
                    signatureBoxEl = null; 
                    return;
                }
                signatureBoxEl.style.left = `${Math.max(0, (viewerRect.width - 150) / 2)}px`; 
                signatureBoxEl.style.top = `${Math.max(0, (viewerRect.height - 75) / 2)}px`;
                
                pdfViewer.appendChild(signatureBoxEl); 
                console.log('[addSignatureBox] Nuevo signatureBoxEl creado y añadido al DOM. Referencia actual:', signatureBoxEl);

                makeSignatureBoxEditable(signatureBoxEl); 
                console.log('[addSignatureBox] makeSignatureBoxEditable llamado. signatureBoxEl debería ser el nuevo cuadro.');
            } catch (error) {
                console.error('[addSignatureBox] ERROR CRÍTICO durante la creación/configuración del cuadro:', error);
                showMessage('Se produjo un error crítico al intentar añadir el cuadro de firma. Revise la consola.');
                if (signatureBoxEl && signatureBoxEl.parentElement) {
                    signatureBoxEl.remove(); 
                }
                signatureBoxEl = null; 
            }
        }
        
        function repositionActiveSignatureBox() {
            if (!activeSignatureBoxInfo || !activeSignatureBoxInfo.element || !pdfViewer || !canvas || !pdfDoc) {
                return;
            }
            const sig = activeSignatureBoxInfo;
            const boxEl = sig.element; 
            if (sig.page === currentPage) {
                const canvasRect = canvas.getBoundingClientRect(); 
                const viewerRect = pdfViewer.getBoundingClientRect();
                const displayX = (sig.x * scale) + (canvasRect.left - viewerRect.left);
                const displayY = (sig.y * scale) + (canvasRect.top - viewerRect.top);
                const displayWidth = sig.width * scale;
                const displayHeight = sig.height * scale;
                
                boxEl.style.left = `${displayX}px`;
                boxEl.style.top = `${displayY}px`;
                boxEl.style.width = `${displayWidth}px`;
                boxEl.style.height = `${displayHeight}px`;
                boxEl.style.display = 'block';
            } else {
                boxEl.style.display = 'none';
            }
        }

        function confirmSignatureBoxPlacement(boxEl) { 
            console.log('[confirmSignatureBoxPlacement] Confirmando. El cuadro azul es:', boxEl);
            if (!boxEl || !pdfDoc) return; 
            const handles = boxEl.querySelectorAll('.resize-handle');
            handles.forEach(h => h.remove());
            boxEl.classList.add('position-confirmed'); 
            
            const canvasRect = canvas.getBoundingClientRect();
            const boxRect = boxEl.getBoundingClientRect(); 
            
            const boxRelToCanvasX = (boxRect.left - canvasRect.left) / scale; 
            const boxRelToCanvasY = (boxRect.top - canvasRect.top) / scale;
            const pdfWidth = boxRect.width / scale;
            const pdfHeight = boxRect.height / scale;
            
            activeSignatureBoxInfo = { 
                element: boxEl, 
                page: currentPage,
                x: boxRelToCanvasX, 
                y: boxRelToCanvasY, 
                width: pdfWidth, 
                height: pdfHeight 
            };
            console.log('[confirmSignatureBoxPlacement] activeSignatureBoxInfo establecido:', activeSignatureBoxInfo);
            console.log('[confirmSignatureBoxPlacement] signatureBoxEl (ahora es el cuadro confirmado/estático) es:', signatureBoxEl);

            repositionActiveSignatureBox(); 
            
            let controls = boxEl.querySelector('.signature-box-controls');
            if (!controls) { 
                controls = document.createElement('div');
                controls.className = 'signature-box-controls';
                boxEl.appendChild(controls);
            }
            controls.innerHTML = ''; 
            
            const drawBtn = document.createElement('button');
            drawBtn.className = 'signature-box-btn draw';
            drawBtn.innerHTML = '✍️'; 
            drawBtn.title = 'Dibujar Firma';
            drawBtn.onclick = (e) => { e.stopPropagation(); openSignatureModal(); };
            
            const editPosBtn = document.createElement('button');
            editPosBtn.className = 'signature-box-btn edit';
            editPosBtn.innerHTML = '✏️'; 
            editPosBtn.title = 'Editar Posición';
            editPosBtn.onclick = (e) => { e.stopPropagation(); makeSignatureBoxEditable(boxEl); }; 
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-box-btn cancel';
            cancelBtn.innerHTML = '❌'; 
            cancelBtn.title = 'Cancelar/Eliminar esta área de firma';
            cancelBtn.onclick = (e) => { 
                e.stopPropagation(); 
                console.log('[confirmSignatureBoxPlacement > cancelBtn] Removiendo cuadro confirmado y anulando signatureBoxEl.');
                boxEl.remove(); 
                signatureBoxEl = null; 
                activeSignatureBoxInfo = null; 
            };
            controls.appendChild(drawBtn);
            controls.appendChild(editPosBtn);
            controls.appendChild(cancelBtn);
        }

        function makeSignatureBoxEditable(boxEl) { 
            console.log('[makeSignatureBoxEditable] Haciendo editable. El cuadro es:', boxEl);
            if (!boxEl) {
                console.warn('[makeSignatureBoxEditable] boxEl es null, no se puede hacer editable.');
                return;
            }
            activeSignatureBoxInfo = null; 
            boxEl.classList.remove('position-confirmed'); 
            boxEl.style.cursor = 'move'; 
            boxEl.querySelectorAll('.resize-handle').forEach(h => h.remove()); 
            addResizeHandlesToSigBox(boxEl); 
            
            console.log('[makeSignatureBoxEditable] signatureBoxEl (ahora azul) es:', signatureBoxEl);

            let controls = boxEl.querySelector('.signature-box-controls');
            if (!controls) {
                controls = document.createElement('div');
                controls.className = 'signature-box-controls';
                boxEl.appendChild(controls);
            }
            controls.innerHTML = ''; 
            
            const confirmPlacementBtn = document.createElement('button');
            confirmPlacementBtn.className = 'signature-box-btn confirm';
            confirmPlacementBtn.innerHTML = '✔️'; 
            confirmPlacementBtn.title = 'Confirmar Posición';
            confirmPlacementBtn.onclick = (e) => { e.stopPropagation(); confirmSignatureBoxPlacement(boxEl); };
            
            const cancelBtn = document.createElement('button'); 
            cancelBtn.className = 'signature-box-btn cancel';
            cancelBtn.innerHTML = '🗑️'; 
            cancelBtn.title = 'Eliminar este cuadro azul';
            cancelBtn.onclick = (e) => { 
                e.stopPropagation(); 
                console.log('[makeSignatureBoxEditable > cancelBtn] Removiendo cuadro azul y anulando signatureBoxEl.');
                boxEl.remove(); 
                signatureBoxEl = null; 
                activeSignatureBoxInfo = null; 
            };
            controls.appendChild(confirmPlacementBtn);
            controls.appendChild(cancelBtn);
            setupSigBoxDragEvents(boxEl); 
            console.log('[makeSignatureBoxEditable] Terminado. signatureBoxEl (debería ser azul y editable):', signatureBoxEl);
        }
        
        const _onSigBoxDragMove = (e) => { 
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleSigBoxDragMove(clientX, clientY);
        };
        const _onSigBoxDragEnd = () => { 
            isDraggingSigBox = false;
            window.removeEventListener('mousemove', _onSigBoxDragMove);
            window.removeEventListener('touchmove', _onSigBoxDragMove);
            window.removeEventListener('mouseup', _onSigBoxDragEnd);
            window.removeEventListener('touchend', _onSigBoxDragEnd);
        };
        const _onSigBoxResizeMove = (e) => { 
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleSigBoxResizeMove(clientX, clientY);
        };
        const _onSigBoxResizeEnd = () => { 
            isResizingSigBox = false;
            resizeHandleTypeSigBox = null;
            window.removeEventListener('mousemove', _onSigBoxResizeMove);
            window.removeEventListener('touchmove', _onSigBoxResizeMove);
            window.removeEventListener('mouseup', _onSigBoxResizeEnd);
            window.removeEventListener('touchend', _onSigBoxResizeEnd);
        };

        function addResizeHandlesToSigBox(box) {
            const handles = ['nw', 'ne', 'sw', 'se']; 
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                box.appendChild(handle);
                handle.addEventListener('mousedown', (e) => {
                    e.stopImmediatePropagation(); 
                    initSigBoxResize(e.clientX, e.clientY, pos, box);
                });
                handle.addEventListener('touchstart', (e) => {
                    e.stopImmediatePropagation();
                    if (e.touches.length === 1) {
                        e.preventDefault(); 
                        initSigBoxResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
                    }
                }, { passive: false });
            });
        }

        function initSigBoxResize(clientX, clientY, handlePos, box) {
            if (box.classList.contains('position-confirmed')) return; 
            isResizingSigBox = true;
            resizeHandleTypeSigBox = handlePos;
            startBoxPosSigBox = { x: box.offsetLeft, y: box.offsetTop };
            startBoxSizeSigBox = { width: box.offsetWidth, height: box.offsetHeight };
            startPointerPosSigBox = { x: clientX, y: clientY };
            isDraggingPdf = false;
            isDraggingSigBox = false;
            pinchState.active = false;
            window.addEventListener('mousemove', _onSigBoxResizeMove);
            window.addEventListener('touchmove', _onSigBoxResizeMove, { passive: false });
            window.addEventListener('mouseup', _onSigBoxResizeEnd);
            window.addEventListener('touchend', _onSigBoxResizeEnd);
        }

        function handleSigBoxResizeMove(clientX, clientY) {
            if (!isResizingSigBox || !resizeHandleTypeSigBox || !signatureBoxEl) return;
            const deltaX = clientX - startPointerPosSigBox.x;
            const deltaY = clientY - startPointerPosSigBox.y;
            let newWidth = startBoxSizeSigBox.width;
            let newHeight = startBoxSizeSigBox.height;
            let newLeft = startBoxPosSigBox.x;
            let newTop = startBoxPosSigBox.y;
            const minWidth = 50; 
            const minHeight = 30; 
            const viewerRect = pdfViewer.getBoundingClientRect();
            if (resizeHandleTypeSigBox.includes('w')) { 
                newWidth = Math.max(minWidth, startBoxSizeSigBox.width - deltaX);
                newLeft = startBoxPosSigBox.x + (startBoxSizeSigBox.width - newWidth);
            }
            if (resizeHandleTypeSigBox.includes('e')) { 
                newWidth = Math.max(minWidth, startBoxSizeSigBox.width + deltaX);
            }
            if (resizeHandleTypeSigBox.includes('n')) { 
                newHeight = Math.max(minHeight, startBoxSizeSigBox.height - deltaY);
                newTop = startBoxPosSigBox.y + (startBoxSizeSigBox.height - newHeight);
            }
            if (resizeHandleTypeSigBox.includes('s')) { 
                newHeight = Math.max(minHeight, startBoxSizeSigBox.height + deltaY);
            }
            if (newLeft < 0) { newWidth += newLeft; newLeft = 0; } 
            if (newTop < 0) { newHeight += newTop; newTop = 0; } 
            if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
            if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }
            newWidth = Math.max(minWidth, newWidth);
            newHeight = Math.max(minHeight, newHeight);
            signatureBoxEl.style.width = `${newWidth}px`;
            signatureBoxEl.style.height = `${newHeight}px`;
            signatureBoxEl.style.left = `${newLeft}px`;
            signatureBoxEl.style.top = `${newTop}px`;
        }

        function setupSigBoxDragEvents(box) {
            function initSigBoxDrag(clientX, clientY) {
                if (box.classList.contains('position-confirmed')) return; 
                isDraggingSigBox = true;
                const viewerRect = pdfViewer.getBoundingClientRect();
                signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
                signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;
                isDraggingPdf = false; 
                isResizingSigBox = false; 
                pinchState.active = false; 
                window.addEventListener('mousemove', _onSigBoxDragMove);
                window.addEventListener('touchmove', _onSigBoxDragMove, { passive: false });
                window.addEventListener('mouseup', _onSigBoxDragEnd);
                window.addEventListener('touchend', _onSigBoxDragEnd);
            }
            box.addEventListener('mousedown', (e) => {
                if (e.target === box && !box.classList.contains('position-confirmed')) {
                    e.stopImmediatePropagation(); 
                    initSigBoxDrag(e.clientX, e.clientY);
                }
            });
            box.addEventListener('touchstart', (e) => {
                if (e.target === box && e.touches.length === 1 && !box.classList.contains('position-confirmed')) {
                    e.stopImmediatePropagation();
                    e.preventDefault(); 
                    initSigBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });
        }

        function handleSigBoxDragMove(clientX, clientY) {
            if (!isDraggingSigBox || !signatureBoxEl) return;
            const viewerRect = pdfViewer.getBoundingClientRect();
            let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
            let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;
            newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBoxEl.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBoxEl.offsetHeight));
            signatureBoxEl.style.left = `${newLeft}px`;
            signatureBoxEl.style.top = `${newTop}px`;
        }

        function openSignatureModal() { 
            if (!activeSignatureBoxInfo) {
                if (signatureBoxEl && !signatureBoxEl.classList.contains('position-confirmed')) {
                    showMessage("Primero debe confirmar la posición del cuadro de firma (botón ✔️ del cuadro azul) antes de poder dibujar en él.");
                } else {
                    showMessage("Error: No hay un área de firma confirmada y activa para dibujar. Añada una firma y confírmela (✔️).");
                }
                return;
            }
            signatureModalEl = document.createElement('div');
            signatureModalEl.className = 'signature-modal';
            const container = document.createElement('div');
            container.className = 'signature-container';
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'signature-canvas-container';
            signaturePadCanvasEl = document.createElement('canvas');
            signaturePadCanvasEl.id = 'signature-canvas';
            canvasContainer.appendChild(signaturePadCanvasEl);
            container.appendChild(canvasContainer);
            signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
            
            const controls = document.createElement('div');
            controls.className = 'signature-controls';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-control-btn cancel';
            cancelBtn.textContent = '❌ Cancelar';
            cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'signature-control-btn clear';
            clearBtn.textContent = '↩️ Limpiar';
            clearBtn.onclick = () => {
                const dpr = window.devicePixelRatio || 1;
                signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / dpr , signaturePadCanvasEl.height / dpr );
            };
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'signature-control-btn confirm';
            confirmBtn.textContent = '✔️ Firmar';
            confirmBtn.onclick = embedSignature; 
            
            controls.appendChild(cancelBtn);
            controls.appendChild(clearBtn);
            controls.appendChild(confirmBtn);
            container.appendChild(controls);
            signatureModalEl.appendChild(container);
            document.body.appendChild(signatureModalEl);
            
            requestAnimationFrame(() => {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                signaturePadCanvasEl.width = rect.width * dpr;
                signaturePadCanvasEl.height = rect.height * dpr;
                signaturePadCanvasEl.style.width = `${rect.width}px`;
                signaturePadCanvasEl.style.height = `${rect.height}px`;
                signaturePadCtxEl.scale(dpr, dpr); 
                signaturePadCtxEl.lineWidth = 1.5; 
                signaturePadCtxEl.lineCap = 'round'; 
                signaturePadCtxEl.lineJoin = 'round'; 
                signaturePadCtxEl.strokeStyle = '#000000'; 
            });
            setupSignaturePadDrawingEventsEl(); 
        }

        function setupSignaturePadDrawingEventsEl() {
            function getPadPosition(e) { 
                const rect = signaturePadCanvasEl.getBoundingClientRect();
                let clientX, clientY;
                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left), 
                    y: (clientY - rect.top)
                };
            }
            function startPadDraw(e) {
                e.preventDefault();
                isDrawingOnPadEl = true;
                lastDrawPadPosEl = getPadPosition(e);
                signaturePadCtxEl.beginPath(); 
                signaturePadCtxEl.moveTo(lastDrawPadPosEl.x, lastDrawPadPosEl.y);
            }
            function drawOnPad(e) {
                if (!isDrawingOnPadEl) return;
                e.preventDefault();
                const currentPos = getPadPosition(e);
                signaturePadCtxEl.lineTo(currentPos.x, currentPos.y);
                signaturePadCtxEl.stroke(); 
                lastDrawPadPosEl = currentPos;
            }
            function stopPadDraw() {
                if(isDrawingOnPadEl) {
                    isDrawingOnPadEl = false;
                }
            }
            signaturePadCanvasEl.addEventListener('mousedown', startPadDraw);
            signaturePadCanvasEl.addEventListener('mousemove', drawOnPad);
            signaturePadCanvasEl.addEventListener('mouseup', stopPadDraw);
            signaturePadCanvasEl.addEventListener('mouseout', stopPadDraw); 
            signaturePadCanvasEl.addEventListener('touchstart', startPadDraw, { passive: false });
            signaturePadCanvasEl.addEventListener('touchmove', drawOnPad, { passive: false });
            signaturePadCanvasEl.addEventListener('touchend', stopPadDraw);
        }

        function embedSignature(isUserBSignature = false, markerInfo = null) { 
            const tempCanvasTest = document.createElement('canvas');
            tempCanvasTest.width = signaturePadCanvasEl.width; 
            tempCanvasTest.height = signaturePadCanvasEl.height;
            const blankDataURL = tempCanvasTest.toDataURL();
            
            // Si es firma de Usuario B, usamos el markerInfo, de lo contrario, activeSignatureBoxInfo
            const targetInfo = isUserBSignature ? markerInfo : activeSignatureBoxInfo;

            if (!targetInfo) { 
                showMessage("Error: No hay información del cuadro de firma activo para incrustar la firma.");
                if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
                return;
            }
            if (!signaturePadCanvasEl || signaturePadCanvasEl.toDataURL() === blankDataURL) {
                showMessage("Por favor, dibuja una firma primero.");
                return;
            }

            const dataURL = signaturePadCanvasEl.toDataURL('image/png'); 
            const signatureImgElement = document.createElement('img');
            signatureImgElement.className = 'embedded-signature'; 
            signatureImgElement.src = dataURL;
            
            const signatureInfo = {
                element: signatureImgElement, 
                page: targetInfo.page, 
                x: targetInfo.x_coord || targetInfo.x, // Usar x_coord/y_coord si es de marker, x/y si es de activeSignatureBoxInfo
                y: targetInfo.y_coord || targetInfo.y, 
                width: targetInfo.width_val || targetInfo.width, 
                height: targetInfo.height_val || targetInfo.height, 
                dataURL: dataURL, 
                // Añadir una referencia al ID del marcador si es una firma de Usuario B
                marker_id_ref: isUserBSignature ? targetInfo.marker_id : undefined
            };
            // Eliminar cualquier firma existente para este marcador antes de añadir la nueva
            embeddedSignatures = embeddedSignatures.filter(sig => sig.marker_id_ref !== signatureInfo.marker_id_ref);
            // Y si ya existe el elemento, removerlo del DOM
            const existingEl = document.querySelector(`.embedded-signature[data-marker-id-ref="${signatureInfo.marker_id_ref}"]`);
            if (existingEl) existingEl.remove();

            signatureImgElement.setAttribute('data-marker-id-ref', signatureInfo.marker_id_ref); // Para poder identificarlo
            embeddedSignatures.push(signatureInfo); 
            pdfViewer.appendChild(signatureImgElement); 
            
            if (!isUserBSignature && activeSignatureBoxInfo.element) { // Solo si es firma de Usuario A, remover el cuadro azul
                console.log('[embedSignature] Removiendo el cuadro de firma confirmado (era signatureBoxEl) y anulando signatureBoxEl.');
                activeSignatureBoxInfo.element.remove(); 
                signatureBoxEl = null; 
                activeSignatureBoxInfo = null; 
            } else if (isUserBSignature) {
                // Si es firma de Usuario B, remover el área del marcador de Usuario B
                const userBArea = document.getElementById('user-b-sig-area');
                if (userBArea) userBArea.remove();
                markerDataForUserB = null; // Marcar como firmado para que no se re-muestre el área de clic
            }
            
            if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
            repositionSignatures(); 
        }

        function repositionSignatures() {
            if (!pdfViewer || !canvas || !pdfDoc) return; 
            const viewerRect = pdfViewer.getBoundingClientRect();
            const pdfCanvasRect = canvas.getBoundingClientRect(); 
            if (pdfCanvasRect.width === 0 || pdfCanvasRect.height === 0) return; 

            const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
            const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;
            
            embeddedSignatures.forEach(sig => {
                if (sig.element) {
                    if (sig.page === currentPage) { 
                        const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                        const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                        const displayWidth = sig.width * scale;
                        const displayHeight = sig.height * scale;
                        
                        sig.element.style.left = `${displayX}px`;
                        sig.element.style.top = `${displayY}px`;
                        sig.element.style.width = `${displayWidth}px`;
                        sig.element.style.height = `${displayHeight}px`;
                        sig.element.style.display = 'block'; 
                    } else {
                        sig.element.style.display = 'none'; 
                    }
                }
            });
        }
        
        function adjustViewerHeightAndRender() {
            const headerElement = document.querySelector('header');
            if (headerElement && pdfViewer) {
                const headerHeight = headerElement.offsetHeight;
                pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
            }
            if (pdfDoc) { 
                renderPage(currentPage); 
            } else {
                if (activeSignatureBoxInfo && activeSignatureBoxInfo.element) {
                    activeSignatureBoxInfo.element.style.display = 'none';
                }
                const userBArea = document.getElementById('user-b-sig-area');
                if(userBArea) userBArea.remove();
            }
        }

        function displayMarkerForUserB(marker) {
            if (!pdfDoc || !marker || marker.page !== currentPage || rendering) return;

            // No mostrar el marcador de Usuario B si ya tenemos una firma incrustada para él
            const isMarkerAlreadySignedLocally = embeddedSignatures.some(sig => sig.marker_id_ref === marker.marker_id);
            if (isMarkerAlreadySignedLocally) {
                const existingUserBArea = document.getElementById('user-b-sig-area');
                if (existingUserBArea) existingUserBArea.remove();
                return;
            }

            let userBSignatureAreaEl = document.getElementById('user-b-sig-area');
            if (!userBSignatureAreaEl) {
                userBSignatureAreaEl = document.createElement('div');
                userBSignatureAreaEl.id = 'user-b-sig-area';
                userBSignatureAreaEl.className = 'user-b-signature-area';
                userBSignatureAreaEl.innerHTML = '<span>Haz clic aquí para firmar</span>';
                pdfViewer.appendChild(userBSignatureAreaEl);
            }
            userBSignatureAreaEl.style.display = 'flex'; 

            const canvasRect = canvas.getBoundingClientRect();
            const viewerRect = pdfViewer.getBoundingClientRect();
            if (canvasRect.width === 0 || canvasRect.height === 0) {
                console.warn("Canvas no listo para posicionar área de User B, reintentando...");
                requestAnimationFrame(() => displayMarkerForUserB(marker)); 
                return;
            }

            const displayX = (marker.x_coord * scale) + (canvasRect.left - viewerRect.left);
            const displayY = (marker.y_coord * scale) + (canvasRect.top - viewerRect.top);
            const displayWidth = marker.width_val * scale;
            const displayHeight = marker.height_val * scale;

            userBSignatureAreaEl.style.left = `${displayX}px`;
            userBSignatureAreaEl.style.top = `${displayY}px`;
            userBSignatureAreaEl.style.width = `${displayWidth}px`;
            userBSignatureAreaEl.style.height = `${displayHeight}px`;

            // Establecer el evento de clic para abrir el modal de firma
            userBSignatureAreaEl.onclick = () => {
                openSignatureModalForUserB(marker);
            };
        }

        function openSignatureModalForUserB(markerToSign) {
            signatureModalEl = document.createElement('div');
            signatureModalEl.className = 'signature-modal';
            const container = document.createElement('div');
            container.className = 'signature-container';
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'signature-canvas-container';
            signaturePadCanvasEl = document.createElement('canvas');
            signaturePadCanvasEl.id = 'signature-canvas';
            canvasContainer.appendChild(signaturePadCanvasEl);
            container.appendChild(canvasContainer);
            signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
            
            const controls = document.createElement('div');
            controls.className = 'signature-controls';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-control-btn cancel';
            cancelBtn.textContent = '❌ Cancelar';
            cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'signature-control-btn clear';
            clearBtn.textContent = '↩️ Limpiar';
            clearBtn.onclick = () => {
                const dpr = window.devicePixelRatio || 1;
                signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / dpr, signaturePadCanvasEl.height / dpr);
            };
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'signature-control-btn confirm';
            confirmBtn.textContent = '✔️ Confirmar y Enviar Firma';
            confirmBtn.onclick = async () => { 
                const signatureDataURL = signaturePadCanvasEl.toDataURL('image/png');
                const tempCanvasTest = document.createElement('canvas');
                tempCanvasTest.width = signaturePadCanvasEl.width;
                tempCanvasTest.height = signaturePadCanvasEl.height;
                if (signatureDataURL === tempCanvasTest.toDataURL()) {
                    showMessage("Por favor, dibuja una firma primero.");
                    return;
                }
                
                // Antes de cerrar el modal, incrustar la firma localmente
                embedSignature(true, markerToSign); // True para indicar que es de Usuario B
                
                if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
                await saveUserBSignatureToSupabase(markerToSign, signatureDataURL);
            };
            
            controls.appendChild(cancelBtn);
            controls.appendChild(clearBtn);
            controls.appendChild(confirmBtn);
            container.appendChild(controls);
            signatureModalEl.appendChild(container);
            document.body.appendChild(signatureModalEl);
            
            requestAnimationFrame(() => {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                signaturePadCanvasEl.width = rect.width * dpr;
                signaturePadCanvasEl.height = rect.height * dpr;
                signaturePadCanvasEl.style.width = `${rect.width}px`;
                signaturePadCanvasEl.style.height = `${rect.height}px`;
                signaturePadCtxEl.scale(dpr, dpr);
                signaturePadCtxEl.lineWidth = 1.5;
                signaturePadCtxEl.lineCap = 'round';
                signaturePadCtxEl.lineJoin = 'round';
                signaturePadCtxEl.strokeStyle = '#000000';
            });
            setupSignaturePadDrawingEventsEl();
        }

        async function saveUserBSignatureToSupabase(marker, signatureDataURL) {
            if (!supabaseClient) {
                showMessage("Error: Cliente Supabase no disponible.");
                return;
            }
            showMessage("Guardando y enviando firma...");

            try {
                const response = await fetch(signatureDataURL);
                const blob = await response.blob();
                const signatureFileName = `signed_sig_${marker.marker_id}.png`;
                const signatureStoragePath = `signed_signatures/${marker.doc_id}/${signatureFileName}`;

                console.log("[saveUserBSignatureToSupabase] Intentando subir firma a Storage con ruta:", signatureStoragePath);

                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs') 
                    .upload(signatureStoragePath, blob, {
                        contentType: 'image/png',
                        cacheControl: '3600',
                        upsert: true
                    });
                if (uploadError) throw new Error(`Error al subir firma a Storage: ${uploadError.message}`);

                const { error: updateError } = await supabaseClient
                    .from('signature_markers')
                    .update({
                        status: 'signed_by_user_b',
                        signed_signature_storage_path: signatureStoragePath, 
                        signed_at: new Date().toISOString()
                    })
                    .eq('marker_id', marker.marker_id)
                    .eq('doc_id', marker.doc_id);
                if (updateError) throw new Error(`Error al actualizar marcador: ${updateError.message}`);

                showMessage("¡Firma enviada exitosamente!\nPuedes cerrar esta ventana.");
                
                // NOTA: La lógica de eliminar el área de marcador y agregar la imagen al DOM del visor
                // se ha movido a `embedSignature(true, markerToSign)` para asegurar que se haga
                // inmediatamente al confirmar la firma, antes de la subida a Supabase.
                // Esto mejora la respuesta de la UI.
                
                // Habilitar botones de Guardar y Compartir para Usuario B, y que ambos suban a Supabase
                const savePdfBtn = document.getElementById('save-pdf-btn');
                const sharePdfBtn = document.getElementById('share-pdf-btn');
                
                // Para Usuario B, "Guardar" y "Compartir" ahora hacen lo mismo: subir el PDF final.
                if (savePdfBtn) {
                    savePdfBtn.style.display = 'inline-block';
                    savePdfBtn.textContent = '💾 Guardar PDF Final'; // Cambiar texto para claridad
                    savePdfBtn.onclick = () => shareSignedPdfByB(marker.doc_id, originalFileName); // Llama a la función de subida a Supabase
                }
                if (sharePdfBtn) {
                    sharePdfBtn.textContent = '📤 Compartir PDF Final'; // Cambiar texto del botón
                    sharePdfBtn.onclick = () => shareSignedPdfByB(marker.doc_id, originalFileName); // Misma función de subida
                    sharePdfBtn.style.display = 'inline-block';
                }

                // Limpiar la URL de la página si se está en el modo de firma de Usuario B
                if (window.history.replaceState) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                }

            } catch (error) {
                console.error("Error guardando firma de Usuario B:", error);
                showMessage(`Error al guardar la firma: ${error.message}`);
            }
        }

        // Esta función ahora también es usada por el botón "Guardar" del Usuario B
        async function shareSignedPdfByB(docId, fileName) {
            if (!pdfDoc || !supabaseClient) {
                showMessage("Error: Documento o cliente Supabase no disponibles para compartir/guardar.");
                return;
            }
            showMessage("Preparando PDF firmado para subir...");

            try {
                const pdfBlob = await getProcessedPdfBlob(); // Obtiene el PDF con todas las firmas incrustadas
                if (!pdfBlob) {
                    showMessage("No se pudo generar el PDF firmado para subir.");
                    return;
                }

                const signedFileName = fileName.replace(/\.pdf$/i, '-firmado-final.pdf');
                const storagePath = `signed_documents/${docId}/${signedFileName}`; // Nueva carpeta para PDFs finales

                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs')
                    .upload(storagePath, pdfBlob, {
                        contentType: 'application/pdf',
                        cacheControl: '3600',
                        upsert: true
                    });

                if (uploadError) {
                    console.error("Error al subir el PDF firmado por B a Storage:", uploadError);
                    throw new Error(`Error al subir el PDF firmado: ${uploadError.message}`);
                }

                // Generar URL para compartir/descargar el PDF final desde Supabase
                const { data: publicUrlData } = supabaseClient.storage
                    .from('pdfs')
                    .getPublicUrl(storagePath);

                const finalShareUrl = publicUrlData.publicUrl;
                
                showMessage("¡PDF firmado subido a la nube!\n\nEnlace de descarga directa:\n\n" + finalShareUrl, true, finalShareUrl);

            } catch (error) {
                console.error("Error subiendo PDF firmado por Usuario B:", error);
                showMessage(`Error al subir el PDF firmado: ${error.message}`);
            }
        }

        async function checkSignaturesStatus() {
            if (!sharedDocIdForUserA) {
                // Intenta recuperar desde localStorage si el usuario volvió a la página
                if (typeof Storage !== "undefined") {
                    const lastShared = localStorage.getItem('lastSharedDocIdForUserA');
                    if (lastShared) {
                        sharedDocIdForUserA = lastShared;
                    } else {
                        showMessage("Primero debes compartir un documento usando 'Compartir'.");
                        return;
                    }
                } else {
                    showMessage("Primero debes compartir un documento usando 'Compartir'.");
                    return;
                }
            }
            if (!supabaseClient || !pdfDoc) { // pdfDoc puede no estar cargado si el usuario solo volvió a la página
                showMessage("Cliente Supabase no disponible o el PDF original no está cargado en esta sesión.");
                // Aquí podrías ofrecer recargar el PDF si tienes su path/blob almacenado,
                // pero por ahora, se asume que el PDF debe estar cargado para superponer firmas.
                return;
            }
            showMessage("Verificando estado de las firmas...");

            try {
                const { data: markers, error } = await supabaseClient
                    .from('signature_markers')
                    .select('*')
                    .eq('doc_id', sharedDocIdForUserA);

                if (error) throw new Error(`Error obteniendo marcadores: ${error.message}`);
                if (!markers || markers.length === 0) {
                    showMessage("No se encontraron marcadores para este documento o aún no hay firmas.");
                    return;
                }

                let newSignaturesLoaded = false;
                for (const marker of markers) {
                    if (marker.status === 'signed_by_user_b' && marker.signed_signature_storage_path) {
                        const existingSignature = embeddedSignatures.find(sig => sig.marker_id_ref === marker.marker_id);
                        if (existingSignature) {
                            if(existingSignature.element && !pdfViewer.contains(existingSignature.element)){
                                // Si ya está en el array local pero no en el DOM (por un cambio de página, por ejemplo)
                                pdfViewer.appendChild(existingSignature.element); 
                            }
                            console.log(`Firma para ${marker.marker_id} ya está en embeddedSignatures o siendo procesada.`);
                            continue; // Saltar si ya está cargada
                        }
                        
                        console.log(`Descargando firma para marcador ${marker.marker_id} desde ${marker.signed_signature_storage_path}`);
                        const { data: signatureDownloadData, error: signatureDownloadError } = await supabaseClient.storage
                            .from('pdfs') 
                            .download(marker.signed_signature_storage_path);

                        if (signatureDownloadError) {
                            console.error(`Error descargando firma ${marker.signed_signature_storage_path}:`, signatureDownloadError);
                            showMessage(`Error al descargar una firma: ${signatureDownloadError.message}`);
                            continue;
                        }

                        const signatureDataURL = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(signatureDownloadData);
                        });

                        const signatureImgElement = document.createElement('img');
                        signatureImgElement.className = 'embedded-signature';
                        signatureImgElement.src = signatureDataURL;
                        signatureImgElement.setAttribute('data-marker-id-ref', marker.marker_id); // Asignar el ID del marcador al elemento de imagen

                        pdfViewer.appendChild(signatureImgElement); 

                        const signatureInfo = {
                            element: signatureImgElement,
                            page: marker.page,
                            x: marker.x_coord,
                            y: marker.y_coord,
                            width: marker.width_val,
                            height: marker.height_val,
                            dataURL: signatureDataURL,
                            marker_id_ref: marker.marker_id // Guardar la referencia al marcador
                        };
                        embeddedSignatures.push(signatureInfo);
                        newSignaturesLoaded = true;
                    }
                }

                if (newSignaturesLoaded) {
                    showMessage("Firmas actualizadas y cargadas en el documento.");
                } else {
                    const hasPending = markers.some(m => m.status === 'pending_user_b_signature');
                    if (hasPending) {
                        showMessage("El documento aún tiene firmas pendientes por parte del Usuario B.");
                    } else {
                        const allSignedAndPresent = markers
                            .filter(m => m.status === 'signed_by_user_b')
                            .every(m => embeddedSignatures.some(es => es.marker_id_ref === m.marker_id));
                        
                        if (markers.some(m=> m.status === 'signed_by_user_b') && allSignedAndPresent) {
                            showMessage("Todas las firmas disponibles ya han sido cargadas.");
                        } else if (!markers.some(m => m.status === 'signed_by_user_b')) {
                            showMessage("Aún no hay firmas de Usuario B para este documento.");
                        } else {
                            showMessage("No hay nuevas firmas o todas las firmas ya han sido cargadas.");
                        }
                    }
                }
                repositionSignatures(); 
                repositionActiveSignatureBox();

            } catch (error) {
                console.error("Error verificando firmas:", error);
                showMessage(`Error al verificar firmas: ${error.message}`);
            }
        }

        window.addEventListener('mousemove', (e) => {
            if (isDraggingSigBox || isResizingSigBox) return;
            if (isDraggingPdf && !pinchState.active) handlePdfMove(e.clientX, e.clientY);
        });
        window.addEventListener('touchmove', (e) => {
            if (isDraggingSigBox || isResizingSigBox) return;
            if (pinchState.active && e.touches.length === 2) { e.preventDefault(); handlePinchMove(e.touches[0], e.touches[1]); }
            else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) handlePdfMove(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        window.addEventListener('mouseup', () => { 
            if (isDraggingPdf) {
                isDraggingPdf = false;
                canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default';
            }
        });
        window.addEventListener('touchend', (e) => { 
            if (isDraggingPdf) isDraggingPdf = false;
            if (pinchState.active && e.touches.length < 2) pinchState.active = false; 
        });
        
        // Variable para almacenar la suscripción a Realtime
        let realtimeSubscription = null;

        /**
         * Configura un listener de Realtime para la tabla signature_markers.
         * Se desuscribe de cualquier listener anterior para evitar duplicados.
         */
        async function setupRealtimeListener() {
            if (!supabaseClient) {
                console.warn("Realtime: Cliente Supabase no inicializado, no se puede configurar el listener.");
                return;
            }

            // Desuscribir de cualquier suscripción anterior para evitar duplicados
            if (realtimeSubscription) {
                console.log("Realtime: Desuscribiendo de la suscripción anterior.");
                await supabaseClient.removeChannel(realtimeSubscription);
                realtimeSubscription = null;
            }

            if (sharedDocIdForUserA) {
                console.log(`Realtime: Intentando suscribir a cambios para doc_id: ${sharedDocIdForUserA}`);
                realtimeSubscription = supabaseClient
                    .channel(`public:signature_markers:doc_id=eq.${sharedDocIdForUserA}`) // Canal específico por doc_id
                    .on('postgres_changes', {
                        event: 'UPDATE', // Solo escuchamos cuando se actualiza un registro
                        schema: 'public',
                        table: 'signature_markers',
                        filter: `doc_id=eq.${sharedDocIdForUserA}` // Filtramos por el ID de nuestro documento
                    }, payload => {
                        console.log('Realtime: Cambio detectado en signature_markers:', payload);
                        // Comprobamos si el cambio es relevante para la firma del usuario B
                        if (payload.new && payload.new.status === 'signed_by_user_b' && payload.new.signed_signature_storage_path) {
                            // Verificamos si esta firma ya está cargada en nuestro array local para evitar duplicados
                            const isAlreadyEmbedded = embeddedSignatures.some(sig => sig.marker_id_ref === payload.new.marker_id);
                            if (!isAlreadyEmbedded) {
                                showMessage('¡Usuario B ha firmado el documento! Actualizando documento...');
                                // Llamamos a checkSignaturesStatus para que se encargue de descargar y renderizar la nueva firma
                                checkSignaturesStatus(); 
                            } else {
                                console.log(`Realtime: Firma para marcador ${payload.new.marker_id} ya incrustada.`);
                            }
                        }
                    })
                    .subscribe((status, err) => {
                        if (status === 'SUBSCRIBED') {
                            console.log(`Realtime: Suscrito con éxito al documento ${sharedDocIdForUserA}`);
                            // Opcional: Llama a checkSignaturesStatus() inmediatamente después de suscribirte
                            // para cargar cualquier firma que haya ocurrido antes de que te suscribieras (si el PDF ya está cargado).
                            if (pdfDoc) { 
                                checkSignaturesStatus();
                            }
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('Realtime: Error en el canal:', err);
                            showMessage(`Error en la conexión en tiempo real: ${err.message}. Intenta refrescar.`);
                        } else if (status === 'CLOSED') {
                            console.log('Realtime: Canal cerrado.');
                        } else {
                             console.log(`Realtime: Estado de suscripción: ${status}`);
                        }
                    });
            } else {
                console.log("Realtime: No hay sharedDocIdForUserA, el listener Realtime no se habilitará.");
            }
        }


        // Modificar el listener de 'load' para llamar a setupRealtimeListener
        window.addEventListener('load', async () => { 
            adjustViewerHeightAndRender();
            const urlParams = new URLSearchParams(window.location.search);
            const docIdFromUrl = urlParams.get('doc_id');
            const mode = urlParams.get('mode');

            // Lógica para restaurar sharedDocIdForUserA para el Usuario A o establecerlo para el Usuario B
            if (docIdFromUrl) {
                // Si hay doc_id en la URL, este es el documento relevante para esta sesión
                sharedDocIdForUserA = docIdFromUrl; // Se usa para la suscripción Realtime y para checkSignaturesStatus
            } else if (typeof Storage !== "undefined") {
                // Si no hay doc_id en la URL, intentamos recuperarlo de localStorage (para Usuario A que refrescó)
                const lastShared = localStorage.getItem('lastSharedDocIdForUserA');
                if (lastShared) {
                    sharedDocIdForUserA = lastShared;
                }
            }

            // Mostrar el botón "Verificar Firmas" si hay un doc_id compartido (para Usuario A)
            const checkBtn = document.getElementById('check-signatures-btn');
            if (checkBtn && sharedDocIdForUserA) {
                checkBtn.style.display = 'inline-block';
            }
            
            // Lógica específica para el modo de firma del Usuario B
            if (docIdFromUrl && mode === 'sign_for_user_b') { 
                console.log(`Modo Firmante (Usuario B): Cargando documento con ID: ${docIdFromUrl}`);
                document.getElementById('file-input').style.display = 'none';
                const addUserASigButton = document.getElementById('toolbar').querySelector('button[onclick="addSignatureBox()"]');
                if(addUserASigButton) addUserASigButton.style.display = 'none';
                
                // Ocultamos los botones de Guardar y Compartir para Usuario B al cargar inicialmente
                // Se habilitarán y cambiarán de función una vez que el PDF sea firmado.
                const savePdfBtn = document.getElementById('save-pdf-btn');
                if(savePdfBtn) savePdfBtn.style.display = 'none';
                const sharePdfBtn = document.getElementById('share-pdf-btn'); 
                if(sharePdfBtn) sharePdfBtn.style.display = 'none';
                if(checkBtn) checkBtn.style.display = 'none'; // El usuario B no debería usar este botón inicialmente

                showMessage(`Cargando documento ${docIdFromUrl} para firmar...`);

                if (!supabaseClient) {
                    showMessage("Error: Cliente Supabase no disponible para cargar el documento.");
                    return;
                }

                try {
                    const { data: markers, error: markerError } = await supabaseClient
                        .from('signature_markers')
                        .select('*')
                        .eq('doc_id', docIdFromUrl);

                    if (markerError) throw new Error(`Error obteniendo marcador: ${markerError.message}`);
                    
                    const targetMarker = markers ? markers.find(m => m.status === 'pending_user_b_signature' || m.status === 'signed_by_user_b') : null;

                    if (!targetMarker) {
                        showMessage("Documento no encontrado, ya procesado, o enlace inválido.");
                        if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
                        return;
                    }
                    
                    markerDataForUserB = targetMarker; 
                    let pdfPathInStorage = markerDataForUserB.pdf_storage_path;

                    if (!pdfPathInStorage) { 
                        console.warn("pdf_storage_path no encontrado en el marcador, intentando listar archivos...");
                        const { data: fileList, error: listError } = await supabaseClient.storage
                            .from('pdfs')
                            .list(`documents/${docIdFromUrl}`, { limit: 1, sortBy: { column: 'created_at', order: 'desc' } });
                        if (listError || !fileList || fileList.length === 0) {
                            throw new Error(`No se encontró el archivo PDF en storage para ${docIdFromUrl}: ${listError ? listError.message : 'Lista vacía'}`);
                        }
                        pdfPathInStorage = fileList[0].name; 
                        originalFileName = fileList[0].name;
                        pdfPathInStorage = `documents/${docIdFromUrl}/${pdfPathInStorage}`; 
                    } else {
                        originalFileName = pdfPathInStorage.split('/').pop(); 
                    }

                    const { data: pdfBlobData, error: downloadError } = await supabaseClient.storage
                        .from('pdfs') 
                        .download(pdfPathInStorage);

                    if (downloadError) throw new Error(`Error descargando PDF (${pdfPathInStorage}): ${downloadError.message}`);
                    originalPdfFileBlob = pdfBlobData;

                    const reader = new FileReader();
                    reader.onload = async function (e_reader) {
                        try { 
                            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                            }
                            const loadingTask = pdfjsLib.getDocument({ data: e_reader.target.result });
                            pdfDoc = await loadingTask.promise;
                            totalPages = pdfDoc.numPages;
                            currentPage = markerDataForUserB.page;
                            translatePos = { x: 0, y: 0 }; scale = 1;
                            document.getElementById('zoom-slider').value = scale;
                            document.getElementById('total-pages').textContent = totalPages;
                            document.getElementById('current-page').textContent = currentPage;
                            
                            embeddedSignatures = [];
                            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
                            if (signatureBoxEl) { signatureBoxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null;}
                            pageVisitCounts = {}; totalPageViewsSession = 0;

                            await renderPage(currentPage); 

                            if (markerDataForUserB.status === 'signed_by_user_b' && markerDataForUserB.signed_signature_storage_path) {
                                showMessage("Este documento ya ha sido firmado. Mostrando firma...");
                                const { data: sigBlob, error: sigErr } = await supabaseClient.storage.from('pdfs').download(markerDataForUserB.signed_signature_storage_path);
                                if (sigErr) throw new Error("Error descargando la firma existente: " + sigErr.message);
                                const sigDataURL = await new Promise((resolve, reject) => {
                                        const r = new FileReader(); r.onloadend = () => resolve(r.result); r.onerror = reject; r.readAsDataURL(sigBlob);
                                });
                                embedSignature(true, { 
                                    page: markerDataForUserB.page,
                                    x_coord: markerDataForUserB.x_coord,
                                    y_coord: markerDataForUserB.y_coord,
                                    width_val: markerDataForUserB.width_val,
                                    height_val: markerDataForUserB.height_val,
                                    dataURL: sigDataURL,
                                    marker_id: markerDataForUserB.marker_id
                                });

                                // Habilitar y configurar botones para Usuario B después de cargar PDF ya firmado
                                const savePdfBtn = document.getElementById('save-pdf-btn');
                                const sharePdfBtn = document.getElementById('share-pdf-btn');
                                if (savePdfBtn) {
                                    savePdfBtn.style.display = 'inline-block';
                                    savePdfBtn.textContent = '💾 Guardar PDF Final';
                                    savePdfBtn.onclick = () => shareSignedPdfByB(docIdFromUrl, originalFileName);
                                }
                                if (sharePdfBtn) {
                                    sharePdfBtn.textContent = '📤 Compartir PDF Final'; 
                                    sharePdfBtn.onclick = () => shareSignedPdfByB(docIdFromUrl, originalFileName);
                                    sharePdfBtn.style.display = 'inline-block';
                                }

                            } else if (markerDataForUserB.status === 'pending_user_b_signature') {
                                    showMessage("Documento cargado. Haz clic en el área indicada para firmar.");
                                }
                        } catch (pdfLoadError) {
                               console.error("Error procesando PDF para Usuario B:", pdfLoadError);
                               showMessage(`Error al procesar el PDF: ${pdfLoadError.message}`);
                        }
                    };
                    reader.readAsArrayBuffer(pdfBlobData);

                } catch (error) {
                    console.error("Error cargando documento para Usuario B:", error);
                    showMessage(`Error al cargar el documento: ${error.message}`);
                    if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
                }
            } else if (docIdFromUrl && mode === 'sign') { 
                console.log(`Modo Firmante (Antiguo): Cargar documento con ID: ${docIdFromUrl}`);
                showMessage(`Modo Firmante (Antiguo) detectado.\nID del Documento: ${docIdFromUrl}\n\n(Este modo puede estar obsoleto o no completamente funcional con las nuevas características.)`);
                document.getElementById('file-input').style.display = 'none';
            }
            
            // Llama a la función de Realtime listener después de que sharedDocIdForUserA
            // haya sido establecido (tanto para Usuario A como para Usuario B si aplica)
            setupRealtimeListener();
        });
        window.addEventListener('resize', adjustViewerHeightAndRender);

    </script>
</body>
</html>
