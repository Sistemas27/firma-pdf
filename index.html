<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Firmar Documento PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #e9ecef;
      overflow: hidden;
    }

    header {
      background: #343a40;
      color: white;
      padding: 0.5rem;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    header h2 {
        margin-top: 0.2rem;
        margin-bottom: 0.5rem;
        font-size: 1.15rem;
        font-weight: 500;
    }

    .navigation-toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 380px;
      margin: 0 auto 0.5rem auto;
    }

    #page-info {
      margin: 0 0.8rem;
      font-size: 0.8rem;
      white-space: nowrap;
      color: #adb5bd;
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.3rem;
      width: 100%;
    }

    .toolbar-btn {
      background: #007bff;
      border: none;
      padding: 0.45rem 0.8rem;
      margin: 0.15rem;
      color: white;
      font-size: 0.8rem;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
      flex-grow: 0;
      flex-basis: auto;
    }
    .toolbar-btn:hover {
        background-color: #0056b3;
        box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
    }
    .toolbar-btn.page-nav-btn {
        min-width: auto;
        padding: 0.4rem 0.7rem;
        background-color: #495057;
    }
    .toolbar-btn.page-nav-btn:hover {
        background-color: #343a40;
        box-shadow: 0 0 0 0.2rem rgba(108,117,125,.25);
    }


    #pdf-viewer {
      width: 100vw;
      /* height will be set by JS */
      overflow: hidden;
      background: #f8f9fa;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none; /* Prevent default touch actions like scroll/zoom on the viewer itself */
    }

    .page-usage-counter {
        position: absolute;
        top: 8px;
        padding: 4px 8px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        font-size: 0.7rem;
        border-radius: 0.2rem;
        z-index: 50;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #current-page-visits {
        left: 8px;
    }
    #total-page-views {
        right: 8px;
    }


    #pdf-canvas {
      cursor: grab;
      image-rendering: -webkit-optimize-contrast; /* for Chrome/Safari */
      image-rendering: crisp-edges; /* for Firefox */
      box-shadow: 0 0 10px rgba(0,0,0,0.1); /* Subtle shadow for depth */
    }

    #zoom-slider-container {
      position: fixed;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(52, 58, 64, 0.8);
      padding: 6px;
      border-radius: 0.25rem;
      z-index: 9999;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    #zoom-slider {
      writing-mode: bt-lr; /* IE */
      -webkit-appearance: slider-vertical; /* WebKit */
      width: 16px;
      height: 100px;
      transform: rotate(180deg); /* To have min at bottom */
    }

    input[type="file"]#file-input {
      padding: 0.4rem;
      border-radius: 0.25rem;
      border: 1px solid #ced4da;
      background-color: #fff;
      color: #495057;
      cursor: pointer;
      font-size: 0.75rem;
      max-width: 240px;
      margin: 0.15rem;
    }
    input[type="file"]#file-input::file-selector-button {
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.4rem 0.7rem;
        border-radius: 0.2rem;
        cursor: pointer;
        margin-right: 8px;
    }

    .signature-box {
      position: absolute;
      border: 1px solid #007bff;
      background-color: rgba(0, 123, 255, 0.08);
      cursor: move; /* Default cursor when draggable */
      z-index: 100;
      touch-action: none; /* Important for touch dragging */
      border-radius: 3px;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.35), 0 1px 4px rgba(0,0,0,0.15); /* Enhanced visibility */
    }
    .signature-box.position-confirmed {
        cursor: default; /* Cursor when position is locked */
        border: 1px dashed #6c757d;
        background-color: transparent;
        box-shadow: none; /* Remove active shadow */
    }


    .signature-box-controls {
      position: absolute;
      top: -38px; /* Position above the box */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 5px;
      background-color: #fff; /* Controls background */
      border-radius: 0.25rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }

    .signature-box-btn {
      width: 30px; /* Circular buttons */
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px; /* Icon size */
      border: none;
      color: white;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s ease;
    }
    .signature-box-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    .signature-box-btn.confirm { background-color: #28a745; } /* Green */
    .signature-box-btn.cancel { background-color: #dc3545; } /* Red */
    .signature-box-btn.edit { background-color: #ffc107; } /* Yellow */
    .signature-box-btn.draw { background-color: #007bff; } /* Blue */


    .resize-handle {
      position: absolute;
      width: 12px; /* Larger touch targets */
      height: 12px;
      background-color: #fff;
      border: 2px solid #007bff;
      border-radius: 50%;
      z-index: 101;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

    .signature-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 10px;
    }

    .signature-container {
      background-color: #ffffff; /* White background */
      padding: 25px; /* More padding */
      border-radius: 0.3rem; /* Consistent border radius */
      width: 100%;
      max-width: 550px; /* Max width for larger screens */
      height: auto;
      max-height: 90vh; /* Ensure it fits in viewport */
      display: flex;
      flex-direction: column;
      box-shadow: 0 0.5rem 1rem rgba(0,0,0,.15); /* Softer shadow */
    }

    .signature-canvas-container {
      flex-grow: 1; /* Allow canvas to take available space */
      border: 1px solid #ced4da; /* Standard border */
      margin-bottom: 20px; /* Space before controls */
      position: relative;
      min-height: 200px; /* Minimum drawing area */
      border-radius: 0.25rem; /* Rounded corners */
      overflow: hidden; /* Clip canvas if it overflows */
      background-color: #fff; /* Ensure background is white if canvas is transparent */
    }

    #signature-canvas {
      width: 100%;
      height: 100%;
      background-color: transparent; /* Let CSS control background */
      cursor: crosshair;
      touch-action: none; /* For drawing on touch devices */
    }

    .signature-controls {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap; /* Wrap buttons on smaller screens */
      gap: 10px; /* Space between buttons */
    }

    .signature-control-btn {
      padding: 0.6rem 1rem; /* Comfortable padding */
      border: none;
      border-radius: 0.25rem; /* Consistent border radius */
      cursor: pointer;
      font-size: 0.9rem;
      flex-grow: 1; /* Allow buttons to grow */
      min-width: 100px; /* Minimum width for readability */
      text-align: center;
      transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      font-weight: 500; /* Slightly bolder text */
    }
    .signature-control-btn:hover {
        transform: translateY(-2px); /* Subtle lift effect */
        box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Softer shadow on hover */
    }
    .signature-control-btn.cancel { background-color: #dc3545; color: white; }
    .signature-control-btn.clear { background-color: #ffc107; color: #212529; } /* Darker text for yellow */
    .signature-control-btn.confirm { background-color: #28a745; color: white; }


    .embedded-signature {
      position: absolute;
      z-index: 99; /* Below signature box but above canvas */
      pointer-events: none; /* Allow clicks to pass through to PDF if needed */
      transform-origin: top left; /* Ensure scaling is from top-left */
    }

    .message-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 15px;
    }
    .message-modal-content {
        background-color: white;
        padding: 25px;
        border-radius: 0.3rem;
        text-align: center;
        box-shadow: 0 0.5rem 1rem rgba(0,0,0,.175);
        max-width: 400px;
        width: 100%;
    }
    .message-modal-content p {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 1rem;
        color: #212529; /* Darker text for better readability */
    }
    .message-modal-content button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 0.5rem 1.25rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.95rem;
        transition: background-color 0.2s ease;
    }
    .message-modal-content button:hover {
        background-color: #0056b3;
    }

  </style>
</head>
<body>
  <header>
    <h2>Firmar Documento PDF</h2>
    <div class="navigation-toolbar">
      <button class="toolbar-btn page-nav-btn" onclick="prevPage()">⬅️ Anterior</button>
      <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
      <button class="toolbar-btn page-nav-btn" onclick="nextPage()">➡️ Siguiente</button>
    </div>
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" />
      <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
      <button class="toolbar-btn" onclick="downloadPDF()">📂 Guardar</button>
      <button class="toolbar-btn" id="share-pdf-btn" onclick="sharePDF()">📤 Compartir</button>
    </div>
  </header>

  <div id="pdf-viewer">
    <canvas id="pdf-canvas"></canvas>
    <div id="current-page-visits" class="page-usage-counter" title="Visitas a esta página">P: 0</div>
    <div id="total-page-views" class="page-usage-counter" title="Total vistas de página">T: 0</div>
  </div>

  <div id="zoom-slider-container">
    <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
  </div>

  <script>
    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1;
    let canvas = document.getElementById('pdf-canvas');
    let context = canvas.getContext('2d');
    const pdfViewer = document.getElementById('pdf-viewer');
    let rendering = false;

    let isDraggingPdf = false;
    let startPos = { x: 0, y: 0 };
    let translatePos = { x: 0, y: 0 };
    let isZoomed = false; // Tracks if canvas is larger than viewer or scale is not 1

    // Signature Box State Variables
    let embeddedSignatures = []; // Stores info about signatures placed on PDF
    let signatureBoxEl = null; // The draggable/resizable signature box element
    let isDraggingSigBox = false; // Is the signature box currently being dragged?
    let isResizingSigBox = false; // Is the signature box currently being resized?
    let signatureBoxDragOffset = { x: 0, y: 0 }; // Offset for dragging signature box
    let resizeHandleTypeSigBox = null; // Which resize handle is active (e.g., 'nw', 'se')
    let startBoxPosSigBox = { x: 0, y: 0 }; // Initial position of signature box for resize
    let startBoxSizeSigBox = { width: 0, height: 0 }; // Initial size of signature box for resize
    let startPointerPosSigBox = { x: 0, y: 0 }; // Initial mouse/touch position for resize

    // Signature Pad (Modal) State Variables
    let signatureModalEl = null; // The modal element for drawing signature
    let signaturePadCanvasEl = null; // The canvas element within the modal for drawing
    let signaturePadCtxEl = null; // The 2D context of the signature pad canvas
    let isDrawingOnPadEl = false; // Is the user currently drawing on the signature pad?
    let lastDrawPadPosEl = { x: 0, y: 0 }; // Last position while drawing on pad

    // Pinch Zoom State
    let pinchState = {
        active: false, initialDistance: 0, lastScale: 1,
        pdfPointX: 0, pdfPointY: 0, // Point on PDF under pinch center
        screenCenterX: 0, screenCenterY: 0 // Pinch center on screen
    };

    // Page visit tracking
    let pageVisitCounts = {}; // { pageNum: count }
    let totalPageViewsSession = 0;


    // --- Utility Functions ---
    function showMessage(message) {
        // Remove any existing message modal first
        const existingModal = document.querySelector('.message-modal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.className = 'message-modal';
        const content = document.createElement('div');
        content.className = 'message-modal-content';
        content.innerHTML = `<p>${message}</p><button>OK</button>`;
        modal.appendChild(content);
        document.body.appendChild(modal);
        content.querySelector('button').onclick = () => modal.remove();
    }

    // --- PDF Loading and Rendering ---
    document.getElementById('file-input').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'application/pdf') {
        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            // Ensure PDF.js worker is configured
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                 pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            }
            const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;
            currentPage = 1;
            translatePos = { x: 0, y: 0 }; // Reset pan
            scale = 1; // Reset zoom
            document.getElementById('zoom-slider').value = scale;
            document.getElementById('total-pages').textContent = totalPages;
            document.getElementById('current-page').textContent = currentPage;

            // Clear previous signatures and state
            embeddedSignatures = [];
            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
            if (signatureBoxEl) {
                signatureBoxEl.remove();
                signatureBoxEl = null;
            }
            pageVisitCounts = {};
            totalPageViewsSession = 0;
            updatePageUsageCounters(); // Update for the first page

            renderPage(currentPage);
          } catch (err) {
            showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
            console.error("Error loading PDF:", err);
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file) {
        showMessage('Por favor, selecciona un archivo PDF.');
      }
    });

    function updatePageUsageCounters() {
        if (!pdfDoc) return; // Don't count if no PDF is loaded
        pageVisitCounts[currentPage] = (pageVisitCounts[currentPage] || 0) + 1;
        totalPageViewsSession++;
        document.getElementById('current-page-visits').textContent = `P${currentPage}: ${pageVisitCounts[currentPage]}`;
        document.getElementById('total-page-views').textContent = `T: ${totalPageViewsSession}`;
    }


    function renderPage(num) {
      if (!pdfDoc || rendering) return;
      rendering = true;

      updatePageUsageCounters(); // Call this when a page starts rendering

      pdfDoc.getPage(num).then(page => {
        const dpr = window.devicePixelRatio || 1; // Device Pixel Ratio for sharp rendering
        const viewportForRender = page.getViewport({ scale: scale * dpr }); // Viewport for actual canvas drawing

        // Set canvas internal dimensions (higher for sharpness)
        canvas.width = viewportForRender.width;
        canvas.height = viewportForRender.height;

        // Set canvas CSS dimensions (for display)
        const viewportCss = page.getViewport({ scale: scale }); // Viewport for CSS sizing
        canvas.style.width = `${viewportCss.width}px`;
        canvas.style.height = `${viewportCss.height}px`;

        // Center canvas within the viewer if smaller than viewer
        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = viewportCss.width; // Use parsed float for reliable comparison
        const cssCanvasHeight = viewportCss.height;

        // Calculate initial centering offsets (these are for the canvas element itself, not translatePos)
        if (cssCanvasWidth < viewerWidth) {
            canvas.style.left = `${(viewerWidth - cssCanvasWidth) / 2}px`;
        } else {
            canvas.style.left = '0px';
        }
        if (cssCanvasHeight < viewerHeight) {
            canvas.style.top = `${(viewerHeight - cssCanvasHeight) / 2}px`;
        } else {
            canvas.style.top = '0px';
        }
        canvas.style.position = 'absolute'; // Ensure canvas is absolutely positioned for left/top/transform

        const renderContext = {
            canvasContext: context,
            viewport: viewportForRender
        };

        const renderTask = page.render(renderContext);

        renderTask.promise.then(() => {
          rendering = false;
          document.getElementById('current-page').textContent = num;
          // Determine if canvas is effectively "zoomed" (scrollable)
          isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
          updateCanvasTransform(); // Apply current pan
          repositionSignatures(); // Reposition any existing signatures
        }).catch(err => {
            rendering = false;
            console.error("Error rendering page:", err);
            showMessage("Error al renderizar la página del PDF.");
        });
      }).catch(err => {
          rendering = false;
          console.error("Error getting page:", err);
          showMessage("Error al obtener la página del PDF.");
      });
    }

    function updateCanvasTransform() {
        // Apply pan and scale transformations
        canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
        repositionSignatures(); // Update signature positions based on new transform
    }

    // --- PDF Panning and Zooming Event Handlers ---
    canvas.addEventListener('mousedown', (e) => {
      // Prevent PDF drag if interacting with signature box or if not zoomed/scrollable
      if (isDraggingSigBox || isResizingSigBox || pinchState.active) return;
      const cssCanvasWidth = parseFloat(canvas.style.width);
      const cssCanvasHeight = parseFloat(canvas.style.height);
      // Only allow dragging if canvas is larger than viewer or explicitly zoomed
      if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
      if (e.target !== canvas) return; // Ensure click is directly on canvas

      isDraggingPdf = true;
      startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
      canvas.style.cursor = 'grabbing';
    });

    pdfViewer.addEventListener('touchstart', (e) => {
        // If touch is on signature box or its children, let signature box handlers deal with it.
        // Signature box handlers use stopImmediatePropagation.
        if (signatureBoxEl && (e.target === signatureBoxEl || signatureBoxEl.contains(e.target))) {
            return;
        }

        if (isDraggingSigBox || isResizingSigBox) return; // Double check to ensure no conflict

        if (e.touches.length === 2) { // Pinch to zoom
            e.preventDefault(); // Prevent browser default pinch zoom
            isDraggingPdf = false; // Stop panning if it was active
            pinchState.active = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            pinchState.lastScale = scale;

            // Calculate pinch center relative to PDF viewer
            const viewerRect = pdfViewer.getBoundingClientRect();
            pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
            pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;

            // Calculate the point on the PDF (in its own coordinate system) that is under the pinch center
            const canvasRect = canvas.getBoundingClientRect(); // Current screen position of canvas
            // Point on canvas (screen coordinates relative to canvas top-left)
            const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
            const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;

            // Convert to PDF's own scaled coordinates (before this new pinch zoom)
            pinchState.pdfPointX = pdfPointScreenX / scale;
            pinchState.pdfPointY = pdfPointScreenY / scale;

        } else if (e.touches.length === 1 && !pinchState.active) { // Single touch pan
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            if ((!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) || e.target !== canvas) {
                 isDraggingPdf = false; return; // Don't drag if not scrollable or touch not on canvas
            }
            isDraggingPdf = true;
            const touch = e.touches[0];
            startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
        }
    }, { passive: false }); // passive: false needed for e.preventDefault() in touchstart


    function handlePdfMove(clientX, clientY) {
        if (!isDraggingPdf) return;

        let newTranslateX = clientX - startPos.x;
        let newTranslateY = clientY - startPos.y;

        // Constrain panning within reasonable bounds
        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);

        const overpanMargin = 30; // Allow some overpan

        // Horizontal panning constraints
        if (cssCanvasWidth > viewerWidth) {
            const minX = viewerWidth - cssCanvasWidth - overpanMargin; // Max negative translate
            const maxX = overpanMargin; // Max positive translate
            newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
        } else {
            newTranslateX = 0; // No horizontal pan if canvas fits
        }

        // Vertical panning constraints
        if (cssCanvasHeight > viewerHeight) {
            const minY = viewerHeight - cssCanvasHeight - overpanMargin; // Max negative translate
            const maxY = overpanMargin; // Max positive translate
            newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
        } else {
            newTranslateY = 0; // No vertical pan if canvas fits
        }

        translatePos.x = newTranslateX;
        translatePos.y = newTranslateY;
        updateCanvasTransform();
    }

    function handlePinchMove(touch1, touch2) {
        if (!pinchState.active || pinchState.initialDistance === 0) return;

        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
        newScale = Math.min(3.0, Math.max(0.5, parseFloat(newScale.toFixed(2)))); // Clamp and round

        // Avoid re-rendering for tiny scale changes unless at min/max
        if (Math.abs(newScale - scale) < 0.01 && newScale !== 0.5 && newScale !== 3.0) return;

        scale = newScale;

        // Adjust translatePos to keep the pinchPoint (pdfPointX, pdfPointY) stationary on screen
        const viewerRect = pdfViewer.getBoundingClientRect(); // pdfViewer's position relative to viewport

        // The canvas.offsetLeft/Top is its initial centering offset *without* the transform.
        // We need to calculate the new translatePos.x/y
        // such that: screenCenterX - (canvas.offsetLeft + newTranslateX) = pdfPointX * newScale
        // newTranslateX = screenCenterX - canvas.offsetLeft - (pdfPointX * newScale)

        translatePos.x = (pinchState.screenCenterX - viewerRect.left - canvas.offsetLeft) - (pinchState.pdfPointX * scale);
        translatePos.y = (pinchState.screenCenterY - viewerRect.top - canvas.offsetTop) - (pinchState.pdfPointY * scale);

        document.getElementById('zoom-slider').value = scale.toFixed(1);
        renderPage(currentPage); // Re-render with new scale and adjusted pan
    }

    function nextPage() {
      if (!pdfDoc || currentPage >= totalPages) return;
      currentPage++;
      translatePos = { x: 0, y: 0 }; // Reset pan for new page
      renderPage(currentPage);
    }

    function prevPage() {
      if (!pdfDoc || currentPage <= 1) return;
      currentPage--;
      translatePos = { x: 0, y: 0 }; // Reset pan for new page
      renderPage(currentPage);
    }

    document.getElementById('zoom-slider').addEventListener('input', async function () {
      if (!pdfDoc) return;
      const oldScale = scale;
      scale = parseFloat(this.value);

      // --- Zoom towards center of the viewer ---
      const viewerRect = pdfViewer.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect(); // Current screen position of canvas

      // Center of the viewer on screen
      const screenCenterX = viewerRect.left + viewerRect.width / 2;
      const screenCenterY = viewerRect.top + viewerRect.height / 2;

      // Point on PDF (scaled coordinates) under the screen center before zoom
      const pdfPointX = (screenCenterX - canvasRect.left) / oldScale;
      const pdfPointY = (screenCenterY - canvasRect.top) / oldScale;

      // Get new canvas dimensions to calculate its expected offsetLeft/Top if centered
      const page = await pdfDoc.getPage(currentPage); // Need page for viewport
      const newViewportCss = page.getViewport({scale: scale}); // For CSS size

      let expectedCanvasOffsetLeft = 0;
      if (newViewportCss.width < viewerRect.width) {
          expectedCanvasOffsetLeft = (viewerRect.width - newViewportCss.width) / 2;
      }
      let expectedCanvasOffsetTop = 0;
      if (newViewportCss.height < viewerRect.height) {
          expectedCanvasOffsetTop = (viewerRect.height - newViewportCss.height) / 2;
      }

      // Calculate new translatePos to keep pdfPointX/Y at screenCenterX/Y
      translatePos.x = (screenCenterX - viewerRect.left - expectedCanvasOffsetLeft) - (pdfPointX * scale);
      translatePos.y = (screenCenterY - viewerRect.top - expectedCanvasOffsetTop) - (pdfPointY * scale);
      // --- End zoom towards center ---

      renderPage(currentPage);
      pinchState.lastScale = scale; // Update for potential subsequent pinch
    });

    pdfViewer.addEventListener('wheel', async function (e) { // Listen on viewer for broader capture
      if (!pdfDoc) return;
      e.preventDefault(); // Prevent page scroll

      const oldScale = scale;
      const delta = e.deltaY > 0 ? -0.1 : 0.1; // Zoom out for scroll down, in for scroll up
      let newScale = parseFloat((scale + delta).toFixed(2)); // Limit precision
      newScale = Math.min(3.0, Math.max(0.5, newScale)); // Clamp scale

      // Avoid re-rendering for tiny scale changes unless at min/max
      if (Math.abs(newScale - oldScale) < 0.01 && newScale !==0.5 && newScale !== 3.0) return;

      // --- Zoom towards mouse pointer ---
      const viewerRect = pdfViewer.getBoundingClientRect();
      // Mouse position relative to the viewer's top-left corner
      const mouseXViewer = e.clientX - viewerRect.left;
      const mouseYViewer = e.clientY - viewerRect.top;

      const canvasRect = canvas.getBoundingClientRect(); // Current screen position of canvas
      // Mouse position relative to the canvas's top-left (transformed)
      const mouseXOnCanvas = e.clientX - canvasRect.left;
      const mouseYOnCanvas = e.clientY - canvasRect.top;

      // Point on PDF (scaled coordinates) under the mouse before zoom
      const pdfPointX = mouseXOnCanvas / oldScale;
      const pdfPointY = mouseYOnCanvas / oldScale;

      scale = newScale; // Update global scale

      // Get new canvas dimensions to calculate its expected offsetLeft/Top if centered
      const page = await pdfDoc.getPage(currentPage);
      const newViewportCss = page.getViewport({ scale: scale });

      let expectedCanvasLeft = 0; // Canvas's base offset if it were centered (without pan)
      if (newViewportCss.width < viewerRect.width) {
          expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
      }
      let expectedCanvasTop = 0;
      if (newViewportCss.height < viewerRect.height) {
          expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
      }

      // Calculate new translatePos to keep pdfPointX/Y at mouseXViewer/YViewer
      // mouseXViewer = expectedCanvasLeft + newTranslateX + (pdfPointX * newScale)
      // newTranslateX = mouseXViewer - expectedCanvasLeft - (pdfPointX * newScale)
      translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
      translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
      // --- End zoom towards mouse pointer ---

      document.getElementById('zoom-slider').value = scale.toFixed(1);
      renderPage(currentPage);
    }, { passive: false }); // passive: false for e.preventDefault()

    // --- PDF Saving and Sharing ---
    async function downloadPDF() {
        if (!pdfDoc) {
            showMessage("Carga un PDF primero.");
            return;
        }
        const { jsPDF } = window.jspdf;
        const newPdfDocGen = new jsPDF(); // orientation: p or l, unit: pt, format: a4 (default)
        // Remove the default first page if jsPDF adds one
        while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }

        showMessage("Preparando PDF para descarga..."); // Show progress

        for (let i = 1; i <= totalPages; i++) {
            const page = await pdfDoc.getPage(i);
            // Use a higher scale for better quality in the generated PDF, but not excessively high.
            // PDF units are points (1/72 inch).
            const downloadScale = 2.0; // Render at 2x resolution for the PDF
            const viewport = page.getViewport({ scale: downloadScale });

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;

            await page.render({ canvasContext: tempCtx, viewport }).promise;

            // Embed signatures for this page onto the temporary canvas
            embeddedSignatures.filter(sig => sig.page === i).forEach(sigInfo => {
                const img = new Image();
                img.src = sigInfo.dataURL; // Assumes signatures are stored as data URLs
                // Convert signature coordinates (which are relative to original page size at scale=1)
                // to the downloadScale.
                const x = sigInfo.x * downloadScale;
                const y = sigInfo.y * downloadScale;
                const width = sigInfo.width * downloadScale;
                const height = sigInfo.height * downloadScale;
                tempCtx.drawImage(img, x, y, width, height);
            });

            const imgData = tempCanvas.toDataURL('image/jpeg', 0.9); // Use JPEG for smaller file size, 0.9 quality

            // Add page to jsPDF document with dimensions from viewport
            // jsPDF addPage format: [width, height] in points
            newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
            newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
        }

        newPdfDocGen.save('documento-firmado.pdf');
        showMessage("PDF guardado.");
    }

    function sharePDF() {
        // Placeholder for share functionality
        showMessage("La función de compartir se implementará próximamente.");
        // Example: navigator.share if supported and file is prepared
    }

    // --- Signature Box Management ---
    function addSignatureBox() {
      if (!pdfDoc) {
        showMessage("Por favor, carga un documento PDF primero.");
        return;
      }
      // Remove existing signature box if any
      if (signatureBoxEl) { signatureBoxEl.remove(); }

      signatureBoxEl = document.createElement('div');
      signatureBoxEl.className = 'signature-box';
      signatureBoxEl.style.width = '150px'; // Default size
      signatureBoxEl.style.height = '75px';

      // Position in the center of the current view of pdfViewer
      const viewerRect = pdfViewer.getBoundingClientRect();
      signatureBoxEl.style.left = `${(viewerRect.width - 150) / 2}px`;
      signatureBoxEl.style.top = `${(viewerRect.height - 75) / 2}px`;

      pdfViewer.appendChild(signatureBoxEl); // Add to viewer, not canvas
      makeSignatureBoxEditable(signatureBoxEl); // Make it draggable, resizable, with controls
    }

    function confirmSignatureBoxPlacement(boxEl) {
        if (!boxEl) return;
        // Remove resize handles
        const handles = boxEl.querySelectorAll('.resize-handle');
        handles.forEach(h => h.remove());
        boxEl.classList.add('position-confirmed'); // Changes cursor and appearance via CSS

        // Update controls: Draw, Edit Position, Cancel
        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) { // Should not happen if makeEditable was called, but good practice
            controls = document.createElement('div');
            controls.className = 'signature-box-controls';
            boxEl.appendChild(controls);
        }
        controls.innerHTML = ''; // Clear previous buttons (e.g., confirm/cancel placement)

        const drawBtn = document.createElement('button');
        drawBtn.className = 'signature-box-btn draw';
        drawBtn.innerHTML = '✍️'; // Pencil icon
        drawBtn.title = 'Dibujar Firma';
        drawBtn.onclick = (e) => { e.stopPropagation(); openSignatureModal(); }; // Stop propagation to avoid issues

        const editPosBtn = document.createElement('button');
        editPosBtn.className = 'signature-box-btn edit';
        editPosBtn.innerHTML = '✏️'; // Edit icon
        editPosBtn.title = 'Editar Posición';
        editPosBtn.onclick = (e) => { e.stopPropagation(); makeSignatureBoxEditable(boxEl); };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = '❌'; // Cross icon
        cancelBtn.title = 'Cancelar Firma';
        cancelBtn.onclick = (e) => { e.stopPropagation(); boxEl.remove(); signatureBoxEl = null; };

        controls.appendChild(drawBtn);
        controls.appendChild(editPosBtn);
        controls.appendChild(cancelBtn);
    }

    function makeSignatureBoxEditable(boxEl) {
        if (!boxEl) return;
        boxEl.classList.remove('position-confirmed'); // Allows dragging/resizing styles/behavior

        // Remove and re-add resize handles to ensure they are fresh and correctly positioned
        boxEl.querySelectorAll('.resize-handle').forEach(h => h.remove());
        addResizeHandlesToSigBox(boxEl); // Adds resize handles with their event listeners

        // Setup/Update controls: Confirm Placement, Cancel
        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) {
            controls = document.createElement('div');
            controls.className = 'signature-box-controls';
            boxEl.appendChild(controls);
        }
        controls.innerHTML = ''; // Clear previous buttons

        const confirmPlacementBtn = document.createElement('button');
        confirmPlacementBtn.className = 'signature-box-btn confirm';
        confirmPlacementBtn.innerHTML = '✔️'; // Checkmark icon
        confirmPlacementBtn.title = 'Confirmar Posición';
        confirmPlacementBtn.onclick = (e) => { e.stopPropagation(); confirmSignatureBoxPlacement(boxEl); };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = '❌'; // Cross icon
        cancelBtn.title = 'Cancelar';
        cancelBtn.onclick = (e) => { e.stopPropagation(); boxEl.remove(); signatureBoxEl = null; };

        controls.appendChild(confirmPlacementBtn);
        controls.appendChild(cancelBtn);

        // ***** THIS IS THE KEY FIX *****
        // Ensure drag events are (re-)initialized for this box
        setupSigBoxDragEvents(boxEl);
    }


    // --- Event Handlers for Signature Box (Dynamically added/removed on window) ---
    // These are named functions to allow removal from window
    const _onSigBoxDragMove = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        handleSigBoxDragMove(clientX, clientY);
    };

    const _onSigBoxDragEnd = () => {
        isDraggingSigBox = false;
        // Remove global listeners
        window.removeEventListener('mousemove', _onSigBoxDragMove);
        window.removeEventListener('touchmove', _onSigBoxDragMove);
        window.removeEventListener('mouseup', _onSigBoxDragEnd);
        window.removeEventListener('touchend', _onSigBoxDragEnd);
    };

    const _onSigBoxResizeMove = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        handleSigBoxResizeMove(clientX, clientY);
    };

    const _onSigBoxResizeEnd = () => {
        isResizingSigBox = false;
        resizeHandleTypeSigBox = null;
        // Remove global listeners
        window.removeEventListener('mousemove', _onSigBoxResizeMove);
        window.removeEventListener('touchmove', _onSigBoxResizeMove);
        window.removeEventListener('mouseup', _onSigBoxResizeEnd);
        window.removeEventListener('touchend', _onSigBoxResizeEnd);
    };
    // --- End Event Handlers for Signature Box ---


    function addResizeHandlesToSigBox(box) {
      const handles = ['nw', 'ne', 'sw', 'se']; // Corner handles
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        box.appendChild(handle);
        // Add event listeners for resizing
        handle.addEventListener('mousedown', (e) => {
          e.stopImmediatePropagation(); // CRUCIAL: Prevent this event from triggering box drag or PDF drag
          initSigBoxResize(e.clientX, e.clientY, pos, box);
        });
        handle.addEventListener('touchstart', (e) => {
          e.stopImmediatePropagation(); // CRUCIAL
          if (e.touches.length === 1) { // Ensure single touch for resize
            e.preventDefault(); // Prevent scrolling/other default actions
            initSigBoxResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
          }
        }, { passive: false }); // passive: false for e.preventDefault()
      });
    }

    function initSigBoxResize(clientX, clientY, handlePos, box) {
        if (box.classList.contains('position-confirmed')) return; // Cannot resize if confirmed
        isResizingSigBox = true;
        resizeHandleTypeSigBox = handlePos;
        // Store initial state for calculating new dimensions/positions
        startBoxPosSigBox = { x: box.offsetLeft, y: box.offsetTop };
        startBoxSizeSigBox = { width: box.offsetWidth, height: box.offsetHeight };
        startPointerPosSigBox = { x: clientX, y: clientY };

        // Disable other interactions
        isDraggingPdf = false;
        isDraggingSigBox = false; // Not dragging the whole box, just resizing
        pinchState.active = false;

        // Add global listeners for resize move and end
        window.addEventListener('mousemove', _onSigBoxResizeMove);
        window.addEventListener('touchmove', _onSigBoxResizeMove, { passive: false });
        window.addEventListener('mouseup', _onSigBoxResizeEnd);
        window.addEventListener('touchend', _onSigBoxResizeEnd);
    }

    function handleSigBoxResizeMove(clientX, clientY) {
        if (!isResizingSigBox || !resizeHandleTypeSigBox || !signatureBoxEl) return;
        const deltaX = clientX - startPointerPosSigBox.x;
        const deltaY = clientY - startPointerPosSigBox.y;
        let newWidth = startBoxSizeSigBox.width;
        let newHeight = startBoxSizeSigBox.height;
        let newLeft = startBoxPosSigBox.x;
        let newTop = startBoxPosSigBox.y;
        const minWidth = 50; // Minimum dimensions for the signature box
        const minHeight = 30;
        const viewerRect = pdfViewer.getBoundingClientRect(); // Boundaries

        // Adjust dimensions and position based on which handle is being dragged
        if (resizeHandleTypeSigBox.includes('w')) { newWidth = Math.max(minWidth, startBoxSizeSigBox.width - deltaX); newLeft = startBoxPosSigBox.x + (startBoxSizeSigBox.width - newWidth); }
        if (resizeHandleTypeSigBox.includes('e')) { newWidth = Math.max(minWidth, startBoxSizeSigBox.width + deltaX); }
        if (resizeHandleTypeSigBox.includes('n')) { newHeight = Math.max(minHeight, startBoxSizeSigBox.height - deltaY); newTop = startBoxPosSigBox.y + (startBoxSizeSigBox.height - newHeight); }
        if (resizeHandleTypeSigBox.includes('s')) { newHeight = Math.max(minHeight, startBoxSizeSigBox.height + deltaY); }

        // Boundary checks against the viewer
        if (newLeft < 0) { newWidth += newLeft; newLeft = 0; } // Adjust width if left edge goes out of bounds
        if (newTop < 0) { newHeight += newTop; newTop = 0; } // Adjust height if top edge goes out of bounds
        if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
        if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }

        // Ensure minimum dimensions are respected after boundary adjustments
        newWidth = Math.max(minWidth, newWidth);
        newHeight = Math.max(minHeight, newHeight);

        signatureBoxEl.style.width = `${newWidth}px`;
        signatureBoxEl.style.height = `${newHeight}px`;
        signatureBoxEl.style.left = `${newLeft}px`;
        signatureBoxEl.style.top = `${newTop}px`;
    }


    function setupSigBoxDragEvents(box) {
        // This function attaches mousedown/touchstart listeners directly to the box
        // for initiating a drag.
        function initSigBoxDrag(clientX, clientY) {
            if (box.classList.contains('position-confirmed')) return; // Cannot drag if confirmed
            isDraggingSigBox = true;
            const viewerRect = pdfViewer.getBoundingClientRect();
            // Calculate offset from mouse pointer to top-left of box, relative to viewer
            signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
            signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;

            // Disable other interactions
            isDraggingPdf = false;
            isResizingSigBox = false; // Not resizing, just dragging
            pinchState.active = false;

            // Add global listeners for drag move and end
            window.addEventListener('mousemove', _onSigBoxDragMove);
            window.addEventListener('touchmove', _onSigBoxDragMove, { passive: false });
            window.addEventListener('mouseup', _onSigBoxDragEnd);
            window.addEventListener('touchend', _onSigBoxDragEnd);
        }

        box.addEventListener('mousedown', (e) => {
            // Only drag if mousedown is directly on the box itself (not a child like a button or resize handle)
            // and if the box is not in a 'position-confirmed' state.
            if (e.target === box && !box.classList.contains('position-confirmed')) {
                e.stopImmediatePropagation(); // CRUCIAL: Prevent PDF drag or other underlying actions
                initSigBoxDrag(e.clientX, e.clientY);
            }
        });
        box.addEventListener('touchstart', (e) => {
            if (e.target === box && e.touches.length === 1 && !box.classList.contains('position-confirmed')) {
                e.stopImmediatePropagation(); // CRUCIAL
                e.preventDefault(); // Prevent default touch actions like scrolling
                initSigBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false }); // passive: false for e.preventDefault()
    }

    function handleSigBoxDragMove(clientX, clientY) {
        if (!isDraggingSigBox || !signatureBoxEl) return;
        const viewerRect = pdfViewer.getBoundingClientRect();
        // Calculate new top-left position relative to viewer
        let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
        let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;

        // Constrain movement within the viewer boundaries
        newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBoxEl.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBoxEl.offsetHeight));

        signatureBoxEl.style.left = `${newLeft}px`;
        signatureBoxEl.style.top = `${newTop}px`;
    }

    // --- Signature Pad Modal ---
    function openSignatureModal() {
      if (!signatureBoxEl) return; // Should not happen if called from button on box
      // Create modal structure
      signatureModalEl = document.createElement('div');
      signatureModalEl.className = 'signature-modal';
      const container = document.createElement('div');
      container.className = 'signature-container';
      const canvasContainer = document.createElement('div');
      canvasContainer.className = 'signature-canvas-container';
      signaturePadCanvasEl = document.createElement('canvas');
      signaturePadCanvasEl.id = 'signature-canvas';
      canvasContainer.appendChild(signaturePadCanvasEl);
      container.appendChild(canvasContainer);
      signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');

      // Controls for the signature pad
      const controls = document.createElement('div');
      controls.className = 'signature-controls';
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-control-btn cancel';
      cancelBtn.textContent = '❌ Cancelar';
      cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };

      const clearBtn = document.createElement('button');
      clearBtn.className = 'signature-control-btn clear';
      clearBtn.textContent = '↩️ Limpiar';
      clearBtn.onclick = () => {
        // Clear considering DPR
        signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / (window.devicePixelRatio||1) , signaturePadCanvasEl.height / (window.devicePixelRatio||1) );
      };

      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-control-btn confirm';
      confirmBtn.textContent = '✔️ Firmar';
      confirmBtn.onclick = embedSignature;

      controls.appendChild(cancelBtn);
      controls.appendChild(clearBtn);
      controls.appendChild(confirmBtn);
      container.appendChild(controls);
      signatureModalEl.appendChild(container);
      document.body.appendChild(signatureModalEl);

      // Set canvas size after it's in the DOM and sized by CSS
      requestAnimationFrame(() => { // Ensures dimensions are calculated after layout
        const rect = canvasContainer.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        signaturePadCanvasEl.width = rect.width * dpr;
        signaturePadCanvasEl.height = rect.height * dpr;

        signaturePadCanvasEl.style.width = `${rect.width}px`;
        signaturePadCanvasEl.style.height = `${rect.height}px`;

        signaturePadCtxEl.scale(dpr, dpr); // Scale context for high-DPI drawing

        // Set drawing style
        signaturePadCtxEl.lineWidth = 1.5; // Adjusted for better visibility
        signaturePadCtxEl.lineCap = 'round';
        signaturePadCtxEl.lineJoin = 'round';
        signaturePadCtxEl.strokeStyle = '#000000'; // Black ink
      });
      setupSignaturePadDrawingEventsEl(); // Attach drawing event listeners
    }

    function setupSignaturePadDrawingEventsEl() {
      function getPadPosition(e) {
        const rect = signaturePadCanvasEl.getBoundingClientRect();
        let clientX, clientY;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        // Position relative to canvas, not scaled by DPR here
        return {
          x: (clientX - rect.left),
          y: (clientY - rect.top)
        };
      }
      function startPadDraw(e) {
        e.preventDefault(); // Prevent page scroll on touch
        isDrawingOnPadEl = true;
        lastDrawPadPosEl = getPadPosition(e);
        signaturePadCtxEl.beginPath(); // Start a new path
        signaturePadCtxEl.moveTo(lastDrawPadPosEl.x, lastDrawPadPosEl.y); // Move to start point
      }
      function drawOnPad(e) {
        if (!isDrawingOnPadEl) return;
        e.preventDefault();
        const currentPos = getPadPosition(e);
        signaturePadCtxEl.lineTo(currentPos.x, currentPos.y); // Draw line to current point
        signaturePadCtxEl.stroke(); // Render the line
        lastDrawPadPosEl = currentPos;
      }
      function stopPadDraw() {
          if(isDrawingOnPadEl) { // Only if drawing was active
            isDrawingOnPadEl = false;
            // signaturePadCtxEl.closePath(); // Not strictly necessary for stroke paths
          }
      }
      // Mouse events
      signaturePadCanvasEl.addEventListener('mousedown', startPadDraw);
      signaturePadCanvasEl.addEventListener('mousemove', drawOnPad);
      signaturePadCanvasEl.addEventListener('mouseup', stopPadDraw);
      signaturePadCanvasEl.addEventListener('mouseout', stopPadDraw); // Stop if mouse leaves canvas
      // Touch events
      signaturePadCanvasEl.addEventListener('touchstart', startPadDraw, { passive: false });
      signaturePadCanvasEl.addEventListener('touchmove', drawOnPad, { passive: false });
      signaturePadCanvasEl.addEventListener('touchend', stopPadDraw);
    }

    function embedSignature() {
        // Check if signature pad is empty
        const tempCanvasTest = document.createElement('canvas');
        tempCanvasTest.width = signaturePadCanvasEl.width; // Use actual pixel dimensions
        tempCanvasTest.height = signaturePadCanvasEl.height;
        const blankDataURL = tempCanvasTest.toDataURL(); // Data URL of a blank canvas

        if (!signatureBoxEl || !signaturePadCanvasEl || signaturePadCtxEl.canvas.toDataURL() === blankDataURL) {
            showMessage("Por favor, dibuja una firma primero.");
            return;
        }

        const dataURL = signaturePadCanvasEl.toDataURL('image/png'); // Get signature as PNG
        const signatureImgElement = document.createElement('img');
        signatureImgElement.className = 'embedded-signature';
        signatureImgElement.src = dataURL;

        // Calculate signature position relative to the PDF page (at scale 1)
        // signatureBoxEl is positioned relative to pdfViewer
        // canvas (pdf page) is positioned relative to pdfViewer and transformed (pan)

        const boxCssLeft = signatureBoxEl.offsetLeft; // Position of box within viewer
        const boxCssTop = signatureBoxEl.offsetTop;

        // Canvas's current visual offset within the viewer, considering its own left/top and pan (translatePos)
        const canvasCssOffsetLeft = canvas.offsetLeft; // Canvas's base offset (centering)
        const canvasCssOffsetTop = canvas.offsetTop;

        // Position of signature box relative to the *displayed* (panned) canvas top-left corner
        const sigBoxRelativeToDisplayedCanvasX = boxCssLeft - canvasCssOffsetLeft - translatePos.x;
        const sigBoxRelativeToDisplayedCanvasY = boxCssTop - canvasCssOffsetTop - translatePos.y;

        // Convert this to coordinates on the PDF page itself (scale = 1)
        const sigPageX = sigBoxRelativeToDisplayedCanvasX / scale;
        const sigPageY = sigBoxRelativeToDisplayedCanvasY / scale;
        const sigPageWidth = signatureBoxEl.offsetWidth / scale;
        const sigPageHeight = signatureBoxEl.offsetHeight / scale;

        const signatureInfo = {
            element: signatureImgElement, page: currentPage,
            x: sigPageX, y: sigPageY, width: sigPageWidth, height: sigPageHeight,
            dataURL: dataURL // Store dataURL for saving to PDF
        };
        embeddedSignatures.push(signatureInfo);
        pdfViewer.appendChild(signatureImgElement); // Add image to viewer for display

        // Clean up
        signatureBoxEl.remove(); signatureBoxEl = null;
        if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
        repositionSignatures(); // Position the newly added signature image correctly
    }

    function repositionSignatures() {
        if (!pdfViewer || !canvas) return; // Ensure elements exist
        const viewerRect = pdfViewer.getBoundingClientRect();
        const pdfCanvasRect = canvas.getBoundingClientRect(); // Current visual position of PDF canvas on screen

        // Calculate the PDF canvas's top-left corner relative to the pdfViewer's top-left.
        // This is where the (0,0) of the *displayed* PDF page content starts within the viewer.
        const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
        const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;

        embeddedSignatures.forEach(sig => {
            if (sig.element) {
                if (sig.page === currentPage) {
                    // Calculate display position and size based on current PDF scale and pan
                    // sig.x, sig.y, sig.width, sig.height are at PDF scale 1
                    const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                    const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                    const displayWidth = sig.width * scale;
                    const displayHeight = sig.height * scale;

                    sig.element.style.left = `${displayX}px`;
                    sig.element.style.top = `${displayY}px`;
                    sig.element.style.width = `${displayWidth}px`;
                    sig.element.style.height = `${displayHeight}px`;
                    sig.element.style.display = 'block';
                } else {
                    sig.element.style.display = 'none'; // Hide if not on current page
                }
            }
        });
    }

    // --- Adjustments for Layout and Window Events ---
    function adjustViewerHeightAndRender() {
        const headerElement = document.querySelector('header');
        if (headerElement && pdfViewer) {
            const headerHeight = headerElement.offsetHeight;
            pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
        }
        // Re-render if PDF is loaded, as viewer size change might affect layout
        if (pdfDoc) { renderPage(currentPage); }
    }

    // --- Global Event Listeners for Mouse/Touch Up and Movement ---
    // These handle ending drags or continuing pans/pinches initiated elsewhere.
    window.addEventListener('mousemove', (e) => {
        // If signature box is being interacted with, its specific handlers (_onSigBoxDragMove, _onSigBoxResizeMove)
        // are active on the window and will handle the event. So, we return here to avoid conflict.
        if (isDraggingSigBox || isResizingSigBox) {
            return;
        }
        // If not interacting with signature box, then handle PDF panning.
        if (isDraggingPdf && !pinchState.active) { // Ensure not pinching
            handlePdfMove(e.clientX, e.clientY);
        }
    });

    window.addEventListener('touchmove', (e) => {
        if (isDraggingSigBox || isResizingSigBox) {
            // Let signature box specific touchmove handlers do their work.
            return;
        }
        // Handle PDF pinch or pan
        if (pinchState.active && e.touches.length === 2) {
            e.preventDefault(); // Prevent default browser pinch actions
            handlePinchMove(e.touches[0], e.touches[1]);
        } else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) {
            // e.preventDefault(); // Not always needed for single touch pan, but can prevent scroll
            handlePdfMove(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false }); // passive: false for e.preventDefault() in pinch

    window.addEventListener('mouseup', () => {
        // Signature box drag/resize end handlers (_onSigBoxDragEnd, _onSigBoxResizeEnd)
        // remove themselves from the window, so no explicit check for isDraggingSigBox needed here for removal.
        if (isDraggingPdf) {
            isDraggingPdf = false;
            // Reset cursor based on whether canvas is scrollable
            canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default';
        }
    });
    window.addEventListener('touchend', (e) => {
        // Signature box drag/resize end handlers also handle touchend.
        if (isDraggingPdf) isDraggingPdf = false; // Stop PDF pan
        if (pinchState.active && e.touches.length < 2) pinchState.active = false; // End pinch if not enough touches
    });


    // Initial setup
    window.addEventListener('load', adjustViewerHeightAndRender);
    window.addEventListener('resize', adjustViewerHeightAndRender);

  </script>
</body>
</html>
