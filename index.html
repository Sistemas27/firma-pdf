<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Firmar Documento PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #e9ecef;
      overflow: hidden; /* Evita el scroll en el body, el visor lo manejará */
    }

    header {
      background: #343a40;
      color: white;
      padding: 0.5rem;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative; /* Para z-index si fuera necesario */
      z-index: 1000; /* Asegura que el header esté sobre el visor */
    }

    header h2 {
        margin-top: 0.2rem;
        margin-bottom: 0.5rem;
        font-size: 1.15rem;
        font-weight: 500;
    }

    .navigation-toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 380px; /* Limita el ancho para mejor apariencia */
      margin: 0 auto 0.5rem auto; /* Centrado y espacio inferior */
    }

    #page-info {
      margin: 0 0.8rem;
      font-size: 0.8rem;
      white-space: nowrap;
      color: #adb5bd; /* Un color más suave para la información de página */
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap; /* Permite que los botones pasen a la siguiente línea si no caben */
      justify-content: center;
      align-items: center;
      gap: 0.3rem; /* Espacio pequeño entre botones */
      width: 100%;
    }

    .toolbar-btn {
      background: #007bff;
      border: none;
      padding: 0.45rem 0.8rem; /* Ajuste de padding */
      margin: 0.15rem; /* Margen pequeño */
      color: white;
      font-size: 0.8rem; /* Tamaño de fuente reducido para botones */
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
      flex-grow: 0; /* No crecer */
      flex-basis: auto; /* Basado en contenido */
    }
    .toolbar-btn:hover {
        background-color: #0056b3;
        box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25); /* Sombra de foco sutil */
    }
    .toolbar-btn.page-nav-btn {
        min-width: auto; /* Ancho automático */
        padding: 0.4rem 0.7rem; /* Padding específico para botones de página */
        background-color: #495057; /* Color diferente para navegación de página */
    }
    .toolbar-btn.page-nav-btn:hover {
        background-color: #343a40;
        box-shadow: 0 0 0 0.2rem rgba(108,117,125,.25);
    }


    #pdf-viewer {
      width: 100vw;
      /* height será ajustado por JS para ocupar el espacio restante */
      overflow: hidden; /* El canvas interno puede ser más grande */
      background: #f8f9fa; /* Un fondo ligeramente diferente al body */
      position: relative; /* Para posicionar el canvas y otros elementos internos */
      display: flex; /* Para centrar el canvas si es más pequeño que el visor */
      justify-content: center;
      align-items: center;
      touch-action: none; /* Previene acciones táctiles por defecto como scroll/zoom en el visor mismo */
    }

    .page-usage-counter {
        position: absolute;
        top: 8px; /* Espaciado desde la parte superior del visor */
        padding: 4px 8px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        font-size: 0.7rem; /* Pequeño para no ser intrusivo */
        border-radius: 0.2rem;
        z-index: 50; /* Sobre el canvas, debajo de modales */
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #current-page-visits {
        left: 8px;
    }
    #total-page-views {
        right: 8px;
    }


    #pdf-canvas {
      cursor: grab; /* Indica que se puede arrastrar */
      image-rendering: -webkit-optimize-contrast; /* Mejora la nitidez en Chrome/Safari */
      image-rendering: crisp-edges; /* Mejora la nitidez en Firefox */
      box-shadow: 0 0 10px rgba(0,0,0,0.1); /* Sombra sutil para dar profundidad */
    }

    #zoom-slider-container {
      position: fixed; /* Fijo en la pantalla */
      right: 8px; /* Pegado a la derecha */
      top: 50%; /* Centrado verticalmente */
      transform: translateY(-50%);
      background: rgba(52, 58, 64, 0.8); /* Fondo semitransparente */
      padding: 6px;
      border-radius: 0.25rem;
      z-index: 9999; /* Encima de casi todo */
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    #zoom-slider {
      writing-mode: bt-lr; /* IE */
      -webkit-appearance: slider-vertical; /* WebKit */
      width: 16px; /* Ancho del slider vertical */
      height: 100px; /* Altura del slider */
      transform: rotate(180deg); /* Para que el mínimo esté abajo */
    }

    /* Estilo para el input de archivo */
    input[type="file"]#file-input {
      padding: 0.4rem;
      border-radius: 0.25rem;
      border: 1px solid #ced4da;
      background-color: #fff;
      color: #495057;
      cursor: pointer;
      font-size: 0.75rem; /* Tamaño de fuente más pequeño */
      max-width: 240px; /* Evita que sea demasiado ancho */
      margin: 0.15rem; /* Margen consistente con otros botones */
    }
    input[type="file"]#file-input::file-selector-button { /* Estilo del botón interno del input file */
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.4rem 0.7rem;
        border-radius: 0.2rem;
        cursor: pointer;
        margin-right: 8px; /* Espacio entre el botón y el texto del archivo */
    }

    /* Estilos para el cuadro de firma interactivo */
    .signature-box {
      position: absolute;
      border: 1px solid #007bff; /* Borde azul distintivo */
      background-color: rgba(0, 123, 255, 0.08); /* Fondo azul muy sutil */
      cursor: move; /* Cursor por defecto cuando es arrastrable */
      z-index: 100; /* Encima del canvas PDF, debajo de modales */
      touch-action: none; /* Importante para el arrastre táctil */
      border-radius: 3px;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.35), 0 1px 4px rgba(0,0,0,0.15); /* Para mayor visibilidad */
    }
    .signature-box.position-confirmed {
        cursor: default; /* Cursor cuando la posición está bloqueada */
        border: 1px dashed #6c757d; /* Borde discontinuo gris */
        background-color: transparent; /* o rgba(0, 123, 255, 0.02) para un leve tinte */
        box-shadow: none; /* Sin sombra activa */
    }


    .signature-box-controls {
      position: absolute;
      top: -38px; /* Posicionado encima del cuadro */
      left: 50%;
      transform: translateX(-50%); /* Centrado horizontalmente */
      display: flex;
      gap: 8px; /* Espacio entre botones de control */
      padding: 5px;
      background-color: #fff; /* Fondo para los controles */
      border-radius: 0.25rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }

    .signature-box-btn {
      width: 30px; /* Botones circulares */
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px; /* Tamaño del ícono/emoji */
      border: none;
      color: white;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s ease;
    }
    .signature-box-btn:hover {
        transform: scale(1.1); /* Efecto de zoom al pasar el mouse */
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    .signature-box-btn.confirm { background-color: #28a745; } /* Verde */
    .signature-box-btn.cancel { background-color: #dc3545; } /* Rojo */
    .signature-box-btn.edit { background-color: #ffc107; color: #212529; } /* Amarillo, texto oscuro */
    .signature-box-btn.draw { background-color: #007bff; } /* Azul */


    .resize-handle {
      position: absolute;
      width: 12px; /* Mayor área táctil */
      height: 12px;
      background-color: #fff; /* Color de fondo del manejador */
      border: 2px solid #007bff; /* Borde para visibilidad */
      border-radius: 50%; /* Circular */
      z-index: 101; /* Encima del signature-box */
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

    /* Estilos para el modal de firma */
    .signature-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6); /* Overlay más oscuro */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000; /* Muy alto para estar sobre todo */
      padding: 10px; /* Espacio por si el modal es muy grande */
    }

    .signature-container {
      background-color: #ffffff; /* Fondo blanco */
      padding: 25px; /* Más padding */
      border-radius: 0.3rem; /* Radio de borde consistente */
      width: 100%;
      max-width: 550px; /* Ancho máximo para pantallas grandes */
      height: auto;
      max-height: 90vh; /* Asegura que quepa en la vista */
      display: flex;
      flex-direction: column;
      box-shadow: 0 0.5rem 1rem rgba(0,0,0,.15); /* Sombra más suave */
    }

    .signature-canvas-container {
      flex-grow: 1; /* Permite que el canvas tome el espacio disponible */
      border: 1px solid #ced4da; /* Borde estándar */
      margin-bottom: 20px; /* Espacio antes de los controles */
      position: relative; /* Para el canvas interno */
      min-height: 200px; /* Área mínima de dibujo */
      border-radius: 0.25rem; /* Bordes redondeados */
      overflow: hidden; /* Recorta el canvas si se desborda */
      background-color: #fff; /* Asegura fondo blanco si el canvas es transparente */
    }

    #signature-canvas {
      width: 100%;
      height: 100%;
      background-color: transparent; /* Deja que el CSS controle el fondo */
      cursor: crosshair;
      touch-action: none; /* Para dibujar en dispositivos táctiles */
    }

    .signature-controls {
      display: flex;
      justify-content: space-between; /* Distribuye los botones */
      flex-wrap: wrap; /* Envuelve los botones en pantallas pequeñas */
      gap: 10px; /* Espacio entre botones */
    }

    .signature-control-btn {
      padding: 0.6rem 1rem; /* Padding cómodo */
      border: none;
      border-radius: 0.25rem; /* Radio de borde consistente */
      cursor: pointer;
      font-size: 0.9rem;
      flex-grow: 1; /* Permite que los botones crezcan */
      min-width: 100px; /* Ancho mínimo para legibilidad */
      text-align: center;
      transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      font-weight: 500; /* Texto ligeramente más grueso */
    }
    .signature-control-btn:hover {
        transform: translateY(-2px); /* Efecto sutil de elevación */
        box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Sombra más suave al pasar el mouse */
    }
    .signature-control-btn.cancel { background-color: #dc3545; color: white; }
    .signature-control-btn.clear { background-color: #ffc107; color: #212529; } /* Texto más oscuro para amarillo */
    .signature-control-btn.confirm { background-color: #28a745; color: white; }


    /* Estilo para la imagen de firma ya incrustada en el PDF viewer */
    .embedded-signature {
      position: absolute;
      z-index: 99; /* Debajo del signature-box pero encima del canvas PDF */
      pointer-events: none; /* Permite que los clics pasen al PDF si es necesario */
      transform-origin: top left; /* Asegura que el escalado sea desde la esquina superior izquierda */
    }

    /* Estilos para el modal de mensajes genérico */
    .message-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 20000; /* Encima de todo, incluso el modal de firma */
        padding: 15px;
    }
    .message-modal-content {
        background-color: white;
        padding: 25px;
        border-radius: 0.3rem;
        text-align: center;
        box-shadow: 0 0.5rem 1rem rgba(0,0,0,.175);
        max-width: 400px; /* Limita el ancho del modal */
        width: 100%;
    }
    .message-modal-content p {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 1rem;
        color: #212529; /* Texto más oscuro para mejor legibilidad */
        white-space: pre-wrap; /* Para respetar saltos de línea \n */
    }
    .message-modal-content button, .message-modal-content input { /* Estilo común para botón e input en modal */
        background-color: #007bff;
        color: white;
        border: none;
        padding: 0.5rem 1.25rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.95rem;
        transition: background-color 0.2s ease;
        display: block; /* Ocupa todo el ancho */
        width: 100%;
        margin-top: 10px; /* Espacio si hay varios elementos */
    }
    .message-modal-content button:hover {
        background-color: #0056b3;
    }
    .message-modal-content input { /* Estilo específico para input si es necesario */
        background-color: #fff;
        color: #495057;
        border: 1px solid #ced4da;
        margin-bottom: 10px;
        text-align: left;
        cursor: text;
    }

    /* Estilo para el área de firma de Usuario B */
    .user-b-signature-area {
        position: absolute;
        border: 2px dashed #007bff;
        background-color: rgba(0, 123, 255, 0.08);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 98; /* Encima del PDF, debajo de otros controles si los hubiera */
    }
    .user-b-signature-area span {
        color:#007bff;
        font-size:0.9em;
        padding:5px;
    }

  </style>
</head>
<body>
  <header>
    <h2>Firmar Documento PDF</h2>
    <div class="navigation-toolbar">
      <button class="toolbar-btn page-nav-btn" onclick="prevPage()">⬅️ Anterior</button>
      <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
      <button class="toolbar-btn page-nav-btn" onclick="nextPage()">➡️ Siguiente</button>
    </div>
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" />
      <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
      <button class="toolbar-btn" onclick="downloadPDF()">📂 Guardar</button>
      <button class="toolbar-btn" id="share-pdf-btn" onclick="sharePDF()">📤 Compartir</button>
      <button class="toolbar-btn" id="check-signatures-btn" onclick="checkSignaturesStatus()" style="display: none;">🔍 Verificar Firmas</button>
    </div>
  </header>

  <div id="pdf-viewer">
    <canvas id="pdf-canvas"></canvas>
    <div id="current-page-visits" class="page-usage-counter" title="Visitas a esta página">P: 0</div>
    <div id="total-page-views" class="page-usage-counter" title="Total vistas de página">T: 0</div>
  </div>

  <div id="zoom-slider-container">
    <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
  </div>

  <script>
    // --- Configuración de Supabase ---
    const SUPABASE_URL = 'https://clkxkehypxmcqxcalmwn.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa3hrZWh5cHhtY3F4Y2FsbXduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzNzgxMjIsImV4cCI6MjA2Mzk1NDEyMn0.eINgBpLReFf_PJmdsM2SVSD9QmuGs4FJe6jcJkp9wCg';

    let supabaseClient = null;

    function showMessage(message, isUrl = false, urlToCopy = '') {
        const existingModal = document.querySelector('.message-modal');
        if (existingModal) existingModal.remove();
        const modal = document.createElement('div');
        modal.className = 'message-modal';
        const content = document.createElement('div');
        content.className = 'message-modal-content';
        let htmlContent = `<p>${message.replace(/\n/g, '<br>')}</p>`;
        if (isUrl && urlToCopy) {
            htmlContent += `<input type="text" value="${urlToCopy}" id="shareable-url-input" readonly style="width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">`;
            htmlContent += `<button id="copy-url-btn">Copiar URL</button>`;
        }
        htmlContent += `<button id="ok-message-btn" style="margin-top: ${isUrl && urlToCopy ? '5px' : '0'};">OK</button>`;
        content.innerHTML = htmlContent;
        modal.appendChild(content);
        document.body.appendChild(modal);
        content.querySelector('#ok-message-btn').onclick = () => modal.remove();
        if (isUrl && urlToCopy) {
            const copyBtn = content.querySelector('#copy-url-btn');
            const urlInput = content.querySelector('#shareable-url-input');
            copyBtn.onclick = () => {
                urlInput.select();
                urlInput.setSelectionRange(0, 99999);
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(urlToCopy).then(() => {
                            copyBtn.textContent = '¡Copiado!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        }).catch(err => { 
                            console.warn('navigator.clipboard.writeText falló, intentando execCommand:', err);
                            if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                            copyBtn.textContent = '¡Copiado (fallback)!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        });
                    } else { 
                        if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                         copyBtn.textContent = '¡Copiado (fallback)!';
                        setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                    }
                } catch (err) {
                    console.error('Error al copiar URL:', err);
                    showMessage('Error al copiar. Por favor, copia manualmente.');
                }
            };
        }
    }
   
    try {
        if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'TU_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'TU_SUPABASE_ANON_KEY') {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY); 
            console.info("Cliente de Supabase inicializado correctamente.");
        } else {
            const placeholderErrorMsg = "Configuración Incompleta: Supabase URL o Anon Key son incorrectas.\n\nLa función de compartir no funcionará.";
            console.warn(placeholderErrorMsg);
            if (typeof showMessage === 'function') { 
                showMessage(placeholderErrorMsg);
            }
            supabaseClient = null; 
        }
    } catch (error) {
        console.error("Error CRÍTICO inicializando Supabase:", error);
        let detail = (error && error.message) ? error.message : (typeof error === 'string' ? error : "Error desconocido.");
        const initErrorMsg = `Error CRÍTICO al inicializar Supabase:\n\n${detail}\n\nLa función de compartir no funcionará.`;
        if (typeof showMessage === 'function') { 
            showMessage(initErrorMsg);
        }
        supabaseClient = null;
    }

    let pdfDoc = null;
    let originalFileName = 'documento.pdf';
    let originalPdfFileBlob = null; 
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1;
    let canvas = document.getElementById('pdf-canvas');
    let context = canvas.getContext('2d');
    const pdfViewer = document.getElementById('pdf-viewer');
    let rendering = false;

    let isDraggingPdf = false;
    let startPos = { x: 0, y: 0 };
    let translatePos = { x: 0, y: 0 };
    let isZoomed = false;

    let embeddedSignatures = [];
    let signatureBoxEl = null; // Variable global para el cuadro de firma
    let activeSignatureBoxInfo = null; 
    let isDraggingSigBox = false;
    let isResizingSigBox = false;
    let signatureBoxDragOffset = { x: 0, y: 0 };
    let resizeHandleTypeSigBox = null;
    let startBoxPosSigBox = { x: 0, y: 0 };
    let startBoxSizeSigBox = { width: 0, height: 0 };
    let startPointerPosSigBox = { x: 0, y: 0 };

    let signatureModalEl = null;
    let signaturePadCanvasEl = null;
    let signaturePadCtxEl = null;
    let isDrawingOnPadEl = false;
    let lastDrawPadPosEl = { x: 0, y: 0 };

    let pinchState = {
        active: false, initialDistance: 0, lastScale: 1,
        pdfPointX: 0, pdfPointY: 0,
        screenCenterX: 0, screenCenterY: 0
    };

    let pageVisitCounts = {};
    let totalPageViewsSession = 0;

    let sharedDocIdForUserA = null;
    let markerDataForUserB = null;


    document.getElementById('file-input').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'application/pdf') {
        originalFileName = file.name;
        originalPdfFileBlob = file; 
       
        sharedDocIdForUserA = null;
        const checkBtn = document.getElementById('check-signatures-btn');
        if (checkBtn) checkBtn.style.display = 'none';
        markerDataForUserB = null; 
        const userBArea = document.getElementById('user-b-sig-area');
        if(userBArea) userBArea.remove();

        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            }
            const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;
            currentPage = 1;
            translatePos = { x: 0, y: 0 }; 
            scale = 1; 
            document.getElementById('zoom-slider').value = scale;
            document.getElementById('total-pages').textContent = totalPages;
            document.getElementById('current-page').textContent = currentPage;
           
            embeddedSignatures = [];
            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
            if (signatureBoxEl) {
                console.log("[file-input] Removing existing signatureBoxEl due to new file load.");
                signatureBoxEl.remove();
                signatureBoxEl = null; 
            }
            activeSignatureBoxInfo = null; 
            pageVisitCounts = {};
            totalPageViewsSession = 0;
            updatePageUsageCounters(); 
            renderPage(currentPage);
          } catch (err) {
            showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
            console.error("Error loading PDF:", err);
            pdfDoc = null; 
            originalPdfFileBlob = null;
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file) {
        showMessage('Por favor, selecciona un archivo PDF.');
        originalPdfFileBlob = null;
      }
        this.value = null; 
    });

    function updatePageUsageCounters() {
        if (!pdfDoc) return;
        pageVisitCounts[currentPage] = (pageVisitCounts[currentPage] || 0) + 1;
        totalPageViewsSession++;
        document.getElementById('current-page-visits').textContent = `P${currentPage}: ${pageVisitCounts[currentPage]}`;
        document.getElementById('total-page-views').textContent = `T: ${totalPageViewsSession}`;
    }

    async function renderPage(num) { 
        if (!pdfDoc || rendering) return;
        rendering = true;
       
        const userBArea = document.getElementById('user-b-sig-area');
        if(userBArea) userBArea.style.display = 'none'; 

        updatePageUsageCounters(); 
       
        try {
            const page = await pdfDoc.getPage(num);
            const dpr = window.devicePixelRatio || 1; 
            const viewportForRender = page.getViewport({ scale: scale * dpr }); 
            canvas.width = viewportForRender.width;
            canvas.height = viewportForRender.height;
           
            const viewportCss = page.getViewport({ scale: scale });
            canvas.style.width = `${viewportCss.width}px`;
            canvas.style.height = `${viewportCss.height}px`;
           
            const viewerWidth = pdfViewer.clientWidth;
            const viewerHeight = pdfViewer.clientHeight;
            const cssCanvasWidth = viewportCss.width;
            const cssCanvasHeight = viewportCss.height;

            canvas.style.left = (cssCanvasWidth < viewerWidth) ? `${(viewerWidth - cssCanvasWidth) / 2}px` : '0px';
            canvas.style.top = (cssCanvasHeight < viewerHeight) ? `${(viewerHeight - cssCanvasHeight) / 2}px` : '0px';
            canvas.style.position = 'absolute'; 
           
            const renderContext = { canvasContext: context, viewport: viewportForRender };
            await page.render(renderContext).promise;

            rendering = false;
            document.getElementById('current-page').textContent = num;
            isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
            updateCanvasTransform(); 

        } catch (err) {
            rendering = false; 
            console.error("Error en renderPage:", err); 
            showMessage("Error al renderizar la página del PDF.");
        }
    }

    function updateCanvasTransform() {
        canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
        repositionSignatures(); 
        repositionActiveSignatureBox(); 
        if (markerDataForUserB && markerDataForUserB.page === currentPage && pdfDoc && !rendering) { 
            displayMarkerForUserB(markerDataForUserB);
        }
    }
   
    canvas.addEventListener('mousedown', (e) => {
        if (isDraggingSigBox || isResizingSigBox || pinchState.active) return; 
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);
        if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
        if (e.target !== canvas && e.target !== pdfViewer) return; 
        isDraggingPdf = true;
        startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
        canvas.style.cursor = 'grabbing';
    });

    pdfViewer.addEventListener('touchstart', (e) => {
        if (signatureBoxEl && (e.target === signatureBoxEl || signatureBoxEl.contains(e.target))) {
            return;
        }
         const userBArea = document.getElementById('user-b-sig-area');
        if (userBArea && (e.target === userBArea || userBArea.contains(e.target))) {
            return; 
        }

        if (isDraggingSigBox || isResizingSigBox) return; 
        if (e.touches.length === 2) { 
            e.preventDefault(); 
            isDraggingPdf = false; 
            pinchState.active = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            pinchState.lastScale = scale; 
            const viewerRect = pdfViewer.getBoundingClientRect();
            pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
            pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
           
            const canvasRect = canvas.getBoundingClientRect();
            const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
            const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;
           
            pinchState.pdfPointX = pdfPointScreenX / scale; 
            pinchState.pdfPointY = pdfPointScreenY / scale;

        } else if (e.touches.length === 1 && !pinchState.active) { 
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            if ((cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight && scale === 1) || (e.target !== canvas && e.target !== pdfViewer)) {
                 isDraggingPdf = false; return;
            }
            isDraggingPdf = true;
            const touch = e.touches[0];
            startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
        }
    }, { passive: false }); 

    function handlePdfMove(clientX, clientY) {
        if (!isDraggingPdf) return;
        let newTranslateX = clientX - startPos.x;
        let newTranslateY = clientY - startPos.y;
        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);
        const overpanMargin = 30; 
       
        if (cssCanvasWidth > viewerWidth) {
            const minX = viewerWidth - cssCanvasWidth - overpanMargin; 
            const maxX = overpanMargin; 
            newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
        } else {
            newTranslateX = (viewerWidth - cssCanvasWidth) / 2; 
        }

        if (cssCanvasHeight > viewerHeight) {
            const minY = viewerHeight - cssCanvasHeight - overpanMargin; 
            const maxY = overpanMargin; 
            newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
        } else {
            newTranslateY = (viewerHeight - cssCanvasHeight) / 2; 
        }
        translatePos.x = newTranslateX;
        translatePos.y = newTranslateY;
        updateCanvasTransform();
    }

    async function handlePinchMove(touch1, touch2) { 
        if (!pinchState.active || pinchState.initialDistance === 0 || !pdfDoc) return;
        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
        newScale = Math.min(3.0, Math.max(0.5, parseFloat(newScale.toFixed(2)))); 
       
        if (Math.abs(newScale - scale) < 0.01 && newScale !== 0.5 && newScale !== 3.0) return; 
       
        const oldScale = scale;
        scale = newScale;
       
        const viewerRect = pdfViewer.getBoundingClientRect(); 
        let baseCanvasX = 0;
        let baseCanvasY = 0;
       
        try {
            const page = await pdfDoc.getPage(currentPage);
            const viewportCss = page.getViewport({scale: scale});
            if (viewportCss.width < viewerRect.width) {
                baseCanvasX = (viewerRect.width - viewportCss.width) / 2;
            }
            if (viewportCss.height < viewerRect.height) {
                baseCanvasY = (viewerRect.height - viewportCss.height) / 2;
            }
           
            translatePos.x = (pinchState.screenCenterX - viewerRect.left - baseCanvasX) - (pinchState.pdfPointX * scale);
            translatePos.y = (pinchState.screenCenterY - viewerRect.top - baseCanvasY) - (pinchState.pdfPointY * scale);
           
            document.getElementById('zoom-slider').value = scale.toFixed(1);
            await renderPage(currentPage); 
        } catch(err) {
            console.error("Error en handlePinchMove al obtener página:", err);
            scale = oldScale; 
        }
    }

    function nextPage() {
      if (!pdfDoc || currentPage >= totalPages) return;
      currentPage++;
      translatePos = { x: 0, y: 0 }; 
      renderPage(currentPage);
    }

    function prevPage() {
      if (!pdfDoc || currentPage <= 1) return;
      currentPage--;
      translatePos = { x: 0, y: 0 }; 
      renderPage(currentPage);
    }

    document.getElementById('zoom-slider').addEventListener('input', async function () {
        if (!pdfDoc) return;
        const oldScale = scale;
        scale = parseFloat(this.value);
       
        const viewerRect = pdfViewer.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect(); 
       
        const screenCenterX = viewerRect.left + viewerRect.width / 2;
        const screenCenterY = viewerRect.top + viewerRect.height / 2;
       
        const pdfPointX = (screenCenterX - canvasRect.left) / oldScale;
        const pdfPointY = (screenCenterY - canvasRect.top) / oldScale;
       
        const page = await pdfDoc.getPage(currentPage);
        const newViewportCss = page.getViewport({scale: scale}); 
       
        let expectedCanvasOffsetLeft = 0;
        if (newViewportCss.width < viewerRect.width) {
            expectedCanvasOffsetLeft = (viewerRect.width - newViewportCss.width) / 2;
        }
        let expectedCanvasOffsetTop = 0;
        if (newViewportCss.height < viewerRect.height) {
            expectedCanvasOffsetTop = (viewerRect.height - newViewportCss.height) / 2;
        }
       
        translatePos.x = (screenCenterX - viewerRect.left - expectedCanvasOffsetLeft) - (pdfPointX * scale);
        translatePos.y = (screenCenterY - viewerRect.top - expectedCanvasOffsetTop) - (pdfPointY * scale);
       
        await renderPage(currentPage); 
        pinchState.lastScale = scale; 
    });

    pdfViewer.addEventListener('wheel', async function (e) {
        if (!pdfDoc) return;
        e.preventDefault(); 
        const oldScale = scale;
        const delta = e.deltaY > 0 ? -0.1 : 0.1; 
        let newScale = parseFloat((scale + delta).toFixed(2));
        newScale = Math.min(3.0, Math.max(0.5, newScale)); 
       
        if (Math.abs(newScale - oldScale) < 0.01 && newScale !==0.5 && newScale !== 3.0) return; 
       
        const viewerRect = pdfViewer.getBoundingClientRect();
        const mouseXViewer = e.clientX - viewerRect.left; 
        const mouseYViewer = e.clientY - viewerRect.top; 
       
        const canvasRect = canvas.getBoundingClientRect(); 
        const mouseXOnCanvas = e.clientX - canvasRect.left; 
        const mouseYOnCanvas = e.clientY - canvasRect.top; 
       
        const pdfPointX = mouseXOnCanvas / oldScale;
        const pdfPointY = mouseYOnCanvas / oldScale;
       
        scale = newScale; 
       
        const page = await pdfDoc.getPage(currentPage);
        const newViewportCss = page.getViewport({ scale: scale }); 
       
        let expectedCanvasLeft = 0;
        if (newViewportCss.width < viewerRect.width) {
            expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
        }
        let expectedCanvasTop = 0;
        if (newViewportCss.height < viewerRect.height) {
            expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
        }
       
        translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
        translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
       
        document.getElementById('zoom-slider').value = scale.toFixed(1);
        await renderPage(currentPage); 
    }, { passive: false }); 

    async function getProcessedPdfBlob() {
        if (!pdfDoc) {
            showMessage("Carga un PDF primero.");
            return null;
        }
        const { jsPDF } = window.jspdf; 
        const newPdfDocGen = new jsPDF(); 
        while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }
       
        for (let i = 1; i <= totalPages; i++) {
            const page = await pdfDoc.getPage(i);
            const downloadScale = 2.0; 
            const viewport = page.getViewport({ scale: downloadScale });
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;
           
            await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
           
            const signaturesForPage = embeddedSignatures.filter(sig => sig.page === i);
            for (const sigInfo of signaturesForPage) {
                const img = new Image();
                try {
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = (errEvent) => {
                            console.error("Error cargando imagen de firma para PDF:", sigInfo.dataURL, errEvent);
                            const syntheticError = new Error("Fallo al cargar imagen de firma: " + sigInfo.dataURL.substring(0,50) + "...");
                            syntheticError.event = errEvent;
                            reject(syntheticError);
                        };
                        img.src = sigInfo.dataURL;
                    });
                    const x = sigInfo.x * downloadScale;
                    const y = sigInfo.y * downloadScale;
                    const width = sigInfo.width * downloadScale;
                    const height = sigInfo.height * downloadScale;
                    tempCtx.drawImage(img, x, y, width, height);
                } catch (imgLoadError) {
                    console.error("Saltando firma debido a error de carga:", imgLoadError);
                }
            }
           
            const imgData = tempCanvas.toDataURL('image/jpeg', 0.9); 
            newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
            newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
        }
        return newPdfDocGen.output('blob');
    }

    async function downloadPDF() {
        showMessage("Preparando PDF para descarga...");
        const pdfBlob = await getProcessedPdfBlob();
        if (pdfBlob) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(pdfBlob);
            link.download = originalFileName.replace(/\.pdf$/i, '-firmado.pdf') || 'documento-firmado.pdf';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href); 
            showMessage("PDF guardado.");
        } else {
            if(pdfDoc) showMessage("No se pudo generar el PDF para descargar.");
        }
    }

    async function sharePDF() {
        console.log('[sharePDF] INICIO. Estado de signatureBoxEl:', signatureBoxEl, '- Tipo:', typeof signatureBoxEl, '- activeSignatureBoxInfo:', activeSignatureBoxInfo);
        if (signatureBoxEl && typeof signatureBoxEl.classList !== 'undefined') {
            console.log('[sharePDF] signatureBoxEl.classList:', signatureBoxEl.classList);
            console.log('[sharePDF] ¿Está signatureBoxEl en el DOM?:', document.body.contains(signatureBoxEl));
        } else if (signatureBoxEl) {
            console.warn('[sharePDF] signatureBoxEl existe pero no tiene classList. Es:', signatureBoxEl);
        }

        if (!pdfDoc) {
            showMessage("Carga un PDF primero para compartir.");
            return;
        }
        if (!supabaseClient) {
            showMessage("Fallo en Supabase: La función de compartir no está disponible.");
            return;
        }
        if (!originalPdfFileBlob) {
            showMessage("El archivo PDF original no está disponible. Por favor, recarga el PDF.");
            return;
        }

        let markerToShare = null;

        // FLUJO PRINCIPAL: Compartir el cuadro "estático" (confirmado)
        if (signatureBoxEl && signatureBoxEl.classList.contains('position-confirmed') && activeSignatureBoxInfo && activeSignatureBoxInfo.element === signatureBoxEl) {
            console.log("[sharePDF] Usando CUADRO CONFIRMADO (estático) y activeSignatureBoxInfo.");
            
            if (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages) {
                console.error("[sharePDF] La página del cuadro de firma confirmado (" + activeSignatureBoxInfo.page + ") es inválida.");
                showMessage("Error: La página registrada para el cuadro de firma confirmado es inválida. Intente editar y confirmar de nuevo el cuadro en una página válida.");
                return; // markerToShare seguirá null
            }
            markerToShare = {
                page: activeSignatureBoxInfo.page,
                x_coord: activeSignatureBoxInfo.x, // Ya están escaladas a PDF original
                y_coord: activeSignatureBoxInfo.y,
                width_val: activeSignatureBoxInfo.width,
                height_val: activeSignatureBoxInfo.height,
                status: 'pending_user_b_signature'
            };
            console.log("[sharePDF] CORRECTO - markerToShare definido desde cuadro CONFIRMADO (estático):", markerToShare);
        
        } 
        // Fallback opcional: si se quisiera compartir el azul (NO es el flujo deseado ahora)
        /* else if (signatureBoxEl && typeof signatureBoxEl.getBoundingClientRect === 'function' && !signatureBoxEl.classList.contains('position-confirmed')) {
            console.log("[sharePDF] Usando CUADRO AZUL (no confirmado). ESTO ES UN FALLBACK, NO EL FLUJO PRINCIPAL DESEADO.");
            const canvasRect = canvas.getBoundingClientRect();
            if (canvasRect.width === 0 || canvasRect.height === 0 || currentPage < 1 || currentPage > totalPages ) {
                showMessage("El PDF no está completamente cargado o el cuadro de firma no está sobre una página válida.");
                return; 
            }
            const boxRect = signatureBoxEl.getBoundingClientRect();
            const boxRelToCanvasX = boxRect.left - canvasRect.left;
            const boxRelToCanvasY = boxRect.top - canvasRect.top;
            markerToShare = {
                page: currentPage,
                x_coord: boxRelToCanvasX / scale,
                y_coord: boxRelToCanvasY / scale,
                width_val: boxRect.width / scale,
                height_val: boxRect.height / scale,
                status: 'pending_user_b_signature'
            };
        } */
        else {
            // Si no se cumplió la condición principal (cuadro confirmado)
            console.warn("[sharePDF] No se cumplió la condición para compartir el cuadro confirmado.");
            if (!signatureBoxEl) console.warn("  - signatureBoxEl es null.");
            else if (!signatureBoxEl.classList.contains('position-confirmed')) console.warn("  - signatureBoxEl existe pero NO está confirmado (es azul).");
            else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) console.warn("  - signatureBoxEl está confirmado, pero activeSignatureBoxInfo es inválido o no coincide.");
        }


        if (!markerToShare) {
            let reason = "No se encontró un cuadro de firma confirmado (estático) para compartir."; 
            
            if (!signatureBoxEl) {
                reason = "No hay ningún cuadro de firma en la página.";
            } else if (!signatureBoxEl.classList.contains('position-confirmed')) {
                reason = "El cuadro de firma actual es azul (editable). Primero debe confirmarlo (con ✔️) para que se vuelva estático y pueda ser compartido.";
            } else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) {
                // Esto puede pasar si signatureBoxEl es el confirmado, pero activeSignatureBoxInfo se perdió o es de otro elemento.
                reason = "El cuadro de firma está confirmado, pero hay una inconsistencia con sus datos internos. Intente editarlo (✏️) y confirmarlo (✔️) de nuevo.";
            } else { 
                 // Si activeSignatureBoxInfo existe y coincide con signatureBoxEl (confirmado), pero markerToShare es null
                 // esto podría ser por la validación de página en la lógica de arriba.
                if (activeSignatureBoxInfo && (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages)) {
                     reason = "La página registrada para el cuadro de firma confirmado es inválida.";
                } else {
                    reason = "No se pudo preparar el cuadro de firma confirmado para compartir por una razón desconocida.";
                }
            }
           
            console.error("SharePDF: FALLO AL PREPARAR MARCADOR. Razón: " + reason, 
                          "signatureBoxEl:", signatureBoxEl, 
                          "activeSignatureBoxInfo:", activeSignatureBoxInfo);
           
            showMessage("Para compartir con Usuario B:\n1. Usa '✍️ Añadir Firma' (aparece cuadro azul).\n2. Posiciona y dimensiona el cuadro azul.\n3. Haz clic en ✔️ sobre el cuadro azul para confirmarlo (se volverá de borde discontinuo).\n4. SOLO ENTONCES, presiona '📤 Compartir'.\n\n" +
                        "AYUDA: El cuadro que se comparte es el de borde discontinuo (estático). Si solo ves el cuadro azul, primero confírmalo.\n\n" +
                        "(Diagnóstico: " + reason.split('(')[0].trim() + ")");
            return;
        }
       
        // Si llegamos aquí, markerToShare está definido y listo para Supabase.
        showMessage("Preparando documento para compartir...");
        const documentId = `doc_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        sharedDocIdForUserA = documentId;
        const sanitizedFileName = originalFileName.replace(/[^a-zA-Z0-9._-]/g, '_');
        const originalPdfStoragePath = `documents/${documentId}/${sanitizedFileName}`;

        try {
            const { data: uploadData, error: uploadError } = await supabaseClient.storage
                .from('pdfs')
                .upload(originalPdfStoragePath, originalPdfFileBlob, {
                    cacheControl: '3600',
                    upsert: false
                });
            if (uploadError) throw new Error(`Error al subir PDF original: ${uploadError.message}`);
            console.log("PDF original subido, path:", uploadData.path);

            const markerForDb = {
                doc_id: documentId,
                marker_id: `marker_userb_${Date.now()}`,
                pdf_storage_path: uploadData.path, 
                ...markerToShare
            };
            const { error: markersError } = await supabaseClient
                .from('signature_markers')
                .insert([markerForDb]);
            if (markersError) throw new Error(`Error al guardar marcador: ${markersError.message}`);
            console.log("Información del marcador para Usuario B guardada.");

            const shareUrl = `${window.location.origin}${window.location.pathname}?doc_id=${documentId}&mode=sign_for_user_b`;
            showMessage(`Documento listo para Usuario B.\nComparte esta URL:\nID Documento: ${documentId}`, true, shareUrl);
           
            const checkBtn = document.getElementById('check-signatures-btn');
            if (checkBtn) checkBtn.style.display = 'inline-block';

        } catch (error) {
            console.error("Excepción detallada en sharePDF (operaciones Supabase):", error);
            let userMessage = `Error al compartir: ${error.message || "Error desconocido."}\n\n`;
            if (error.message && error.message.includes("signature_markers")) {
                userMessage += "Verifica la tabla 'signature_markers' y sus políticas RLS en Supabase.\n";
            } else if (error.message && (error.message.includes("bucket") || error.message.includes("Storage"))) {
                userMessage += "Verifica el bucket 'pdfs' en Supabase Storage y sus políticas de acceso.\n";
            }
            showMessage(userMessage);
        }
    }

    function addSignatureBox() {
      console.log('[addSignatureBox] Llamada. Estado actual de signatureBoxEl:', signatureBoxEl);
      if (!pdfDoc) {
        showMessage("Por favor, carga un documento PDF primero.");
        return;
      }
      if (signatureBoxEl) { 
        console.log('[addSignatureBox] Hay un signatureBoxEl existente, se removerá.');
        try {
            signatureBoxEl.remove();
        } catch(e) {
            console.warn('[addSignatureBox] Error al remover signatureBoxEl existente del DOM:', e);
        }
      }
      signatureBoxEl = null; 
      activeSignatureBoxInfo = null; 

      try {
          signatureBoxEl = document.createElement('div'); 
          signatureBoxEl.className = 'signature-box';
          signatureBoxEl.style.width = '150px'; 
          signatureBoxEl.style.height = '75px';
          
          const viewerRect = pdfViewer.getBoundingClientRect();
          if (!pdfViewer || (viewerRect.width === 0 && viewerRect.height === 0 && !pdfViewer.offsetParent)) { 
              console.error("[addSignatureBox] pdfViewer no está disponible, no tiene dimensiones o no está visible.");
              showMessage("Error: El visor de PDF no está listo para añadir una firma.");
              signatureBoxEl = null; 
              return;
          }
          signatureBoxEl.style.left = `${Math.max(0, (viewerRect.width - 150) / 2)}px`; 
          signatureBoxEl.style.top = `${Math.max(0, (viewerRect.height - 75) / 2)}px`;
          
          pdfViewer.appendChild(signatureBoxEl); 
          console.log('[addSignatureBox] Nuevo signatureBoxEl creado y añadido al DOM. Referencia actual:', signatureBoxEl);

          makeSignatureBoxEditable(signatureBoxEl); 
          console.log('[addSignatureBox] makeSignatureBoxEditable llamado. signatureBoxEl debería ser el nuevo cuadro.');
      } catch (error) {
          console.error('[addSignatureBox] ERROR CRÍTICO durante la creación/configuración del cuadro:', error);
          showMessage('Se produjo un error crítico al intentar añadir el cuadro de firma. Revise la consola.');
          if (signatureBoxEl && signatureBoxEl.parentElement) {
              signatureBoxEl.remove(); 
          }
          signatureBoxEl = null; 
      }
    }
   
    function repositionActiveSignatureBox() {
        // Esta función reposiciona el activeSignatureBoxInfo.element, que es el cuadro confirmado.
        if (!activeSignatureBoxInfo || !activeSignatureBoxInfo.element || !pdfViewer || !canvas || !pdfDoc) {
            // Si no hay un activeSignatureBoxInfo, pero sí un signatureBoxEl azul, reposicionarlo.
             if (signatureBoxEl && !signatureBoxEl.classList.contains('position-confirmed') && pdfViewer && canvas && pdfDoc) {
                const boxElToReposition = signatureBoxEl;
                const canvasRect = canvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                // Calcular posición relativa al viewer, no al canvas, ya que es un cuadro "flotante"
                // Esta parte necesita revisión si el cuadro azul se va a mantener estrictamente sobre el canvas.
                // Por ahora, lo dejamos como estaba para el azul.
                // La lógica original de posicionamiento del azul era en addSignatureBox y al arrastrarlo.
                // Este es un punto a considerar: el azul no se reposicionaba con el zoom/pan del PDF de forma automática.
             }
            return;
        }
        const sig = activeSignatureBoxInfo;
        const boxEl = sig.element; // Este es el cuadro confirmado (antes signatureBoxEl)
        if (sig.page === currentPage) {
            const canvasRect = canvas.getBoundingClientRect(); 
            const viewerRect = pdfViewer.getBoundingClientRect();
            // Las coords sig.x, sig.y son relativas al PDF original (scale 1)
            const displayX = (sig.x * scale) + (canvasRect.left - viewerRect.left);
            const displayY = (sig.y * scale) + (canvasRect.top - viewerRect.top);
            const displayWidth = sig.width * scale;
            const displayHeight = sig.height * scale;
           
            boxEl.style.left = `${displayX}px`;
            boxEl.style.top = `${displayY}px`;
            boxEl.style.width = `${displayWidth}px`;
            boxEl.style.height = `${displayHeight}px`;
            boxEl.style.display = 'block';
        } else {
            boxEl.style.display = 'none';
        }
    }

    function confirmSignatureBoxPlacement(boxEl) { // boxEl es el signatureBoxEl azul
        console.log('[confirmSignatureBoxPlacement] Confirmando. El cuadro azul es:', boxEl);
        if (!boxEl || !pdfDoc) return; 
        const handles = boxEl.querySelectorAll('.resize-handle');
        handles.forEach(h => h.remove());
        boxEl.classList.add('position-confirmed'); 
       
        const canvasRect = canvas.getBoundingClientRect();
        const boxRect = boxEl.getBoundingClientRect(); // Coords del cuadro azul en pantalla
        
        // Convertir coords de pantalla del cuadro azul a coords relativas al PDF (scale 1)
        const boxRelToCanvasX = (boxRect.left - canvasRect.left) / scale; 
        const boxRelToCanvasY = (boxRect.top - canvasRect.top) / scale;
        const pdfWidth = boxRect.width / scale;
        const pdfHeight = boxRect.height / scale;
       
        activeSignatureBoxInfo = { 
            element: boxEl, // boxEl (antes el signatureBoxEl azul) es ahora el cuadro confirmado (estático)
            page: currentPage,
            x: boxRelToCanvasX, 
            y: boxRelToCanvasY, 
            width: pdfWidth,  
            height: pdfHeight  
        };
        // signatureBoxEl sigue siendo boxEl, ahora con clase 'position-confirmed'. Es el cuadro estático.
        console.log('[confirmSignatureBoxPlacement] activeSignatureBoxInfo establecido:', activeSignatureBoxInfo);
        console.log('[confirmSignatureBoxPlacement] signatureBoxEl (ahora es el cuadro confirmado/estático) es:', signatureBoxEl);

        repositionActiveSignatureBox(); // Reposiciona el cuadro ahora confirmado usando sus nuevas coords PDF
       
        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) { 
            controls = document.createElement('div');
            controls.className = 'signature-box-controls';
            boxEl.appendChild(controls);
        }
        controls.innerHTML = ''; 
       
        const drawBtn = document.createElement('button');
        drawBtn.className = 'signature-box-btn draw';
        drawBtn.innerHTML = '✍️'; 
        drawBtn.title = 'Dibujar Firma';
        drawBtn.onclick = (e) => { e.stopPropagation(); openSignatureModal(); };
       
        const editPosBtn = document.createElement('button');
        editPosBtn.className = 'signature-box-btn edit';
        editPosBtn.innerHTML = '✏️'; 
        editPosBtn.title = 'Editar Posición';
        editPosBtn.onclick = (e) => { e.stopPropagation(); makeSignatureBoxEditable(boxEl); }; 
       
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = '❌'; 
        cancelBtn.title = 'Cancelar/Eliminar esta área de firma';
        cancelBtn.onclick = (e) => { 
            e.stopPropagation(); 
            console.log('[confirmSignatureBoxPlacement > cancelBtn] Removiendo cuadro confirmado y anulando signatureBoxEl.');
            boxEl.remove(); 
            signatureBoxEl = null; 
            activeSignatureBoxInfo = null; 
        };
        controls.appendChild(drawBtn);
        controls.appendChild(editPosBtn);
        controls.appendChild(cancelBtn);
    }

    function makeSignatureBoxEditable(boxEl) { 
        console.log('[makeSignatureBoxEditable] Haciendo editable. El cuadro es:', boxEl);
        if (!boxEl) {
            console.warn('[makeSignatureBoxEditable] boxEl es null, no se puede hacer editable.');
            return;
        }
        // Cuando se edita un cuadro confirmado, activeSignatureBoxInfo se anula porque sus datos ya no son válidos
        // hasta que se reconfirme. El cuadro vuelve a ser el "azul".
        activeSignatureBoxInfo = null; 
        boxEl.classList.remove('position-confirmed'); 
        boxEl.style.cursor = 'move'; 
        boxEl.querySelectorAll('.resize-handle').forEach(h => h.remove()); 
        addResizeHandlesToSigBox(boxEl); 
       
        // signatureBoxEl es boxEl, que ahora es azul y editable.
        console.log('[makeSignatureBoxEditable] signatureBoxEl (ahora azul) es:', signatureBoxEl);

        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) {
            controls = document.createElement('div');
            controls.className = 'signature-box-controls';
            boxEl.appendChild(controls);
        }
        controls.innerHTML = ''; 
       
        const confirmPlacementBtn = document.createElement('button');
        confirmPlacementBtn.className = 'signature-box-btn confirm';
        confirmPlacementBtn.innerHTML = '✔️'; 
        confirmPlacementBtn.title = 'Confirmar Posición';
        confirmPlacementBtn.onclick = (e) => { e.stopPropagation(); confirmSignatureBoxPlacement(boxEl); };
       
        const cancelBtn = document.createElement('button'); 
        cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = '🗑️'; 
        cancelBtn.title = 'Eliminar este cuadro azul';
        cancelBtn.onclick = (e) => { 
            e.stopPropagation(); 
            console.log('[makeSignatureBoxEditable > cancelBtn] Removiendo cuadro azul y anulando signatureBoxEl.');
            boxEl.remove(); 
            signatureBoxEl = null; 
            activeSignatureBoxInfo = null; // Ya era null, pero por si acaso.
        };
        controls.appendChild(confirmPlacementBtn);
        controls.appendChild(cancelBtn);
        setupSigBoxDragEvents(boxEl); 
        console.log('[makeSignatureBoxEditable] Terminado. signatureBoxEl (debería ser azul y editable):', signatureBoxEl);
    }

    // ... (resto de las funciones sin cambios relevantes para esta lógica específica)
    // _onSigBoxDragMove, _onSigBoxDragEnd, _onSigBoxResizeMove, _onSigBoxResizeEnd
    // addResizeHandlesToSigBox, initSigBoxResize, handleSigBoxResizeMove
    // setupSigBoxDragEvents, handleSigBoxDragMove
    // openSignatureModal, setupSignaturePadDrawingEventsEl, embedSignature
    // repositionSignatures, adjustViewerHeightAndRender
    // displayMarkerForUserB, openSignatureModalForUserB, saveUserBSignatureToSupabase, checkSignaturesStatus
    // listeners de mouse/touch y load/resize

    const _onSigBoxDragMove = (e) => { 
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        handleSigBoxDragMove(clientX, clientY);
    };
    const _onSigBoxDragEnd = () => { 
        isDraggingSigBox = false;
        window.removeEventListener('mousemove', _onSigBoxDragMove);
        window.removeEventListener('touchmove', _onSigBoxDragMove);
        window.removeEventListener('mouseup', _onSigBoxDragEnd);
        window.removeEventListener('touchend', _onSigBoxDragEnd);
    };
    const _onSigBoxResizeMove = (e) => { 
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        handleSigBoxResizeMove(clientX, clientY);
    };
    const _onSigBoxResizeEnd = () => { 
        isResizingSigBox = false;
        resizeHandleTypeSigBox = null;
        window.removeEventListener('mousemove', _onSigBoxResizeMove);
        window.removeEventListener('touchmove', _onSigBoxResizeMove);
        window.removeEventListener('mouseup', _onSigBoxResizeEnd);
        window.removeEventListener('touchend', _onSigBoxResizeEnd);
    };

    function addResizeHandlesToSigBox(box) {
      const handles = ['nw', 'ne', 'sw', 'se']; 
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        box.appendChild(handle);
        handle.addEventListener('mousedown', (e) => {
          e.stopImmediatePropagation(); 
          initSigBoxResize(e.clientX, e.clientY, pos, box);
        });
        handle.addEventListener('touchstart', (e) => {
          e.stopImmediatePropagation();
          if (e.touches.length === 1) {
            e.preventDefault(); 
            initSigBoxResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
          }
        }, { passive: false });
      });
    }

    function initSigBoxResize(clientX, clientY, handlePos, box) {
        if (box.classList.contains('position-confirmed')) return; 
        isResizingSigBox = true;
        resizeHandleTypeSigBox = handlePos;
        startBoxPosSigBox = { x: box.offsetLeft, y: box.offsetTop };
        startBoxSizeSigBox = { width: box.offsetWidth, height: box.offsetHeight };
        startPointerPosSigBox = { x: clientX, y: clientY };
        isDraggingPdf = false;
        isDraggingSigBox = false;
        pinchState.active = false;
        window.addEventListener('mousemove', _onSigBoxResizeMove);
        window.addEventListener('touchmove', _onSigBoxResizeMove, { passive: false });
        window.addEventListener('mouseup', _onSigBoxResizeEnd);
        window.addEventListener('touchend', _onSigBoxResizeEnd);
    }

    function handleSigBoxResizeMove(clientX, clientY) {
        if (!isResizingSigBox || !resizeHandleTypeSigBox || !signatureBoxEl) return;
        const deltaX = clientX - startPointerPosSigBox.x;
        const deltaY = clientY - startPointerPosSigBox.y;
        let newWidth = startBoxSizeSigBox.width;
        let newHeight = startBoxSizeSigBox.height;
        let newLeft = startBoxPosSigBox.x;
        let newTop = startBoxPosSigBox.y;
        const minWidth = 50; 
        const minHeight = 30; 
        const viewerRect = pdfViewer.getBoundingClientRect();
        if (resizeHandleTypeSigBox.includes('w')) { 
            newWidth = Math.max(minWidth, startBoxSizeSigBox.width - deltaX);
            newLeft = startBoxPosSigBox.x + (startBoxSizeSigBox.width - newWidth);
        }
        if (resizeHandleTypeSigBox.includes('e')) { 
            newWidth = Math.max(minWidth, startBoxSizeSigBox.width + deltaX);
        }
        if (resizeHandleTypeSigBox.includes('n')) { 
            newHeight = Math.max(minHeight, startBoxSizeSigBox.height - deltaY);
            newTop = startBoxPosSigBox.y + (startBoxSizeSigBox.height - newHeight);
        }
        if (resizeHandleTypeSigBox.includes('s')) { 
            newHeight = Math.max(minHeight, startBoxSizeSigBox.height + deltaY);
        }
        if (newLeft < 0) { newWidth += newLeft; newLeft = 0; } 
        if (newTop < 0) { newHeight += newTop; newTop = 0; } 
        if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
        if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }
        newWidth = Math.max(minWidth, newWidth);
        newHeight = Math.max(minHeight, newHeight);
        signatureBoxEl.style.width = `${newWidth}px`;
        signatureBoxEl.style.height = `${newHeight}px`;
        signatureBoxEl.style.left = `${newLeft}px`;
        signatureBoxEl.style.top = `${newTop}px`;
    }

    function setupSigBoxDragEvents(box) {
        function initSigBoxDrag(clientX, clientY) {
            if (box.classList.contains('position-confirmed')) return; 
            isDraggingSigBox = true;
            const viewerRect = pdfViewer.getBoundingClientRect();
            signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
            signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;
            isDraggingPdf = false; 
            isResizingSigBox = false; 
            pinchState.active = false; 
            window.addEventListener('mousemove', _onSigBoxDragMove);
            window.addEventListener('touchmove', _onSigBoxDragMove, { passive: false });
            window.addEventListener('mouseup', _onSigBoxDragEnd);
            window.addEventListener('touchend', _onSigBoxDragEnd);
        }
        box.addEventListener('mousedown', (e) => {
            if (e.target === box && !box.classList.contains('position-confirmed')) {
                e.stopImmediatePropagation(); 
                initSigBoxDrag(e.clientX, e.clientY);
            }
        });
        box.addEventListener('touchstart', (e) => {
            if (e.target === box && e.touches.length === 1 && !box.classList.contains('position-confirmed')) {
                e.stopImmediatePropagation();
                e.preventDefault(); 
                initSigBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
    }

    function handleSigBoxDragMove(clientX, clientY) {
        if (!isDraggingSigBox || !signatureBoxEl) return;
        const viewerRect = pdfViewer.getBoundingClientRect();
        let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
        let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;
        newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBoxEl.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBoxEl.offsetHeight));
        signatureBoxEl.style.left = `${newLeft}px`;
        signatureBoxEl.style.top = `${newTop}px`;
    }

    function openSignatureModal() { 
      // Esta función es para que el Usuario A firme en un cuadro ya confirmado.
      // Necesita activeSignatureBoxInfo.
      if (!activeSignatureBoxInfo) {
          // Si hay un signatureBoxEl azul, no se puede abrir este modal.
          if (signatureBoxEl && !signatureBoxEl.classList.contains('position-confirmed')) {
              showMessage("Primero debe confirmar la posición del cuadro de firma (botón ✔️ del cuadro azul) antes de poder dibujar en él.");
          } else {
              showMessage("Error: No hay un área de firma confirmada y activa para dibujar. Añada una firma y confírmela (✔️).");
          }
          return;
      }
      // El resto de la lógica del modal de firma para Usuario A...
      signatureModalEl = document.createElement('div');
      signatureModalEl.className = 'signature-modal';
      const container = document.createElement('div');
      container.className = 'signature-container';
      const canvasContainer = document.createElement('div');
      canvasContainer.className = 'signature-canvas-container';
      signaturePadCanvasEl = document.createElement('canvas');
      signaturePadCanvasEl.id = 'signature-canvas';
      canvasContainer.appendChild(signaturePadCanvasEl);
      container.appendChild(canvasContainer);
      signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
     
      const controls = document.createElement('div');
      controls.className = 'signature-controls';
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-control-btn cancel';
      cancelBtn.textContent = '❌ Cancelar';
      cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
     
      const clearBtn = document.createElement('button');
      clearBtn.className = 'signature-control-btn clear';
      clearBtn.textContent = '↩️ Limpiar';
      clearBtn.onclick = () => {
        signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / (window.devicePixelRatio||1) , signaturePadCanvasEl.height / (window.devicePixelRatio||1) );
      };
     
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-control-btn confirm';
      confirmBtn.textContent = '✔️ Firmar';
      confirmBtn.onclick = embedSignature; 
     
      controls.appendChild(cancelBtn);
      controls.appendChild(clearBtn);
      controls.appendChild(confirmBtn);
      container.appendChild(controls);
      signatureModalEl.appendChild(container);
      document.body.appendChild(signatureModalEl);
     
      requestAnimationFrame(() => {
        const rect = canvasContainer.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        signaturePadCanvasEl.width = rect.width * dpr;
        signaturePadCanvasEl.height = rect.height * dpr;
        signaturePadCanvasEl.style.width = `${rect.width}px`;
        signaturePadCanvasEl.style.height = `${rect.height}px`;
        signaturePadCtxEl.scale(dpr, dpr); 
        signaturePadCtxEl.lineWidth = 1.5; 
        signaturePadCtxEl.lineCap = 'round'; 
        signaturePadCtxEl.lineJoin = 'round'; 
        signaturePadCtxEl.strokeStyle = '#000000'; 
      });
      setupSignaturePadDrawingEventsEl(); 
    }

    function setupSignaturePadDrawingEventsEl() {
      function getPadPosition(e) { 
        const rect = signaturePadCanvasEl.getBoundingClientRect();
        let clientX, clientY;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
          x: (clientX - rect.left), 
          y: (clientY - rect.top)
        };
      }
      function startPadDraw(e) {
        e.preventDefault();
        isDrawingOnPadEl = true;
        lastDrawPadPosEl = getPadPosition(e);
        signaturePadCtxEl.beginPath(); 
        signaturePadCtxEl.moveTo(lastDrawPadPosEl.x, lastDrawPadPosEl.y);
      }
      function drawOnPad(e) {
        if (!isDrawingOnPadEl) return;
        e.preventDefault();
        const currentPos = getPadPosition(e);
        signaturePadCtxEl.lineTo(currentPos.x, currentPos.y);
        signaturePadCtxEl.stroke(); 
        lastDrawPadPosEl = currentPos;
      }
      function stopPadDraw() {
         if(isDrawingOnPadEl) {
           isDrawingOnPadEl = false;
         }
      }
      signaturePadCanvasEl.addEventListener('mousedown', startPadDraw);
      signaturePadCanvasEl.addEventListener('mousemove', drawOnPad);
      signaturePadCanvasEl.addEventListener('mouseup', stopPadDraw);
      signaturePadCanvasEl.addEventListener('mouseout', stopPadDraw); 
      signaturePadCanvasEl.addEventListener('touchstart', startPadDraw, { passive: false });
      signaturePadCanvasEl.addEventListener('touchmove', drawOnPad, { passive: false });
      signaturePadCanvasEl.addEventListener('touchend', stopPadDraw);
    }

    function embedSignature() { // Cuando Usuario A firma su propio cuadro
        const tempCanvasTest = document.createElement('canvas');
        tempCanvasTest.width = signaturePadCanvasEl.width; 
        tempCanvasTest.height = signaturePadCanvasEl.height;
        const blankDataURL = tempCanvasTest.toDataURL();
       
        if (!activeSignatureBoxInfo) { 
            showMessage("Error: No hay información del cuadro de firma activo para incrustar la firma.");
            if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
            return;
        }
        if (!signaturePadCanvasEl || signaturePadCanvasEl.toDataURL() === blankDataURL) {
            showMessage("Por favor, dibuja una firma primero.");
            return;
        }

        const dataURL = signaturePadCanvasEl.toDataURL('image/png'); 
        const signatureImgElement = document.createElement('img');
        signatureImgElement.className = 'embedded-signature'; 
        signatureImgElement.src = dataURL;
       
        const signatureInfo = {
            element: signatureImgElement, 
            page: activeSignatureBoxInfo.page,     
            x: activeSignatureBoxInfo.x, 
            y: activeSignatureBoxInfo.y, 
            width: activeSignatureBoxInfo.width, 
            height: activeSignatureBoxInfo.height, 
            dataURL: dataURL       
        };
        embeddedSignatures.push(signatureInfo); 
        pdfViewer.appendChild(signatureImgElement); 
       
        if(activeSignatureBoxInfo.element) { 
            console.log('[embedSignature] Removiendo el cuadro de firma confirmado (era signatureBoxEl) y anulando signatureBoxEl.');
            activeSignatureBoxInfo.element.remove(); 
        }
        // Después de que Usuario A firma en su cuadro, ese cuadro (signatureBoxEl) se reemplaza por la imagen.
        // Ya no hay un signatureBoxEl interactivo en la página que corresponda a ESE proceso.
        signatureBoxEl = null; 
        activeSignatureBoxInfo = null; 
       
        if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
        repositionSignatures(); 
    }

    function repositionSignatures() {
        if (!pdfViewer || !canvas || !pdfDoc) return; 
        const viewerRect = pdfViewer.getBoundingClientRect();
        const pdfCanvasRect = canvas.getBoundingClientRect(); 
        if (pdfCanvasRect.width === 0 || pdfCanvasRect.height === 0) return; 

        const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
        const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;
       
        embeddedSignatures.forEach(sig => {
            if (sig.element) {
                if (sig.page === currentPage) { 
                    const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                    const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                    const displayWidth = sig.width * scale;
                    const displayHeight = sig.height * scale;
                   
                    sig.element.style.left = `${displayX}px`;
                    sig.element.style.top = `${displayY}px`;
                    sig.element.style.width = `${displayWidth}px`;
                    sig.element.style.height = `${displayHeight}px`;
                    sig.element.style.display = 'block'; 
                } else {
                    sig.element.style.display = 'none'; 
                }
            }
        });
    }
   
    function adjustViewerHeightAndRender() {
        const headerElement = document.querySelector('header');
        if (headerElement && pdfViewer) {
            const headerHeight = headerElement.offsetHeight;
            pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
        }
        if (pdfDoc) { 
            renderPage(currentPage); 
        } else {
            if (activeSignatureBoxInfo && activeSignatureBoxInfo.element) {
                activeSignatureBoxInfo.element.style.display = 'none';
            }
             const userBArea = document.getElementById('user-b-sig-area');
            if(userBArea) userBArea.remove();
        }
    }

    function displayMarkerForUserB(marker) {
        if (!pdfDoc || !marker || marker.page !== currentPage || rendering) return;

        const existingUserBArea = document.getElementById('user-b-sig-area');
        if (existingUserBArea) existingUserBArea.remove();

        const userBSignatureAreaEl = document.createElement('div');
        userBSignatureAreaEl.id = 'user-b-sig-area';
        userBSignatureAreaEl.className = 'user-b-signature-area';
        userBSignatureAreaEl.innerHTML = '<span>Haz clic aquí para firmar</span>';
        userBSignatureAreaEl.style.display = 'flex'; 

        const canvasRect = canvas.getBoundingClientRect();
        const viewerRect = pdfViewer.getBoundingClientRect();
        if (canvasRect.width === 0 || canvasRect.height === 0) {
            console.warn("Canvas no listo para posicionar área de User B, reintentando...");
            requestAnimationFrame(() => displayMarkerForUserB(marker)); 
            return;
        }

        const displayX = (marker.x_coord * scale) + (canvasRect.left - viewerRect.left);
        const displayY = (marker.y_coord * scale) + (canvasRect.top - viewerRect.top);
        const displayWidth = marker.width_val * scale;
        const displayHeight = marker.height_val * scale;

        userBSignatureAreaEl.style.left = `${displayX}px`;
        userBSignatureAreaEl.style.top = `${displayY}px`;
        userBSignatureAreaEl.style.width = `${displayWidth}px`;
        userBSignatureAreaEl.style.height = `${displayHeight}px`;

        userBSignatureAreaEl.onclick = () => {
            openSignatureModalForUserB(marker);
        };
        pdfViewer.appendChild(userBSignatureAreaEl);
    }

    function openSignatureModalForUserB(markerToSign) {
        signatureModalEl = document.createElement('div');
        signatureModalEl.className = 'signature-modal';
        const container = document.createElement('div');
        container.className = 'signature-container';
        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'signature-canvas-container';
        signaturePadCanvasEl = document.createElement('canvas');
        signaturePadCanvasEl.id = 'signature-canvas';
        canvasContainer.appendChild(signaturePadCanvasEl);
        container.appendChild(canvasContainer);
        signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
       
        const controls = document.createElement('div');
        controls.className = 'signature-controls';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'signature-control-btn cancel';
        cancelBtn.textContent = '❌ Cancelar';
        cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
       
        const clearBtn = document.createElement('button');
        clearBtn.className = 'signature-control-btn clear';
        clearBtn.textContent = '↩️ Limpiar';
        clearBtn.onclick = () => {
            signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / (window.devicePixelRatio||1), signaturePadCanvasEl.height / (window.devicePixelRatio||1));
        };
       
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'signature-control-btn confirm';
        confirmBtn.textContent = '✔️ Confirmar y Enviar Firma';
        confirmBtn.onclick = async () => { 
            const signatureDataURL = signaturePadCanvasEl.toDataURL('image/png');
            const tempCanvasTest = document.createElement('canvas');
            tempCanvasTest.width = signaturePadCanvasEl.width;
            tempCanvasTest.height = signaturePadCanvasEl.height;
            if (signatureDataURL === tempCanvasTest.toDataURL()) {
                showMessage("Por favor, dibuja una firma primero.");
                return;
            }
            if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
            await saveUserBSignatureToSupabase(markerToSign, signatureDataURL);
        };
       
        controls.appendChild(cancelBtn);
        controls.appendChild(clearBtn);
        controls.appendChild(confirmBtn);
        container.appendChild(controls);
        signatureModalEl.appendChild(container);
        document.body.appendChild(signatureModalEl);
       
        requestAnimationFrame(() => {
            const rect = canvasContainer.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            signaturePadCanvasEl.width = rect.width * dpr;
            signaturePadCanvasEl.height = rect.height * dpr;
            signaturePadCanvasEl.style.width = `${rect.width}px`;
            signaturePadCanvasEl.style.height = `${rect.height}px`;
            signaturePadCtxEl.scale(dpr, dpr);
            signaturePadCtxEl.lineWidth = 1.5;
            signaturePadCtxEl.lineCap = 'round';
            signaturePadCtxEl.lineJoin = 'round';
            signaturePadCtxEl.strokeStyle = '#000000';
        });
        setupSignaturePadDrawingEventsEl();
    }

    async function saveUserBSignatureToSupabase(marker, signatureDataURL) {
        if (!supabaseClient) {
            showMessage("Error: Cliente Supabase no disponible.");
            return;
        }
        showMessage("Guardando y enviando firma...");

        try {
            const response = await fetch(signatureDataURL);
            const blob = await response.blob();
            const signatureFileName = `signed_sig_${marker.marker_id}.png`;
            const signatureStoragePath = `signed_signatures/${marker.doc_id}/${signatureFileName}`;

            const { data: uploadData, error: uploadError } = await supabaseClient.storage
                .from('pdfs') 
                .upload(signatureStoragePath, blob, {
                    contentType: 'image/png',
                    cacheControl: '3600',
                    upsert: true
                });
            if (uploadError) throw new Error(`Error al subir firma a Storage: ${uploadError.message}`);

            const { error: updateError } = await supabaseClient
                .from('signature_markers')
                .update({
                    status: 'signed_by_user_b',
                    signed_signature_storage_path: signatureStoragePath, 
                    signed_at: new Date().toISOString()
                })
                .eq('marker_id', marker.marker_id)
                .eq('doc_id', marker.doc_id);
            if (updateError) throw new Error(`Error al actualizar marcador: ${updateError.message}`);

            showMessage("¡Firma enviada exitosamente!\nPuedes cerrar esta ventana.");
            const placeholderArea = document.getElementById('user-b-sig-area');
            if (placeholderArea) {
                placeholderArea.innerHTML = `<img src="${signatureDataURL}" style="width:100%; height:100%; object-fit:contain;" alt="Firma"/>`;
                placeholderArea.style.border = '1px solid green';
                placeholderArea.style.cursor = 'default';
                placeholderArea.onclick = null;
            }
            if (window.history.replaceState) {
                window.history.replaceState({}, document.title, window.location.pathname);
            }

        } catch (error) {
            console.error("Error guardando firma de Usuario B:", error);
            showMessage(`Error al guardar la firma: ${error.message}`);
        }
    }

    async function checkSignaturesStatus() {
        if (!sharedDocIdForUserA) {
            showMessage("Primero debes compartir un documento usando 'Compartir'.");
            return;
        }
        if (!supabaseClient || !pdfDoc) {
            showMessage("Cliente Supabase no disponible o PDF no cargado.");
            return;
        }
        showMessage("Verificando estado de las firmas...");

        try {
            const { data: markers, error } = await supabaseClient
                .from('signature_markers')
                .select('*')
                .eq('doc_id', sharedDocIdForUserA);

            if (error) throw new Error(`Error obteniendo marcadores: ${error.message}`);
            if (!markers || markers.length === 0) {
                showMessage("No se encontraron marcadores para este documento o aún no hay firmas.");
                return;
            }

            let newSignaturesLoaded = false;
            for (const marker of markers) {
                if (marker.status === 'signed_by_user_b' && marker.signed_signature_storage_path) {
                    const existingSignature = embeddedSignatures.find(sig => sig.marker_id_ref === marker.marker_id);
                    if (existingSignature) {
                        if(existingSignature.element && !pdfViewer.contains(existingSignature.element)){
                             pdfViewer.appendChild(existingSignature.element); 
                        }
                        console.log(`Firma para ${marker.marker_id} ya está en embeddedSignatures o siendo procesada.`);
                        continue; 
                    }
                   
                    console.log(`Descargando firma para marcador ${marker.marker_id} desde ${marker.signed_signature_storage_path}`);
                    const { data: signatureDownloadData, error: signatureDownloadError } = await supabaseClient.storage
                        .from('pdfs') 
                        .download(marker.signed_signature_storage_path);

                    if (signatureDownloadError) {
                        console.error(`Error descargando firma ${marker.signed_signature_storage_path}:`, signatureDownloadError);
                        showMessage(`Error al descargar una firma: ${signatureDownloadError.message}`);
                        continue;
                    }

                    const signatureDataURL = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(signatureDownloadData);
                    });

                    const signatureImgElement = document.createElement('img');
                    signatureImgElement.className = 'embedded-signature';
                    signatureImgElement.src = signatureDataURL;
                    pdfViewer.appendChild(signatureImgElement); 

                    const signatureInfo = {
                        element: signatureImgElement,
                        page: marker.page,
                        x: marker.x_coord,
                        y: marker.y_coord,
                        width: marker.width_val,
                        height: marker.height_val,
                        dataURL: signatureDataURL,
                        marker_id_ref: marker.marker_id
                    };
                    embeddedSignatures.push(signatureInfo);
                    newSignaturesLoaded = true;
                }
            }

            if (newSignaturesLoaded) {
                showMessage("Firmas actualizadas y cargadas en el documento.");
            } else {
                const hasPending = markers.some(m => m.status === 'pending_user_b_signature');
                if (hasPending) {
                    showMessage("El documento aún tiene firmas pendientes por parte del Usuario B.");
                } else {
                    const allSignedAndPresent = markers
                        .filter(m => m.status === 'signed_by_user_b')
                        .every(m => embeddedSignatures.some(es => es.marker_id_ref === m.marker_id));
                   
                    if (markers.some(m=> m.status === 'signed_by_user_b') && allSignedAndPresent) {
                         showMessage("Todas las firmas disponibles ya han sido cargadas.");
                    } else if (!markers.some(m => m.status === 'signed_by_user_b')) {
                         showMessage("Aún no hay firmas de Usuario B para este documento.");
                    } else {
                          showMessage("No hay nuevas firmas o todas las firmas ya han sido cargadas.");
                    }
                }
            }
            repositionSignatures(); 
            repositionActiveSignatureBox();

        } catch (error) {
            console.error("Error verificando firmas:", error);
            showMessage(`Error al verificar firmas: ${error.message}`);
        }
    }

    window.addEventListener('mousemove', (e) => {
        if (isDraggingSigBox || isResizingSigBox) return;
        if (isDraggingPdf && !pinchState.active) handlePdfMove(e.clientX, e.clientY);
    });
    window.addEventListener('touchmove', (e) => {
        if (isDraggingSigBox || isResizingSigBox) return;
        if (pinchState.active && e.touches.length === 2) { e.preventDefault(); handlePinchMove(e.touches[0], e.touches[1]); }
        else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) handlePdfMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    window.addEventListener('mouseup', () => { 
        if (isDraggingPdf) {
            isDraggingPdf = false;
            canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default';
        }
    });
    window.addEventListener('touchend', (e) => { 
        if (isDraggingPdf) isDraggingPdf = false;
        if (pinchState.active && e.touches.length < 2) pinchState.active = false; 
    });
   
    window.addEventListener('load', async () => { 
        adjustViewerHeightAndRender();
        const urlParams = new URLSearchParams(window.location.search);
        const docIdFromUrl = urlParams.get('doc_id');
        const mode = urlParams.get('mode');

        if (docIdFromUrl && mode === 'sign_for_user_b') { 
            console.log(`Modo Firmante (Usuario B): Cargar documento con ID: ${docIdFromUrl}`);
            document.getElementById('file-input').style.display = 'none';
            const addUserASigButton = document.getElementById('toolbar').querySelector('button[onclick="addSignatureBox()"]');
            if(addUserASigButton) addUserASigButton.style.display = 'none';
            const shareBtn = document.getElementById('share-pdf-btn');
            if(shareBtn) shareBtn.style.display = 'none';
            const saveBtn = document.getElementById('toolbar').querySelector('button[onclick="downloadPDF()"]');
            if(saveBtn) saveBtn.style.display = 'none';
            const checkStatusBtn = document.getElementById('check-signatures-btn');
            if(checkStatusBtn) checkStatusBtn.style.display = 'none';

            showMessage(`Cargando documento ${docIdFromUrl} para firmar...`);

            if (!supabaseClient) {
                showMessage("Error: Cliente Supabase no disponible para cargar el documento.");
                return;
            }

            try {
                const { data: markers, error: markerError } = await supabaseClient
                    .from('signature_markers')
                    .select('*')
                    .eq('doc_id', docIdFromUrl);

                if (markerError) throw new Error(`Error obteniendo marcador: ${markerError.message}`);
               
                const targetMarker = markers ? markers.find(m => m.status === 'pending_user_b_signature' || m.status === 'signed_by_user_b') : null;

                if (!targetMarker) {
                    showMessage("Documento no encontrado, ya procesado, o enlace inválido.");
                    if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
                    return;
                }
               
                markerDataForUserB = targetMarker; 
                let pdfPathInStorage = markerDataForUserB.pdf_storage_path;

                if (!pdfPathInStorage) { 
                    console.warn("pdf_storage_path no encontrado en el marcador, intentando listar archivos...");
                    const { data: fileList, error: listError } = await supabaseClient.storage
                        .from('pdfs')
                        .list(`documents/${docIdFromUrl}`, { limit: 1, sortBy: { column: 'created_at', order: 'desc' } });
                    if (listError || !fileList || fileList.length === 0) {
                        throw new Error(`No se encontró el archivo PDF en storage para ${docIdFromUrl}: ${listError ? listError.message : 'Lista vacía'}`);
                    }
                    pdfPathInStorage = fileList[0].name; 
                    originalFileName = fileList[0].name;
                    pdfPathInStorage = `documents/${docIdFromUrl}/${pdfPathInStorage}`; 
                } else {
                    originalFileName = pdfPathInStorage.split('/').pop(); 
                }

                const { data: pdfBlob, error: downloadError } = await supabaseClient.storage
                    .from('pdfs') 
                    .download(pdfPathInStorage);

                if (downloadError) throw new Error(`Error descargando PDF (${pdfPathInStorage}): ${downloadError.message}`);
                originalPdfFileBlob = pdfBlob;

                const reader = new FileReader();
                reader.onload = async function (e_reader) {
                    try { 
                        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                        }
                        const loadingTask = pdfjsLib.getDocument({ data: e_reader.target.result });
                        pdfDoc = await loadingTask.promise;
                        totalPages = pdfDoc.numPages;
                        currentPage = markerDataForUserB.page; 
                        translatePos = { x: 0, y: 0 }; scale = 1;
                        document.getElementById('zoom-slider').value = scale;
                        document.getElementById('total-pages').textContent = totalPages;
                       
                        embeddedSignatures = [];
                        document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
                        if (signatureBoxEl) { signatureBoxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null;}
                        pageVisitCounts = {}; totalPageViewsSession = 0;

                        await renderPage(currentPage); 

                        if (markerDataForUserB.status === 'signed_by_user_b' && markerDataForUserB.signed_signature_storage_path) {
                            showMessage("Este documento ya ha sido firmado. Mostrando firma...");
                            const { data: sigBlob, error: sigErr } = await supabaseClient.storage.from('pdfs').download(markerDataForUserB.signed_signature_storage_path);
                            if (sigErr) throw new Error("Error descargando la firma existente: " + sigErr.message);
                            const sigDataURL = await new Promise((resolve, reject) => {
                               const r = new FileReader(); r.onloadend = () => resolve(r.result); r.onerror = reject; r.readAsDataURL(sigBlob);
                            });
                            const placeholderArea = document.getElementById('user-b-sig-area');
                            if (placeholderArea) { 
                                placeholderArea.innerHTML = `<img src="${sigDataURL}" style="width:100%; height:100%; object-fit:contain;" alt="Firma"/>`;
                                placeholderArea.style.border = '1px solid green';
                                placeholderArea.style.cursor = 'default';
                                placeholderArea.onclick = null;
                            }
                        } else if (markerDataForUserB.status === 'pending_user_b_signature') {
                             showMessage("Documento cargado. Haz clic en el área indicada para firmar.");
                        }
                    } catch (pdfLoadError) {
                         console.error("Error procesando PDF para Usuario B:", pdfLoadError);
                         showMessage(`Error al procesar el PDF: ${pdfLoadError.message}`);
                    }
                };
                reader.readAsArrayBuffer(pdfBlob);

            } catch (error) {
                console.error("Error cargando documento para Usuario B:", error);
                showMessage(`Error al cargar el documento: ${error.message}`);
                if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
            }
        } else if (docIdFromUrl && mode === 'sign') { 
             console.log(`Modo Firmante (Antiguo): Cargar documento con ID: ${docIdFromUrl}`);
             showMessage(`Modo Firmante (Antiguo) detectado.\nID del Documento: ${docIdFromUrl}\n\n(Este modo puede estar obsoleto o no completamente funcional con las nuevas características.)`);
             document.getElementById('file-input').style.display = 'none';
        }
    });
    window.addEventListener('resize', adjustViewerHeightAndRender);

  </script>
</body>
</html>
