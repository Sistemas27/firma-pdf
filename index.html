<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Firmar Documento PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #e9ecef;
      overflow: hidden; /* Evita el scroll en el body, el visor lo manejar√° */
    }

    header {
      background: #343a40;
      color: white;
      padding: 0.5rem;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative; /* Para z-index si fuera necesario */
      z-index: 1000; /* Asegura que el header est√© sobre el visor */
    }

    header h2 {
        margin-top: 0.2rem;
        margin-bottom: 0.5rem;
        font-size: 1.15rem;
        font-weight: 500;
    }

    .navigation-toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 380px; /* Limita el ancho para mejor apariencia */
      margin: 0 auto 0.5rem auto; /* Centrado y espacio inferior */
    }

    #page-info {
      margin: 0 0.8rem;
      font-size: 0.8rem;
      white-space: nowrap;
      color: #adb5bd; /* Un color m√°s suave para la informaci√≥n de p√°gina */
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap; /* Permite que los botones pasen a la siguiente l√≠nea si no caben */
      justify-content: center;
      align-items: center;
      gap: 0.3rem; /* Espacio peque√±o entre botones */
      width: 100%;
    }

    .toolbar-btn {
      background: #007bff;
      border: none;
      padding: 0.45rem 0.8rem; /* Ajuste de padding */
      margin: 0.15rem; /* Margen peque√±o */
      color: white;
      font-size: 0.8rem; /* Tama√±o de fuente reducido para botones */
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
      flex-grow: 0; /* No crecer */
      flex-basis: auto; /* Basado en contenido */
    }
    .toolbar-btn:hover {
        background-color: #0056b3;
        box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25); /* Sombra de foco sutil */
    }
    .toolbar-btn.page-nav-btn {
        min-width: auto; /* Ancho autom√°tico */
        padding: 0.4rem 0.7rem; /* Padding espec√≠fico para botones de p√°gina */
        background-color: #495057; /* Color diferente para navegaci√≥n de p√°gina */
    }
    .toolbar-btn.page-nav-btn:hover {
        background-color: #343a40;
        box-shadow: 0 0 0 0.2rem rgba(108,117,125,.25);
    }


    #pdf-viewer {
      width: 100vw;
      /* height ser√° ajustado por JS para ocupar el espacio restante */
      overflow: hidden; /* El canvas interno puede ser m√°s grande */
      background: #f8f9fa; /* Un fondo ligeramente diferente al body */
      position: relative; /* Para posicionar el canvas y otros elementos internos */
      display: flex; /* Para centrar el canvas si es m√°s peque√±o que el visor */
      justify-content: center;
      align-items: center;
      touch-action: none; /* Previene acciones t√°ctiles por defecto como scroll/zoom en el visor mismo */
    }

    .page-usage-counter {
        position: absolute;
        top: 8px; /* Espaciado desde la parte superior del visor */
        padding: 4px 8px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        font-size: 0.7rem; /* Peque√±o para no ser intrusivo */
        border-radius: 0.2rem;
        z-index: 50; /* Sobre el canvas, debajo de modales */
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #current-page-visits {
        left: 8px;
    }
    #total-page-views {
        right: 8px;
    }


    #pdf-canvas {
      cursor: grab; /* Indica que se puede arrastrar */
      image-rendering: -webkit-optimize-contrast; /* Mejora la nitidez en Chrome/Safari */
      image-rendering: crisp-edges; /* Mejora la nitidez en Firefox */
      box-shadow: 0 0 10px rgba(0,0,0,0.1); /* Sombra sutil para dar profundidad */
    }

    #zoom-slider-container {
      position: fixed; /* Fijo en la pantalla */
      right: 8px; /* Pegado a la derecha */
      top: 50%; /* Centrado verticalmente */
      transform: translateY(-50%);
      background: rgba(52, 58, 64, 0.8); /* Fondo semitransparente */
      padding: 6px;
      border-radius: 0.25rem;
      z-index: 9999; /* Encima de casi todo */
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    #zoom-slider {
      writing-mode: bt-lr; /* IE */
      -webkit-appearance: slider-vertical; /* WebKit */
      width: 16px; /* Ancho del slider vertical */
      height: 100px; /* Altura del slider */
      transform: rotate(180deg); /* Para que el m√≠nimo est√© abajo */
    }

    /* Estilo para el input de archivo */
    input[type="file"]#file-input {
      padding: 0.4rem;
      border-radius: 0.25rem;
      border: 1px solid #ced4da;
      background-color: #fff;
      color: #495057;
      cursor: pointer;
      font-size: 0.75rem; /* Tama√±o de fuente m√°s peque√±o */
      max-width: 240px; /* Evita que sea demasiado ancho */
      margin: 0.15rem; /* Margen consistente con otros botones */
    }
    input[type="file"]#file-input::file-selector-button { /* Estilo del bot√≥n interno del input file */
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.4rem 0.7rem;
        border-radius: 0.2rem;
        cursor: pointer;
        margin-right: 8px; /* Espacio entre el bot√≥n y el texto del archivo */
    }

    /* Estilos para el cuadro de firma interactivo */
    .signature-box {
      position: absolute;
      border: 1px solid #007bff; /* Borde azul distintivo */
      background-color: rgba(0, 123, 255, 0.08); /* Fondo azul muy sutil */
      cursor: move; /* Cursor por defecto cuando es arrastrable */
      z-index: 100; /* Encima del canvas PDF, debajo de modales */
      touch-action: none; /* Importante para el arrastre t√°ctil */
      border-radius: 3px;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.35), 0 1px 4px rgba(0,0,0,0.15); /* Para mayor visibilidad */
    }
    .signature-box.position-confirmed {
        cursor: default; /* Cursor cuando la posici√≥n est√° bloqueada */
        border: 1px dashed #6c757d; /* Borde discontinuo gris */
        background-color: transparent; 
        box-shadow: none; /* Sin sombra activa */
    }


    .signature-box-controls {
      position: absolute;
      top: -38px; /* Posicionado encima del cuadro */
      left: 50%;
      transform: translateX(-50%); /* Centrado horizontalmente */
      display: flex;
      gap: 8px; /* Espacio entre botones de control */
      padding: 5px;
      background-color: #fff; /* Fondo para los controles */
      border-radius: 0.25rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }

    .signature-box-btn {
      width: 30px; /* Botones circulares */
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px; /* Tama√±o del √≠cono/emoji */
      border: none;
      color: white;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s ease;
    }
    .signature-box-btn:hover {
        transform: scale(1.1); /* Efecto de zoom al pasar el mouse */
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    .signature-box-btn.confirm { background-color: #28a745; } /* Verde (Paloma ‚úîÔ∏è) */
    .signature-box-btn.cancel { background-color: #dc3545; } /* Rojo (Basura üóëÔ∏è o X ‚ùå) */
    .signature-box-btn.edit { background-color: #ffc107; color: #212529; } /* Amarillo (L√°piz ‚úèÔ∏è) */
    .signature-box-btn.draw { background-color: #007bff; } /* Azul (Mano ‚úçÔ∏è) */


    .resize-handle {
      position: absolute;
      width: 12px; /* Mayor √°rea t√°ctil */
      height: 12px;
      background-color: #fff; /* Color de fondo del manejador */
      border: 2px solid #007bff; /* Borde para visibilidad */
      border-radius: 50%; /* Circular */
      z-index: 101; /* Encima del signature-box */
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

    /* Estilos para el modal de firma */
    .signature-modal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.6); display: flex;
      justify-content: center; align-items: center; z-index: 10000; padding: 10px;
    }
    .signature-container {
      background-color: #ffffff; padding: 25px; border-radius: 0.3rem;
      width: 100%; max-width: 550px; height: auto; max-height: 90vh;
      display: flex; flex-direction: column; box-shadow: 0 0.5rem 1rem rgba(0,0,0,.15);
    }
    .signature-canvas-container {
      flex-grow: 1; border: 1px solid #ced4da; margin-bottom: 20px;
      position: relative; min-height: 200px; border-radius: 0.25rem;
      overflow: hidden; background-color: #fff;
    }
    #signature-canvas {
      width: 100%; height: 100%; background-color: transparent;
      cursor: crosshair; touch-action: none;
    }
    .signature-controls {
      display: flex; justify-content: space-between;
      flex-wrap: wrap; gap: 10px;
    }
    .signature-control-btn {
      padding: 0.6rem 1rem; border: none; border-radius: 0.25rem;
      cursor: pointer; font-size: 0.9rem; flex-grow: 1; min-width: 100px;
      text-align: center; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      font-weight: 500;
    }
    .signature-control-btn:hover {
        transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .signature-control-btn.cancel { background-color: #dc3545; color: white; }
    .signature-control-btn.clear { background-color: #ffc107; color: #212529; }
    .signature-control-btn.confirm { background-color: #28a745; color: white; }
    .embedded-signature {
      position: absolute; z-index: 99; pointer-events: none;
      transform-origin: top left;
    }
    .message-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.6); display: flex;
        justify-content: center; align-items: center; z-index: 20000; padding: 15px;
    }
    .message-modal-content {
        background-color: white; padding: 25px; border-radius: 0.3rem;
        text-align: center; box-shadow: 0 0.5rem 1rem rgba(0,0,0,.175);
        max-width: 400px; width: 100%;
    }
    .message-modal-content p {
        margin-top: 0; margin-bottom: 20px; font-size: 1rem;
        color: #212529; white-space: pre-wrap;
    }
    .message-modal-content button, .message-modal-content input {
        background-color: #007bff; color: white; border: none;
        padding: 0.5rem 1.25rem; border-radius: 0.25rem; cursor: pointer;
        font-size: 0.95rem; transition: background-color 0.2s ease;
        display: block; width: 100%; margin-top: 10px;
    }
    .message-modal-content button:hover { background-color: #0056b3; }
    .message-modal-content input {
        background-color: #fff; color: #495057; border: 1px solid #ced4da;
        margin-bottom: 10px; text-align: left; cursor: text;
    }
    #qr-code-container img, #qr-code-container svg { /* Estilo para el QR */
        display: block;
        margin: 0 auto;
        border: 1px solid #eee; /* Opcional: un borde ligero para el QR */
    }
  </style>
</head>
<body>
  <header>
    <h2>Firmar Documento PDF</h2>
    <div class="navigation-toolbar">
      <button class="toolbar-btn page-nav-btn" onclick="prevPage()">‚¨ÖÔ∏è Anterior</button>
      <div id="page-info">P√°gina <span id="current-page">1</span> de <span id="total-pages">1</span></div>
      <button class="toolbar-btn page-nav-btn" onclick="nextPage()">‚û°Ô∏è Siguiente</button>
    </div>
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" />
      <button class="toolbar-btn" onclick="addSignatureBox()">‚úçÔ∏è A√±adir Firma</button>
      <button class="toolbar-btn" onclick="downloadPDF()">üìÇ Guardar</button>
      <button class="toolbar-btn" id="share-pdf-btn" onclick="sharePDF()">üì§ Compartir</button>
    </div>
  </header>

  <div id="pdf-viewer">
    <canvas id="pdf-canvas"></canvas>
    <div id="current-page-visits" class="page-usage-counter" title="Visitas a esta p√°gina">P: 0</div>
    <div id="total-page-views" class="page-usage-counter" title="Total vistas de p√°gina">T: 0</div>
  </div>

  <div id="zoom-slider-container">
    <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
  </div>

  <script>
    // --- Configuraci√≥n de Supabase ---
    const SUPABASE_URL = 'https://clkxkehypxmcqxcalmwn.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa3hrZWh5cHhtY3F4Y2FsbXduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzNzgxMjIsImV4cCI6MjA2Mzk1NDEyMn0.eINgBpLReFf_PJmdsM2SVSD9QmuGs4FJe6jcJkp9wCg';

    let supabaseClient = null;

    // --- Funci√≥n showMessage MODIFICADA para QR ---
    function showMessage(message, isUrl = false, urlToCopy = '', qrCodeHtml = '') {
        const existingModal = document.querySelector('.message-modal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.className = 'message-modal';
        const content = document.createElement('div');
        content.className = 'message-modal-content';

        let htmlContent = `<p>${message.replace(/\n/g, '<br>')}</p>`;

        if (qrCodeHtml) {
            htmlContent += `<div id="qr-code-container" style="margin: 15px auto; width: 128px; height: 128px;">${qrCodeHtml}</div>`;
        }

        if (isUrl && urlToCopy) {
            htmlContent += `<input type="text" value="${urlToCopy}" id="shareable-url-input" readonly style="width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">`;
            htmlContent += `<button id="copy-url-btn">Copiar URL</button>`;
        }
        // Ajustar margen del bot√≥n OK si hay URL/QR o no
        const okButtonMarginTop = (isUrl && urlToCopy) || qrCodeHtml ? '5px' : '0';
        htmlContent += `<button id="ok-message-btn" style="margin-top: ${okButtonMarginTop};">OK</button>`;

        content.innerHTML = htmlContent;
        modal.appendChild(content);
        document.body.appendChild(modal);

        content.querySelector('#ok-message-btn').onclick = () => modal.remove();

        if (isUrl && urlToCopy && content.querySelector('#copy-url-btn')) {
            const copyBtn = content.querySelector('#copy-url-btn');
            const urlInput = content.querySelector('#shareable-url-input');
            copyBtn.onclick = () => {
                urlInput.select();
                urlInput.setSelectionRange(0, 99999);
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(urlToCopy).then(() => {
                            copyBtn.textContent = '¬°Copiado!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        }).catch(err => { // Fallback para entornos donde navigator.clipboard.writeText puede fallar
                            if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                            urlInput.select(); 
                            document.execCommand('copy');
                            copyBtn.textContent = '¬°Copiado!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        });
                    } else { // Fallback para HTTP o contextos no seguros
                        urlInput.select(); 
                        if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                        copyBtn.textContent = '¬°Copiado!';
                        setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                    }
                } catch (err) {
                    console.error('Error al copiar URL:', err);
                    showMessage('Error al copiar. Por favor, copia manualmente.');
                }
            };
        }
    }
    
    // --- Inicializaci√≥n de Supabase (como estaba en tu c√≥digo) ---
    try {
        if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'TU_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'TU_SUPABASE_ANON_KEY') {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY); 
            console.info("Cliente de Supabase inicializado correctamente.");
        } else {
            const placeholderErrorMsg = "Configuraci√≥n Incompleta: Supabase URL o Anon Key son incorrectas.\n\nLa funci√≥n de compartir no funcionar√°.";
            console.warn(placeholderErrorMsg);
            if (typeof showMessage === 'function') { 
                showMessage(placeholderErrorMsg);
            }
            supabaseClient = null; 
        }
    } catch (error) {
        console.error("Error CR√çTICO inicializando Supabase:", error);
        let detail = (error && error.message) ? error.message : (typeof error === 'string' ? error : "Error desconocido.");
        const initErrorMsg = `Error CR√çTICO al inicializar Supabase:\n\n${detail}\n\nLa funci√≥n de compartir no funcionar√°.`;
        if (typeof showMessage === 'function') { 
            showMessage(initErrorMsg);
        }
        supabaseClient = null;
    }

    // --- Variables Globales (como estaban en tu c√≥digo, m√°s activeSignatureBoxInfo) ---
    let pdfDoc = null;
    let originalFileName = 'documento.pdf';
    let originalPdfFileBlob = null; 
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1;
    let canvas = document.getElementById('pdf-canvas');
    let context = canvas.getContext('2d');
    const pdfViewer = document.getElementById('pdf-viewer');
    let rendering = false;

    let isDraggingPdf = false;
    let startPos = { x: 0, y: 0 };
    let translatePos = { x: 0, y: 0 };
    let isZoomed = false;

    let embeddedSignatures = [];
    let signatureBoxEl = null;
    let activeSignatureBoxInfo = null; // Para el anclaje del cuadro confirmado
    let isDraggingSigBox = false;
    let isResizingSigBox = false;
    let signatureBoxDragOffset = { x: 0, y: 0 };
    let resizeHandleTypeSigBox = null;
    let startBoxPosSigBox = { x: 0, y: 0 };
    let startBoxSizeSigBox = { width: 0, height: 0 };
    let startPointerPosSigBox = { x: 0, y: 0 };

    let signatureModalEl = null;
    let signaturePadCanvasEl = null;
    let signaturePadCtxEl = null;
    let isDrawingOnPadEl = false;
    let lastDrawPadPosEl = { x: 0, y: 0 };

    let pinchState = {
        active: false, initialDistance: 0, lastScale: 1,
        pdfPointX: 0, pdfPointY: 0,
        screenCenterX: 0, screenCenterY: 0
    };

    let pageVisitCounts = {};
    let totalPageViewsSession = 0;

    // --- Listener de Carga de Archivo (como estaba en tu c√≥digo) ---
    document.getElementById('file-input').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'application/pdf') {
        originalFileName = file.name;
        originalPdfFileBlob = file; 
        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            }
            const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;
            currentPage = 1;
            translatePos = { x: 0, y: 0 }; 
            scale = 1; 
            document.getElementById('zoom-slider').value = scale;
            document.getElementById('total-pages').textContent = totalPages;
            document.getElementById('current-page').textContent = currentPage;
            embeddedSignatures = []; // Limpiar firmas anteriores
            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
            if (signatureBoxEl) { // Limpiar cuadro de firma activo si existiera
                signatureBoxEl.remove();
                signatureBoxEl = null;
                activeSignatureBoxInfo = null; 
            }
            pageVisitCounts = {}; totalPageViewsSession = 0;
            updatePageUsageCounters(); 
            renderPage(currentPage);
          } catch (err) {
            showMessage('Error al cargar el PDF. Aseg√∫rate de que es un archivo PDF v√°lido.');
            console.error("Error loading PDF:", err);
            pdfDoc = null; originalPdfFileBlob = null;
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file) {
        showMessage('Por favor, selecciona un archivo PDF.');
        originalPdfFileBlob = null;
      }
        this.value = null; 
    });

    function updatePageUsageCounters() {
        if (!pdfDoc) return;
        pageVisitCounts[currentPage] = (pageVisitCounts[currentPage] || 0) + 1;
        totalPageViewsSession++;
        document.getElementById('current-page-visits').textContent = `P${currentPage}: ${pageVisitCounts[currentPage]}`;
        document.getElementById('total-page-views').textContent = `T: ${totalPageViewsSession}`;
    }

    // --- Renderizado de P√°gina y Transformaciones (CON anclaje de activeSignatureBoxInfo) ---
    function renderPage(num) {
      if (!pdfDoc || rendering) return;
      rendering = true;
      updatePageUsageCounters(); 
      pdfDoc.getPage(num).then(page => {
        const dpr = window.devicePixelRatio || 1; 
        const viewportForRender = page.getViewport({ scale: scale * dpr }); 
        canvas.width = viewportForRender.width; canvas.height = viewportForRender.height;
        const viewportCss = page.getViewport({ scale: scale });
        canvas.style.width = `${viewportCss.width}px`; canvas.style.height = `${viewportCss.height}px`;
        const viewerWidth = pdfViewer.clientWidth; const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = viewportCss.width; const cssCanvasHeight = viewportCss.height;
        canvas.style.left = (cssCanvasWidth < viewerWidth) ? `${(viewerWidth - cssCanvasWidth) / 2}px` : '0px';
        canvas.style.top = (cssCanvasHeight < viewerHeight) ? `${(viewerHeight - cssCanvasHeight) / 2}px` : '0px';
        canvas.style.position = 'absolute'; 
        const renderContext = { canvasContext: context, viewport: viewportForRender };
        page.render(renderContext).promise.then(() => {
          rendering = false;
          document.getElementById('current-page').textContent = num;
          isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
          updateCanvasTransform(); 
          repositionSignatures(); 
          repositionActiveSignatureBox(); // ANCLAJE
        }).catch(err => {
          rendering = false; console.error("Error rendering page:", err); showMessage("Error al renderizar la p√°gina del PDF.");
        });
      }).catch(err => {
          rendering = false; console.error("Error getting page:", err); showMessage("Error al obtener la p√°gina del PDF.");
      });
    }

    function updateCanvasTransform() {
        canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
        repositionSignatures(); 
        repositionActiveSignatureBox(); // ANCLAJE
    }
    
    // --- Funciones de Navegaci√≥n, Zoom, Paneo (como estaban en tu c√≥digo) ---
    // (mousedown, touchstart del canvas, handlePdfMove, handlePinchMove, nextPage, prevPage, zoom-slider, wheel)
    // Estas funciones se mantienen igual que en el c√≥digo que proporcionaste, 
    // ya que su l√≥gica de movimiento y zoom del PDF es independiente del anclaje del cuadro de firma.
    // ... (Incluir aqu√≠ todas esas funciones desde el c√≥digo que me enviaste) ...
    // Para brevedad, no las repito aqu√≠, pero deben estar. Por ejemplo:
    canvas.addEventListener('mousedown', (e) => {
        if (isDraggingSigBox || isResizingSigBox || pinchState.active) return; 
        const cssCanvasWidth = parseFloat(canvas.style.width);
        const cssCanvasHeight = parseFloat(canvas.style.height);
        if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
        if (e.target !== canvas) return; 
        isDraggingPdf = true;
        startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
        canvas.style.cursor = 'grabbing';
    });
    pdfViewer.addEventListener('touchstart', (e) => {
        if (signatureBoxEl && (e.target === signatureBoxEl || signatureBoxEl.contains(e.target))) { return; }
        if (isDraggingSigBox || isResizingSigBox) return; 
        if (e.touches.length === 2) { 
            e.preventDefault(); isDraggingPdf = false; pinchState.active = true;
            const touch1 = e.touches[0]; const touch2 = e.touches[1];
            pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            pinchState.lastScale = scale; 
            const viewerRect = pdfViewer.getBoundingClientRect();
            pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
            pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
            const canvasRect = canvas.getBoundingClientRect();
            const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
            const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;
            pinchState.pdfPointX = pdfPointScreenX / scale; pinchState.pdfPointY = pdfPointScreenY / scale;
        } else if (e.touches.length === 1 && !pinchState.active) { 
            const cssCanvasWidth = parseFloat(canvas.style.width); const cssCanvasHeight = parseFloat(canvas.style.height);
            if ((!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) || e.target !== canvas) {
                isDraggingPdf = false; return;
            }
            isDraggingPdf = true; const touch = e.touches[0];
            startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
        }
    }, { passive: false }); 
    function handlePdfMove(clientX, clientY) {
        if (!isDraggingPdf) return;
        let newTranslateX = clientX - startPos.x; let newTranslateY = clientY - startPos.y;
        const viewerWidth = pdfViewer.clientWidth; const viewerHeight = pdfViewer.clientHeight;
        const cssCanvasWidth = parseFloat(canvas.style.width); const cssCanvasHeight = parseFloat(canvas.style.height);
        const overpanMargin = 30; 
        if (cssCanvasWidth > viewerWidth) {
            const minX = viewerWidth - cssCanvasWidth - overpanMargin; const maxX = overpanMargin; 
            newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
        } else { newTranslateX = 0; }
        if (cssCanvasHeight > viewerHeight) {
            const minY = viewerHeight - cssCanvasHeight - overpanMargin; const maxY = overpanMargin; 
            newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
        } else { newTranslateY = 0; }
        translatePos.x = newTranslateX; translatePos.y = newTranslateY;
        updateCanvasTransform();
    }
    function handlePinchMove(touch1, touch2) {
        if (!pinchState.active || pinchState.initialDistance === 0) return;
        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
        newScale = Math.min(3.0, Math.max(0.5, parseFloat(newScale.toFixed(2)))); 
        if (Math.abs(newScale - scale) < 0.01 && newScale !== 0.5 && newScale !== 3.0) return; 
        const oldScale = scale; scale = newScale;
        const viewerRect = pdfViewer.getBoundingClientRect(); 
        let baseCanvasX = 0; let baseCanvasY = 0;
        if (pdfDoc) {
            pdfDoc.getPage(currentPage).then(page => { 
                const viewportCss = page.getViewport({scale: scale});
                if (viewportCss.width < viewerRect.width) { baseCanvasX = (viewerRect.width - viewportCss.width) / 2; }
                if (viewportCss.height < viewerRect.height) { baseCanvasY = (viewerRect.height - viewportCss.height) / 2; }
                translatePos.x = (pinchState.screenCenterX - viewerRect.left - baseCanvasX) - (pinchState.pdfPointX * scale);
                translatePos.y = (pinchState.screenCenterY - viewerRect.top - baseCanvasY) - (pinchState.pdfPointY * scale);
                document.getElementById('zoom-slider').value = scale.toFixed(1);
                renderPage(currentPage); 
            });
        }
    }
    function nextPage() { if (!pdfDoc || currentPage >= totalPages) return; currentPage++; translatePos = { x: 0, y: 0 }; renderPage(currentPage); }
    function prevPage() { if (!pdfDoc || currentPage <= 1) return; currentPage--; translatePos = { x: 0, y: 0 }; renderPage(currentPage); }
    document.getElementById('zoom-slider').addEventListener('input', async function () {
        if (!pdfDoc) return; const oldScale = scale; scale = parseFloat(this.value);
        const viewerRect = pdfViewer.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect(); 
        const screenCenterX = viewerRect.left + viewerRect.width / 2; const screenCenterY = viewerRect.top + viewerRect.height / 2;
        const pdfPointX = (screenCenterX - canvasRect.left) / oldScale; const pdfPointY = (screenCenterY - canvasRect.top) / oldScale;
        const page = await pdfDoc.getPage(currentPage); const newViewportCss = page.getViewport({scale: scale}); 
        let expectedCanvasOffsetLeft = 0; if (newViewportCss.width < viewerRect.width) { expectedCanvasOffsetLeft = (viewerRect.width - newViewportCss.width) / 2; }
        let expectedCanvasOffsetTop = 0; if (newViewportCss.height < viewerRect.height) { expectedCanvasOffsetTop = (viewerRect.height - newViewportCss.height) / 2; }
        translatePos.x = (screenCenterX - viewerRect.left - expectedCanvasOffsetLeft) - (pdfPointX * scale);
        translatePos.y = (screenCenterY - viewerRect.top - expectedCanvasOffsetTop) - (pdfPointY * scale);
        renderPage(currentPage); pinchState.lastScale = scale; 
    });
    pdfViewer.addEventListener('wheel', async function (e) {
        if (!pdfDoc) return; e.preventDefault(); 
        const oldScale = scale; const delta = e.deltaY > 0 ? -0.1 : 0.1; 
        let newScale = parseFloat((scale + delta).toFixed(2)); newScale = Math.min(3.0, Math.max(0.5, newScale)); 
        if (Math.abs(newScale - oldScale) < 0.01 && newScale !==0.5 && newScale !== 3.0) return; 
        const viewerRect = pdfViewer.getBoundingClientRect(); const mouseXViewer = e.clientX - viewerRect.left; const mouseYViewer = e.clientY - viewerRect.top; 
        const canvasRect = canvas.getBoundingClientRect(); const mouseXOnCanvas = e.clientX - canvasRect.left; const mouseYOnCanvas = e.clientY - canvasRect.top; 
        const pdfPointX = mouseXOnCanvas / oldScale; const pdfPointY = mouseYOnCanvas / oldScale; scale = newScale; 
        const page = await pdfDoc.getPage(currentPage); const newViewportCss = page.getViewport({ scale: scale }); 
        let expectedCanvasLeft = 0; if (newViewportCss.width < viewerRect.width) { expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2; }
        let expectedCanvasTop = 0; if (newViewportCss.height < viewerRect.height) { expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2; }
        translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
        translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
        document.getElementById('zoom-slider').value = scale.toFixed(1); renderPage(currentPage);
    }, { passive: false }); 


    // --- Procesamiento y Descarga de PDF (como estaban en tu c√≥digo) ---
    async function getProcessedPdfBlob() { /* ... (c√≥digo de tu script) ... */ }
    async function downloadPDF() { /* ... (c√≥digo de tu script) ... */ }
    
    // --- Funci√≥n para generar QR ---
    async function generateQRCodeHTML(textToEncode) {
        try {
            const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=128x128&data=${encodeURIComponent(textToEncode)}&format=svg`;
            const response = await fetch(qrApiUrl);
            if (!response.ok) {
                console.error("Error fetching QR code from API:", response.statusText);
                return `<p style="font-size:0.8em; color:red;">Error al generar QR</p>`;
            }
            const svgString = await response.text();
            if (svgString.trim().toLowerCase().startsWith("<svg")) {
                 return svgString; 
            }
            console.error("Respuesta de API de QR no fue SVG v√°lido.");
            return `<p style="font-size:0.8em; color:red;">QR inv√°lido</p>`;
        } catch(error) {
            console.error("Excepci√≥n al generar QR code:", error);
            return `<p style="font-size:0.8em; color:red;">Fallo QR</p>`;
        }
    }

    // --- Funci√≥n sharePDF MODIFICADA para flujo Usuario A -> B ---
    async function sharePDF() {
        if (!pdfDoc) {
            showMessage("Carga un PDF primero para compartir."); return;
        }
        if (!supabaseClient) {
            showMessage("Fallo en Supabase: La inicializaci√≥n no tuvo √©xito.\nLa funci√≥n de compartir no est√° disponible."); return;
        }
        if (!originalPdfFileBlob) {
            showMessage("El PDF original no est√° disponible. Recarga el PDF."); return;
        }
        // Los "cuadros marcadores" son las 'embeddedSignatures' que el Usuario A ha "dibujado"
        // como placeholders (ej. un recuadro o texto "Firmar aqu√≠").
        if (embeddedSignatures.length === 0) {
            showMessage("A√±ade y 'dibuja' al menos un cuadro marcador (placeholder) para el Usuario B antes de compartir."); return;
        }

        showMessage("Preparando documento para compartir...");

        const documentId = `doc_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        const safeOriginalFileName = originalFileName.replace(/[^a-zA-Z0-9_.-]/g, '_'); // Sanitize filename
        const originalPdfStoragePath = `documents_for_signing/${documentId}/${safeOriginalFileName}`;

        try {
            const { data: uploadData, error: uploadError } = await supabaseClient.storage
                .from('pdfs') // Aseg√∫rate que este bucket exista.
                .upload(originalPdfStoragePath, originalPdfFileBlob, {
                    cacheControl: '3600', upsert: false 
                });

            if (uploadError) throw new Error(`Subiendo PDF original: ${uploadError.message}`);
            console.log("PDF original subido:", uploadData);

            const markersToSave = embeddedSignatures.map((sig, index) => ({
                doc_id: documentId, 
                marker_id: `marker_B_${index + 1}_${Date.now()}`, // ID √∫nico para el marcador
                page: sig.page,
                x_coord: sig.x, y_coord: sig.y,
                width_val: sig.width, height_val: sig.height,
                // dataURL_A_placeholder: sig.dataURL, // Opcional: si quieres guardar el visual del placeholder de A
                status: 'pending_user_b_signature' 
            }));
            
            // Aseg√∫rate de tener una tabla 'signature_markers' en Supabase
            // Columnas: id (PK), doc_id, marker_id, page, x_coord, y_coord, width_val, height_val, status, signed_signature_data_url (nullable), signed_at (nullable)
            const { error: markersError } = await supabaseClient
                .from('signature_markers') 
                .insert(markersToSave);

            if (markersError) throw new Error(`Guardando marcadores: ${markersError.message}`);
            console.log("Marcadores guardados en Supabase.");

            const shareUrl = `${window.location.origin}${window.location.pathname}?doc_id=${documentId}&mode=sign_b`; // Usar 'sign_b' para Usuario B
            const qrHtml = await generateQRCodeHTML(shareUrl);

            showMessage(`¬°Listo para compartir con Usuario B!\nID del Documento: ${documentId}\n\nURL:`, true, shareUrl, qrHtml);

        } catch (error) {
            console.error("Error en sharePDF:", error);
            let userMessage = `Error al compartir: ${error.message || "Desconocido."}\n`;
            if (String(error.message).includes("signature_markers")) userMessage += "Verifica tabla 'signature_markers' y permisos en Supabase.\n";
            else if (String(error.message).includes("bucket") || String(error.message).includes("pdfs")) userMessage += "Verifica bucket 'pdfs' y permisos en Supabase.\n";
            userMessage += "\nRevisa consola para detalles.";
            showMessage(userMessage);
        }
    }

    // --- Funciones del Cuadro de Firma (CON anclaje de activeSignatureBoxInfo) ---
    function addSignatureBox() {
      if (!pdfDoc) { showMessage("Por favor, carga un documento PDF primero."); return; }
      if (signatureBoxEl) { signatureBoxEl.remove(); }
      activeSignatureBoxInfo = null; 
      signatureBoxEl = document.createElement('div');
      signatureBoxEl.className = 'signature-box';
      signatureBoxEl.style.width = '150px'; signatureBoxEl.style.height = '75px';
      const viewerRect = pdfViewer.getBoundingClientRect();
      signatureBoxEl.style.left = `${(viewerRect.width - 150) / 2}px`;
      signatureBoxEl.style.top = `${(viewerRect.height - 75) / 2}px`;
      pdfViewer.appendChild(signatureBoxEl);
      makeSignatureBoxEditable(signatureBoxEl); 
    }
    
    function repositionActiveSignatureBox() {
        if (!activeSignatureBoxInfo || !activeSignatureBoxInfo.element || !pdfViewer || !canvas || !pdfDoc) {
            if (activeSignatureBoxInfo && activeSignatureBoxInfo.element) {
                 // activeSignatureBoxInfo.element.style.display = 'none'; 
            }
            return;
        }
        const sig = activeSignatureBoxInfo; const boxEl = sig.element;
        if (sig.page === currentPage) {
            const canvasRect = canvas.getBoundingClientRect(); 
            const viewerRect = pdfViewer.getBoundingClientRect();
            const displayX = (sig.x * scale) + (canvasRect.left - viewerRect.left);
            const displayY = (sig.y * scale) + (canvasRect.top - viewerRect.top);
            const displayWidth = sig.width * scale; const displayHeight = sig.height * scale;
            boxEl.style.left = `${displayX}px`; boxEl.style.top = `${displayY}px`;
            boxEl.style.width = `${displayWidth}px`; boxEl.style.height = `${displayHeight}px`;
            boxEl.style.display = 'block';
        } else { boxEl.style.display = 'none'; }
    }

    function confirmSignatureBoxPlacement(boxEl) {
        if (!boxEl || !pdfDoc) return; 
        const handles = boxEl.querySelectorAll('.resize-handle'); handles.forEach(h => h.remove());
        boxEl.classList.add('position-confirmed'); 
        const canvasRect = canvas.getBoundingClientRect(); const boxRect = boxEl.getBoundingClientRect();
        const boxRelToCanvasX = boxRect.left - canvasRect.left; const boxRelToCanvasY = boxRect.top - canvasRect.top;
        activeSignatureBoxInfo = {
            element: boxEl, page: currentPage,
            x: boxRelToCanvasX / scale, y: boxRelToCanvasY / scale,
            width: boxRect.width / scale, height: boxRect.height / scale  
        };
        repositionActiveSignatureBox(); 
        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) { controls = document.createElement('div'); controls.className = 'signature-box-controls'; boxEl.appendChild(controls); }
        controls.innerHTML = ''; 
        const drawBtn = document.createElement('button'); drawBtn.className = 'signature-box-btn draw';
        drawBtn.innerHTML = '‚úçÔ∏è'; drawBtn.title = 'Dibujar Firma/Marcador'; drawBtn.onclick = (e) => { e.stopPropagation(); openSignatureModal(); };
        const editPosBtn = document.createElement('button'); editPosBtn.className = 'signature-box-btn edit';
        editPosBtn.innerHTML = '‚úèÔ∏è'; editPosBtn.title = 'Editar Posici√≥n'; editPosBtn.onclick = (e) => { e.stopPropagation(); makeSignatureBoxEditable(boxEl); };
        const cancelBtn = document.createElement('button'); cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = '‚ùå'; cancelBtn.title = 'Cancelar/Eliminar Cuadro'; cancelBtn.onclick = (e) => { 
            e.stopPropagation(); boxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null; 
        };
        controls.appendChild(drawBtn); controls.appendChild(editPosBtn); controls.appendChild(cancelBtn);
    }

    function makeSignatureBoxEditable(boxEl) {
        if (!boxEl) return;
        activeSignatureBoxInfo = null; boxEl.classList.remove('position-confirmed'); 
        boxEl.style.cursor = 'move'; 
        boxEl.querySelectorAll('.resize-handle').forEach(h => h.remove()); 
        addResizeHandlesToSigBox(boxEl); 
        let controls = boxEl.querySelector('.signature-box-controls');
        if (!controls) { controls = document.createElement('div'); controls.className = 'signature-box-controls'; boxEl.appendChild(controls); }
        controls.innerHTML = ''; 
        const confirmPlacementBtn = document.createElement('button'); confirmPlacementBtn.className = 'signature-box-btn confirm';
        confirmPlacementBtn.innerHTML = '‚úîÔ∏è'; confirmPlacementBtn.title = 'Confirmar Posici√≥n'; 
        confirmPlacementBtn.onclick = (e) => { e.stopPropagation(); confirmSignatureBoxPlacement(boxEl); };
        const cancelBtn = document.createElement('button'); cancelBtn.className = 'signature-box-btn cancel';
        cancelBtn.innerHTML = 'üóëÔ∏è'; cancelBtn.title = 'Eliminar este cuadro'; 
        cancelBtn.onclick = (e) => { e.stopPropagation(); boxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null; };
        controls.appendChild(confirmPlacementBtn); controls.appendChild(cancelBtn);
        setupSigBoxDragEvents(boxEl); 
    }
    
    // --- L√≥gica de Arrastre y Redimensi√≥n del Cuadro de Firma (como estaba en tu c√≥digo) ---
    // ( _onSigBoxDragMove, _onSigBoxDragEnd, _onSigBoxResizeMove, _onSigBoxResizeEnd, 
    //   addResizeHandlesToSigBox, initSigBoxResize, handleSigBoxResizeMove, 
    //   setupSigBoxDragEvents, handleSigBoxDragMove)
    // Estas funciones se mantienen igual que en el c√≥digo que proporcionaste,
    // ya que definen c√≥mo se edita el cuadro ANTES de confirmarlo y anclarlo.
    // ... (Incluir aqu√≠ todas esas funciones desde el c√≥digo que me enviaste) ...
    // Para brevedad, no las repito aqu√≠, pero deben estar. Por ejemplo:
    const _onSigBoxDragMove = (e) => { const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; handleSigBoxDragMove(clientX, clientY); };
    const _onSigBoxDragEnd = () => { isDraggingSigBox = false; window.removeEventListener('mousemove', _onSigBoxDragMove); window.removeEventListener('touchmove', _onSigBoxDragMove); window.removeEventListener('mouseup', _onSigBoxDragEnd); window.removeEventListener('touchend', _onSigBoxDragEnd); };
    const _onSigBoxResizeMove = (e) => { const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; handleSigBoxResizeMove(clientX, clientY); };
    const _onSigBoxResizeEnd = () => { isResizingSigBox = false; resizeHandleTypeSigBox = null; window.removeEventListener('mousemove', _onSigBoxResizeMove); window.removeEventListener('touchmove', _onSigBoxResizeMove); window.removeEventListener('mouseup', _onSigBoxResizeEnd); window.removeEventListener('touchend', _onSigBoxResizeEnd); };
    function addResizeHandlesToSigBox(box) { const handles = ['nw', 'ne', 'sw', 'se']; handles.forEach(pos => { const handle = document.createElement('div'); handle.className = `resize-handle ${pos}`; box.appendChild(handle); handle.addEventListener('mousedown', (e) => { e.stopImmediatePropagation(); initSigBoxResize(e.clientX, e.clientY, pos, box); }); handle.addEventListener('touchstart', (e) => { e.stopImmediatePropagation(); if (e.touches.length === 1) { e.preventDefault(); initSigBoxResize(e.touches[0].clientX, e.touches[0].clientY, pos, box); } }, { passive: false }); }); }
    function initSigBoxResize(clientX, clientY, handlePos, box) { if (box.classList.contains('position-confirmed')) return; isResizingSigBox = true; resizeHandleTypeSigBox = handlePos; startBoxPosSigBox = { x: box.offsetLeft, y: box.offsetTop }; startBoxSizeSigBox = { width: box.offsetWidth, height: box.offsetHeight }; startPointerPosSigBox = { x: clientX, y: clientY }; isDraggingPdf = false; isDraggingSigBox = false; pinchState.active = false; window.addEventListener('mousemove', _onSigBoxResizeMove); window.addEventListener('touchmove', _onSigBoxResizeMove, { passive: false }); window.addEventListener('mouseup', _onSigBoxResizeEnd); window.addEventListener('touchend', _onSigBoxResizeEnd); }
    function handleSigBoxResizeMove(clientX, clientY) { if (!isResizingSigBox || !resizeHandleTypeSigBox || !signatureBoxEl) return; const deltaX = clientX - startPointerPosSigBox.x; const deltaY = clientY - startPointerPosSigBox.y; let newWidth = startBoxSizeSigBox.width; let newHeight = startBoxSizeSigBox.height; let newLeft = startBoxPosSigBox.x; let newTop = startBoxPosSigBox.y; const minWidth = 50; const minHeight = 30; const viewerRect = pdfViewer.getBoundingClientRect(); if (resizeHandleTypeSigBox.includes('w')) { newWidth = Math.max(minWidth, startBoxSizeSigBox.width - deltaX); newLeft = startBoxPosSigBox.x + (startBoxSizeSigBox.width - newWidth); } if (resizeHandleTypeSigBox.includes('e')) { newWidth = Math.max(minWidth, startBoxSizeSigBox.width + deltaX); } if (resizeHandleTypeSigBox.includes('n')) { newHeight = Math.max(minHeight, startBoxSizeSigBox.height - deltaY); newTop = startBoxPosSigBox.y + (startBoxSizeSigBox.height - newHeight); } if (resizeHandleTypeSigBox.includes('s')) { newHeight = Math.max(minHeight, startBoxSizeSigBox.height + deltaY); } if (newLeft < 0) { newWidth += newLeft; newLeft = 0; } if (newTop < 0) { newHeight += newTop; newTop = 0; } if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; } if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; } newWidth = Math.max(minWidth, newWidth); newHeight = Math.max(minHeight, newHeight); signatureBoxEl.style.width = `${newWidth}px`; signatureBoxEl.style.height = `${newHeight}px`; signatureBoxEl.style.left = `${newLeft}px`; signatureBoxEl.style.top = `${newTop}px`; }
    function setupSigBoxDragEvents(box) { function initSigBoxDrag(clientX, clientY) { if (box.classList.contains('position-confirmed')) return; isDraggingSigBox = true; const viewerRect = pdfViewer.getBoundingClientRect(); signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft; signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop; isDraggingPdf = false; isResizingSigBox = false; pinchState.active = false; window.addEventListener('mousemove', _onSigBoxDragMove); window.addEventListener('touchmove', _onSigBoxDragMove, { passive: false }); window.addEventListener('mouseup', _onSigBoxDragEnd); window.addEventListener('touchend', _onSigBoxDragEnd); } box.addEventListener('mousedown', (e) => { if (e.target === box && !box.classList.contains('position-confirmed')) { e.stopImmediatePropagation(); initSigBoxDrag(e.clientX, e.clientY); } }); box.addEventListener('touchstart', (e) => { if (e.target === box && e.touches.length === 1 && !box.classList.contains('position-confirmed')) { e.stopImmediatePropagation(); e.preventDefault(); initSigBoxDrag(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false }); }
    function handleSigBoxDragMove(clientX, clientY) { if (!isDraggingSigBox || !signatureBoxEl) return; const viewerRect = pdfViewer.getBoundingClientRect(); let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x; let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y; newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBoxEl.offsetWidth)); newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBoxEl.offsetHeight)); signatureBoxEl.style.left = `${newLeft}px`; signatureBoxEl.style.top = `${newTop}px`; }


    // --- Modal de Firma y Dibujo (como estaban en tu c√≥digo) ---
    function openSignatureModal() { /* ... (c√≥digo de tu script) ... */ }
    function setupSignaturePadDrawingEventsEl() { /* ... (c√≥digo de tu script) ... */ }

    // --- Incrustar Firma (con anclaje y placeholder para Usuario A) ---
    function embedSignature() {
        const tempCanvasTest = document.createElement('canvas');
        tempCanvasTest.width = signaturePadCanvasEl.width; tempCanvasTest.height = signaturePadCanvasEl.height;
        const blankDataURL = tempCanvasTest.toDataURL();
        if (!signatureBoxEl || !signaturePadCanvasEl || signaturePadCanvasEl.toDataURL() === blankDataURL) {
            showMessage("Dibuja una firma o marcador primero."); return;
        }
        if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) {
            console.warn("activeSignatureBoxInfo no sincronizado. Recalculando...");
            const canvasRect = canvas.getBoundingClientRect(); const boxRect = signatureBoxEl.getBoundingClientRect();
            const boxRelToCanvasX = boxRect.left - canvasRect.left; const boxRelToCanvasY = boxRect.top - canvasRect.top;
            activeSignatureBoxInfo = { 
                element: signatureBoxEl, page: currentPage,
                x: boxRelToCanvasX / scale, y: boxRelToCanvasY / scale,
                width: boxRect.width / scale, height: boxRect.height / scale
            };
        }
        const dataURL = signaturePadCanvasEl.toDataURL('image/png'); 
        const signatureImgElement = document.createElement('img');
        signatureImgElement.className = 'embedded-signature'; signatureImgElement.src = dataURL;
        const sigPageX = activeSignatureBoxInfo.x; const sigPageY = activeSignatureBoxInfo.y;
        const sigPageWidth = activeSignatureBoxInfo.width; const sigPageHeight = activeSignatureBoxInfo.height;
        const signatureInfo = {
            element: signatureImgElement, page: activeSignatureBoxInfo.page,     
            x: sigPageX, y: sigPageY, width: sigPageWidth, height: sigPageHeight, dataURL: dataURL       
        };
        embeddedSignatures.push(signatureInfo); 
        pdfViewer.appendChild(signatureImgElement); 
        signatureBoxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null; 
        if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
        repositionSignatures(); 
    }

    // --- Reposicionar Firmas Incrustadas (como estaban en tu c√≥digo) ---
    function repositionSignatures() {
        if (!pdfViewer || !canvas) return;
        const viewerRect = pdfViewer.getBoundingClientRect(); const pdfCanvasRect = canvas.getBoundingClientRect(); 
        const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
        const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;
        embeddedSignatures.forEach(sig => {
            if (sig.element) {
                if (sig.page === currentPage) { 
                    const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                    const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                    const displayWidth = sig.width * scale; const displayHeight = sig.height * scale;
                    sig.element.style.left = `${displayX}px`; sig.element.style.top = `${displayY}px`;
                    sig.element.style.width = `${displayWidth}px`; sig.element.style.height = `${displayHeight}px`;
                    sig.element.style.display = 'block'; 
                } else { sig.element.style.display = 'none'; }
            }
        });
    }
    
    // --- Ajustar Altura del Visor y Eventos Globales (con anclaje) ---
    function adjustViewerHeightAndRender() {
        const headerElement = document.querySelector('header');
        if (headerElement && pdfViewer) {
            const headerHeight = headerElement.offsetHeight;
            pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
        }
        if (pdfDoc) { renderPage(currentPage); } 
        else { if (activeSignatureBoxInfo && activeSignatureBoxInfo.element) { activeSignatureBoxInfo.element.style.display = 'none';} }
    }

    window.addEventListener('mousemove', (e) => { if (isDraggingSigBox || isResizingSigBox) { return; } if (isDraggingPdf && !pinchState.active) { handlePdfMove(e.clientX, e.clientY); } });
    window.addEventListener('touchmove', (e) => { if (isDraggingSigBox || isResizingSigBox) { return; } if (pinchState.active && e.touches.length === 2) { e.preventDefault(); handlePinchMove(e.touches[0], e.touches[1]); } else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) { handlePdfMove(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false });
    window.addEventListener('mouseup', () => { if (isDraggingPdf) { isDraggingPdf = false; canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default'; } });
    window.addEventListener('touchend', (e) => { if (isDraggingPdf) isDraggingPdf = false; if (pinchState.active && e.touches.length < 2) pinchState.active = false; });
    
    window.addEventListener('load', () => {
      adjustViewerHeightAndRender();
      const urlParams = new URLSearchParams(window.location.search);
      const docIdFromUrl = urlParams.get('doc_id');
      const mode = urlParams.get('mode');
      if (docIdFromUrl && mode === 'sign_b') { // Usar 'sign_b' para diferenciar
          console.log(`Modo Firmante (Usuario B): Cargar documento con ID: ${docIdFromUrl}`);
          showMessage(`Modo Firmante (Usuario B) detectado.\nID del Documento: ${docIdFromUrl}\n\n(La funcionalidad del Usuario B para cargar, ver marcadores y firmar a√∫n no est√° implementada en esta versi√≥n.)`);
          document.getElementById('file-input').style.display = 'none';
          // Considera deshabilitar otros botones de Usuario A tambi√©n
          // document.querySelector('button[onclick="addSignatureBox()"]').disabled = true;
          // document.getElementById('share-pdf-btn').disabled = true;
      }
    });
    window.addEventListener('resize', adjustViewerHeightAndRender);

  </script>
</body>
</html>
