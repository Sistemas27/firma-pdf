<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Firmar Documento PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f4f4;
      overflow: hidden; /* Evitar scroll en el body */
    }

    header {
      background: #2c3e50;
      color: white;
      padding: 0.75rem; /* Reducido padding para móviles */
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header h2 {
        margin-top: 0.25rem;
        margin-bottom: 0.5rem; /* Reducido espacio */
        font-size: 1.25rem; /* Ligeramente más pequeño */
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.5rem; /* Solo margen inferior */
      gap: 0.3rem; /* Espacio reducido para móviles */
      width: 100%;
    }

    .toolbar-btn {
      background: #3498db;
      border: none;
      padding: 0.5rem 0.8rem; /* Ajustado padding */
      margin: 0.2rem;
      color: white;
      font-size: 0.85rem; /* Ligeramente más pequeño */
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      flex-grow: 1; /* Permitir que los botones crezcan */
      flex-basis: auto; /* Base automática */
      min-width: 100px; /* Ancho mínimo para evitar que se encojan demasiado */
    }
    .toolbar-btn:hover {
        background-color: #2980b9;
    }

    #pdf-viewer {
      width: 100vw;
      /* La altura se ajusta dinámicamente con JS */
      overflow: hidden;
      background: #fff;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none; /* Importante para el paneo táctil del PDF y pinch-zoom */
    }

    #pdf-canvas {
      cursor: grab;
      /* El tamaño se establece por JS */
    }

    #page-info {
      text-align: center;
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
      font-size: 0.85rem;
    }

    #zoom-slider-container {
      position: fixed;
      right: 5px; /* Más cerca del borde en móviles */
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.1); /* Ligeramente más visible */
      padding: 5px;
      border-radius: 8px;
      z-index: 9999;
    }

    #zoom-slider {
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      width: 18px; /* Más delgado */
      height: 120px; /* Más corto */
      transform: rotate(180deg);
    }

    input[type="file"]#file-input {
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ccc; /* Borde más claro */
      background-color: #fff;
      color: #333;
      cursor: pointer;
      font-size: 0.85rem;
      width: 100%; /* Ocupar ancho disponible en la toolbar */
      max-width: 280px; /* Máximo ancho */
      margin: 0.2rem;
    }
    input[type="file"]#file-input::file-selector-button {
        background: #5dade2; /* Color ligeramente diferente */
        color: white;
        border: none;
        padding: 0.5rem 0.8rem;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 8px;
    }

    .signature-box {
      position: absolute;
      border: 2px dashed #3498db;
      background-color: rgba(52, 152, 219, 0.15); /* Ligeramente más opaco */
      cursor: move;
      z-index: 100;
      touch-action: none; /* Para permitir arrastre táctil del cuadro */
    }

    .signature-box-controls {
      position: absolute;
      top: -35px; /* Un poco más arriba para no solapar con manijas en pantallas pequeñas */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px; /* Más espacio */
      padding: 3px;
      background-color: rgba(255, 255, 255, 0.85);
      border-radius: 6px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.2);
    }

    .signature-box-btn {
      width: 28px; /* Más grandes para táctil */
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px; /* Íconos más grandes */
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .signature-box-btn.confirm { background-color: #2ecc71; color: white; }
    .signature-box-btn.cancel { background-color: #e74c3c; color: white; }

    .resize-handle {
      position: absolute;
      width: 12px; /* Ligeramente más grandes para táctil */
      height: 12px;
      background-color: #3498db;
      border: 1.5px solid white;
      border-radius: 50%;
      z-index: 101;
    }
    .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

    .signature-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 10px; /* Espacio por si el contenido es muy grande */
    }

    .signature-container {
      background-color: white;
      padding: 15px; /* Menos padding en móviles */
      border-radius: 8px;
      width: 100%; /* Ocupar el ancho del padding del modal */
      max-width: 500px;
      height: auto;
      max-height: 90vh; /* Un poco más de altura permitida */
      display: flex;
      flex-direction: column;
    }

    .signature-canvas-container {
      flex-grow: 1;
      border: 1px solid #b0bec5; /* Borde más suave */
      margin-bottom: 10px;
      position: relative;
      min-height: 180px; /* Ajustado para móviles */
      border-radius: 4px; /* Bordes redondeados */
      overflow: hidden; /* Para que el canvas no se salga */
    }

    #signature-canvas {
      width: 100%;
      height: 100%;
      background-color: #ffffff;
      cursor: crosshair;
      touch-action: none;
    }

    .signature-controls {
      display: flex;
      justify-content: space-between; /* Distribuir mejor */
      flex-wrap: wrap;
      gap: 8px;
    }

    .signature-control-btn {
      padding: 10px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem; /* Ligeramente más pequeño */
      flex-grow: 1;
      min-width: 90px;
      text-align: center;
      transition: background-color 0.2s ease;
    }
    .signature-control-btn.cancel { background-color: #ef5350; color: white; }
    .signature-control-btn.clear { background-color: #ffab40; color: white; }
    .signature-control-btn.confirm { background-color: #4caf50; color: white; }
    .signature-control-btn:hover { filter: brightness(110%); }


    .embedded-signature {
      position: absolute;
      z-index: 99;
      pointer-events: none;
      transform-origin: top left;
    }

    .message-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        padding: 15px;
    }
    .message-modal-content {
        background-color: white;
        padding: 20px 25px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        max-width: 400px;
        width: 100%;
    }
    .message-modal-content p {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1rem;
        color: #333;
    }
    .message-modal-content button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 25px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.95rem;
        transition: background-color 0.2s ease;
    }
    .message-modal-content button:hover {
        background-color: #2980b9;
    }

  </style>
</head>
<body>
  <header>
    <h2>Firmar Documento PDF</h2>
    <div id="toolbar">
      <input type="file" id="file-input" accept="application/pdf" />
      <button class="toolbar-btn" onclick="prevPage()">⬅️ Anterior</button>
      <button class="toolbar-btn" onclick="nextPage()">➡️ Siguiente</button>
      <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
      <button class="toolbar-btn" onclick="downloadPDF()">📂 Guardar</button>
      </div>
    <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
  </header>

  <div id="pdf-viewer">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <div id="zoom-slider-container">
    <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
  </div>

  <script>
    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1;
    let canvas = document.getElementById('pdf-canvas');
    let context = canvas.getContext('2d');
    const pdfViewer = document.getElementById('pdf-viewer'); // Get pdfViewer element
    let rendering = false;
    
    let isDraggingPdf = false;
    let startPos = { x: 0, y: 0 }; // For single-touch/mouse PDF dragging
    let translatePos = { x: 0, y: 0 };
    // let lastTouchPos = { x: 0, y: 0 }; // No longer needed with new pinch logic
    let isZoomed = false; // Indicates if PDF can be panned
    
    let embeddedSignatures = [];
    let isDraggingBox = false; 
    let signatureBoxDragOffset = { x: 0, y: 0 }; 

    // State for pinch-to-zoom
    let pinchState = {
        active: false,
        initialDistance: 0,
        lastScale: 1, // Stores the scale at the beginning of the pinch
        pdfPointX: 0, // Point on the PDF (unscaled) under the initial pinch center X
        pdfPointY: 0, // Point on the PDF (unscaled) under the initial pinch center Y
        screenCenterX: 0, // Initial screen X coordinate of the pinch center
        screenCenterY: 0  // Initial screen Y coordinate of the pinch center
    };


    // Función para mostrar mensajes modales
    function showMessage(message) {
        const existingModal = document.querySelector('.message-modal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.className = 'message-modal';
        const content = document.createElement('div');
        content.className = 'message-modal-content';
        content.innerHTML = `<p>${message}</p><button>OK</button>`;
        modal.appendChild(content);
        document.body.appendChild(modal);
        content.querySelector('button').onclick = () => modal.remove();
    }

    document.getElementById('file-input').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'application/pdf') {
        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                 pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            }
            const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;
            currentPage = 1;
            translatePos = { x: 0, y: 0 };
            scale = 1;
            document.getElementById('zoom-slider').value = scale;
            document.getElementById('total-pages').textContent = totalPages;
            embeddedSignatures = [];
            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
            if (signatureBox) {
                signatureBox.remove();
                signatureBox = null;
            }
            renderPage(currentPage);
          } catch (err) {
            showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
            console.error("Error loading PDF:", err);
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file) {
        showMessage('Por favor, selecciona un archivo PDF.');
      }
    });

    function renderPage(num) {
      if (!pdfDoc || rendering) return;
      rendering = true;
      pdfDoc.getPage(num).then(page => {
        const viewport = page.getViewport({ scale: scale });
        
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;

        // Center canvas if smaller than viewer (important for initial render and after zoom out)
        if (viewport.width < viewerWidth) {
            canvas.style.left = `${(viewerWidth - viewport.width) / 2}px`;
        } else {
            canvas.style.left = '0px';
        }
        if (viewport.height < viewerHeight) {
            canvas.style.top = `${(viewerHeight - viewport.height) / 2}px`;
        } else {
            canvas.style.top = '0px';
        }
        canvas.style.position = 'absolute';

        const renderContext = { canvasContext: context, viewport };
        const renderTask = page.render(renderContext);
        
        renderTask.promise.then(() => {
          rendering = false;
          document.getElementById('current-page').textContent = num;
          // Update isZoomed: can pan if content wider/taller than viewer OR if explicitly zoomed (scale !== 1)
          isZoomed = scale !== 1 || viewport.width > viewerWidth || viewport.height > viewerHeight;
          updateCanvasTransform(); // Applies translatePos
          repositionSignatures();
        }).catch(err => {
            rendering = false;
            console.error("Error rendering page:", err);
            showMessage("Error al renderizar la página del PDF.");
        });
      }).catch(err => {
          rendering = false;
          console.error("Error getting page:", err);
          showMessage("Error al obtener la página del PDF.");
      });
    }

    function updateCanvasTransform() {
        // The canvas's own left/top style handles centering when smaller than viewer.
        // translatePos is an additional offset from that centered/top-left position.
        canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
        repositionSignatures();
    }

    // Arrastre del PDF (Mouse on canvas)
    canvas.addEventListener('mousedown', (e) => {
      if (pinchState.active) return; // Don't drag if pinching
      // Allow dragging if zoomed or content overflows
      if (!isZoomed && (canvas.width <= pdfViewer.clientWidth && canvas.height <= pdfViewer.clientHeight)) return;
      if (e.target !== canvas) return; // Only drag if click is directly on canvas

      isDraggingPdf = true;
      startPos = { x: e.clientX - translatePos.x,  y: e.clientY - translatePos.y };
      canvas.style.cursor = 'grabbing';
    });
    
    // Touch event listeners on pdfViewer for PDF drag and pinch-zoom
    pdfViewer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) { // PINCH START
            e.preventDefault(); // Prevent default browser pinch zoom/scroll
            isDraggingPdf = false; 
            isResizing = false; 
            isDraggingBox = false;

            pinchState.active = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            pinchState.lastScale = scale; // Store scale at the beginning of this pinch

            const viewerRect = pdfViewer.getBoundingClientRect();
            pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
            pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
            
            // Calculate the point on the PDF (unscaled coordinates) that is under the pinch center
            // This needs to account for the canvas's own offset (canvas.offsetLeft/Top) if it's centered
            const canvasRect = canvas.getBoundingClientRect();
            const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
            const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;

            pinchState.pdfPointX = pdfPointScreenX / scale;
            pinchState.pdfPointY = pdfPointScreenY / scale;

        } else if (e.touches.length === 1 && !pinchState.active) { // SINGLE TOUCH PDF DRAG START
            // Allow dragging if zoomed or content overflows, and target is the canvas itself
            if ((!isZoomed && (canvas.width <= pdfViewer.clientWidth && canvas.height <= pdfViewer.clientHeight)) || e.target !== canvas) {
                 isDraggingPdf = false; return;
            }
            // e.preventDefault(); // Only if it causes issues, generally not needed for simple drag
            isDraggingPdf = true;
            const touch = e.touches[0];
            startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
        }
    }, { passive: false });


    function handlePdfMove(clientX, clientY) {
        if (!isDraggingPdf) return;
        
        let newTranslateX = clientX - startPos.x;
        let newTranslateY = clientY - startPos.y;
        
        const viewerWidth = pdfViewer.clientWidth;
        const viewerHeight = pdfViewer.clientHeight;
        const canvasWidth = canvas.width; // This is already scaled viewport width
        const canvasHeight = canvas.height; // This is already scaled viewport height

        const overpanMargin = 30; // Reduced overpan

        // Horizontal panning constraints
        if (canvasWidth > viewerWidth) {
            const minX = viewerWidth - canvasWidth - overpanMargin;
            const maxX = overpanMargin;
            newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
        } else {
            newTranslateX = 0; // No horizontal pan if canvas fits
        }

        // Vertical panning constraints
        if (canvasHeight > viewerHeight) {
            const minY = viewerHeight - canvasHeight - overpanMargin;
            const maxY = overpanMargin;
            newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
        } else {
            newTranslateY = 0; // No vertical pan if canvas fits
        }
        
        translatePos.x = newTranslateX;
        translatePos.y = newTranslateY;
        updateCanvasTransform();
    }

    function handlePinchMove(touch1, touch2) {
        if (!pinchState.active || pinchState.initialDistance === 0) return;

        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
        newScale = Math.min(3.0, Math.max(0.5, newScale)); // Clamp scale

        const oldScale = scale; // Scale before this move event
        scale = newScale; // Update global scale

        // The screen center of the pinch should remain over the same point on the PDF.
        // pinchState.pdfPointX/Y is the target point on the unscaled PDF.
        // pinchState.screenCenterX/Y is the target screen position for that PDF point.
        
        // We need the canvas's current offset within the viewer to correctly calculate the new translatePos
        // because canvas.style.left/top might be non-zero if the canvas is centered.
        const canvasRect = canvas.getBoundingClientRect();
        const viewerRect = pdfViewer.getBoundingClientRect();
        const canvasCurrentScreenLeft = canvasRect.left - viewerRect.left; // Canvas X relative to viewer
        const canvasCurrentScreenTop = canvasRect.top - viewerRect.top;   // Canvas Y relative to viewer

        // The new position of (pdfPointX * scale, pdfPointY * scale) on the scaled canvas
        // should align with (pinchState.screenCenterX - viewerRect.left - canvas.offsetLeft, pinchState.screenCenterY - viewerRect.top - canvas.offsetTop)
        // translatePos.x is the translation of the canvas content *relative to its own 0,0 (which might be offset by canvas.style.left/top)*

        translatePos.x = (pinchState.screenCenterX - viewerRect.left - canvas.offsetLeft) - (pinchState.pdfPointX * scale);
        translatePos.y = (pinchState.screenCenterY - viewerRect.top - canvas.offsetTop) - (pinchState.pdfPointY * scale);
        
        document.getElementById('zoom-slider').value = scale.toFixed(1);
        renderPage(currentPage); // This will re-render with new scale, set new canvas.width/height,
                                 // re-center canvas via style.left/top if needed, and then apply translatePos.
    }


    // Global move listeners
    window.addEventListener('mousemove', (e) => {
        if (isDraggingPdf && !pinchState.active) handlePdfMove(e.clientX, e.clientY);
        if (isResizing) handleResizeMove(e.clientX, e.clientY); // Assumes isResizing is true
        if (isDraggingBox) handleBoxDragMove(e.clientX, e.clientY); // Assumes isDraggingBox is true
    });

    window.addEventListener('touchmove', (e) => {
        if (pinchState.active && e.touches.length === 2) {
            e.preventDefault(); 
            handlePinchMove(e.touches[0], e.touches[1]);
        } else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) {
            // e.preventDefault(); // Optional: if single touch drag causes page scroll
            const touch = e.touches[0];
            handlePdfMove(touch.clientX, touch.clientY);
        } else if (isResizing && e.touches.length === 1 && !pinchState.active) {
            e.preventDefault();
            const touch = e.touches[0];
            handleResizeMove(touch.clientX, touch.clientY);
        } else if (isDraggingBox && e.touches.length === 1 && !pinchState.active) {
            e.preventDefault();
            const touch = e.touches[0];
            handleBoxDragMove(touch.clientX, touch.clientY);
        }
    }, { passive: false });

    // Global end listeners
    window.addEventListener('mouseup', () => {
        if (isDraggingPdf) {
            isDraggingPdf = false;
            canvas.style.cursor = (isZoomed || (canvas.width > pdfViewer.clientWidth || canvas.height > pdfViewer.clientHeight)) ? 'grab' : 'default';
        }
        if (isDraggingBox) isDraggingBox = false;
        if (isResizing) { isResizing = false; resizeHandleType = null;}
        // Pinch state is reset by touch count in touchend
    });
    window.addEventListener('touchend', (e) => {
        if (isDraggingPdf) {
            isDraggingPdf = false;
        }
        if (isDraggingBox) isDraggingBox = false;
        if (isResizing) { isResizing = false; resizeHandleType = null; }
        
        if (pinchState.active && e.touches.length < 2) {
            pinchState.active = false;
            // No need to reset other pinchState values here, they get re-init on next pinch start
        }
    });


    function nextPage() {
      if (!pdfDoc || currentPage >= totalPages) return;
      currentPage++;
      translatePos = { x: 0, y: 0 }; // Reset pan on page change
      renderPage(currentPage);
    }

    function prevPage() {
      if (!pdfDoc || currentPage <= 1) return;
      currentPage--;
      translatePos = { x: 0, y: 0 }; // Reset pan on page change
      renderPage(currentPage);
    }

    document.getElementById('zoom-slider').addEventListener('input', function () {
      if (!pdfDoc) return;
      scale = parseFloat(this.value);
      // When changing scale with slider, we want to zoom towards center of viewer
      // This requires adjusting translatePos similar to pinch zoom logic, but simpler:
      // 1. Get current center of the PDF content on screen.
      // 2. Calculate what translatePos would make this point stay centered after new scale.
      const viewerRect = pdfViewer.getBoundingClientRect();
      const oldScale = pinchState.lastScale || 1; // A bit of a hack, need a reliable oldScale

      // For slider zoom, let's try to zoom to the center of the current view of the PDF content
      const currentCanvasRect = canvas.getBoundingClientRect();
      const visiblePdfCenterX = viewerRect.left + viewerRect.width / 2;
      const visiblePdfCenterY = viewerRect.top + viewerRect.height / 2;

      // Point on PDF (unscaled) that is currently at the center of the viewer
      const pdfPointX = (visiblePdfCenterX - currentCanvasRect.left) / oldScale;
      const pdfPointY = (visiblePdfCenterY - currentCanvasRect.top) / oldScale;
      
      // Calculate new translatePos to keep this pdfPoint at the center of the viewer
      // This needs to consider that canvas.offsetLeft/Top might change after renderPage
      // This is complex. A simpler slider zoom just scales, then user re-pans.
      // For now, let slider zoom be simple, without translatePos adjustment. User can re-pan.
      // TODO: Implement centered zoom for slider if desired.
      
      renderPage(currentPage);
      pinchState.lastScale = scale; // Update for next potential pinch
    });

    pdfViewer.addEventListener('wheel', function (e) {
      if (!pdfDoc) return;
      e.preventDefault();
      
      const oldScale = scale;
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      let newScale = parseFloat((scale + delta).toFixed(1)); // Keep to one decimal place
      newScale = Math.min(3.0, Math.max(0.5, newScale));
      
      if (newScale === oldScale) return; // No change, no re-render

      // Zoom towards mouse pointer
      const viewerRect = pdfViewer.getBoundingClientRect();
      const mouseXViewer = e.clientX - viewerRect.left; // Mouse X relative to viewer
      const mouseYViewer = e.clientY - viewerRect.top; // Mouse Y relative to viewer

      // Point on PDF (unscaled) under the mouse pointer
      // Needs to account for canvas's own offset (style.left/top) and current translatePos
      const canvasRect = canvas.getBoundingClientRect(); // Current position of canvas on screen
      const mouseXOnCanvas = e.clientX - canvasRect.left; // Mouse X relative to displayed canvas
      const mouseYOnCanvas = e.clientY - canvasRect.top; // Mouse Y relative to displayed canvas

      const pdfPointX = mouseXOnCanvas / oldScale;
      const pdfPointY = mouseYOnCanvas / oldScale;

      scale = newScale; // Update global scale

      // New translatePos to keep pdfPoint under the mouse pointer (mouseXViewer, mouseYViewer)
      // translatePos.x = mouseXViewer - (pdfPointX * scale) - parseFloat(canvas.style.left || 0)
      // translatePos.y = mouseYViewer - (pdfPointY * scale) - parseFloat(canvas.style.top || 0)
      // The canvas.style.left/top is applied by renderPage. translatePos is relative to that.
      // So, the target screen position for the scaled pdfPoint is (mouseXViewer - canvas.offsetLeft).
      translatePos.x = (mouseXViewer - parseFloat(canvas.style.left || 0)) - (pdfPointX * scale);
      translatePos.y = (mouseYViewer - parseFloat(canvas.style.top || 0)) - (pdfPointY * scale);


      document.getElementById('zoom-slider').value = scale.toFixed(1);
      renderPage(currentPage);
    }, { passive: false });

    async function downloadPDF() {
        if (!pdfDoc) {
            showMessage("Carga un PDF primero.");
            return;
        }
        const { jsPDF } = window.jspdf;
        const newPdfDocGen = new jsPDF(); // Renamed to avoid conflict
        while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }
        
        showMessage("Preparando PDF para descarga...");

        for (let i = 1; i <= totalPages; i++) {
            const page = await pdfDoc.getPage(i);
            const viewport = page.getViewport({ scale: 2 }); 

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;

            await page.render({ canvasContext: tempCtx, viewport }).promise;

            embeddedSignatures.filter(sig => sig.page === i).forEach(sigInfo => {
                const img = new Image();
                img.src = sigInfo.dataURL;
                const x = sigInfo.x * 2; 
                const y = sigInfo.y * 2;
                const width = sigInfo.width * 2;
                const height = sigInfo.height * 2;
                tempCtx.drawImage(img, x, y, width, height);
            });
            
            const imgData = tempCanvas.toDataURL('image/jpeg', 0.85); 
            
            newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
            newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
        }
        
        newPdfDocGen.save('documento-firmado.pdf');
        showMessage("PDF guardado.");
    }

    // ========== SISTEMA DE FIRMA DIGITAL ==========
    let signatureBox = null;
    let isResizing = false;
    let resizeHandleType = null;
    let startBoxPos = { x: 0, y: 0 };
    let startBoxSize = { width: 0, height: 0 };
    let startPointerPos = { x: 0, y: 0 }; 

    let signatureModal = null;
    let signaturePadCanvas = null; 
    let signaturePadCtx = null;
    let isDrawingOnPad = false;
    let lastDrawPadPos = { x: 0, y: 0 };


    function addSignatureBox() {
      if (!pdfDoc) {
        showMessage("Por favor, carga un documento PDF primero.");
        return;
      }
      if (signatureBox) { signatureBox.remove(); }

      signatureBox = document.createElement('div');
      signatureBox.className = 'signature-box';
      signatureBox.style.width = '150px'; 
      signatureBox.style.height = '75px';
      
      const viewerRect = pdfViewer.getBoundingClientRect();
      
      signatureBox.style.left = `${(viewerRect.width - 150) / 2}px`;
      signatureBox.style.top = `${(viewerRect.height - 75) / 2}px`;

      const controls = document.createElement('div');
      controls.className = 'signature-box-controls';
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-box-btn confirm';
      confirmBtn.innerHTML = '✔️';
      confirmBtn.title = 'Confirmar posición y firmar';
      confirmBtn.onclick = openSignatureModal;
      
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-box-btn cancel';
      cancelBtn.innerHTML = '❌';
      cancelBtn.title = 'Cancelar firma';
      cancelBtn.onclick = () => { signatureBox.remove(); signatureBox = null; };

      controls.appendChild(confirmBtn);
      controls.appendChild(cancelBtn);
      signatureBox.appendChild(controls);

      addResizeHandles(signatureBox);
      setupBoxDragEvents(signatureBox);

      pdfViewer.appendChild(signatureBox);
    }

    function addResizeHandles(box) {
      const handles = ['nw', 'ne', 'sw', 'se'];
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        box.appendChild(handle);
        
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          initResize(e.clientX, e.clientY, pos, box);
        });
        handle.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          if (e.touches.length === 1) {
            e.preventDefault(); // Prevent page scroll when dragging handles
            initResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
          }
        }, { passive: false });
      });
    }

    function initResize(clientX, clientY, handlePos, box) {
        isResizing = true;
        resizeHandleType = handlePos;
        startBoxPos = { x: box.offsetLeft, y: box.offsetTop };
        startBoxSize = { width: box.offsetWidth, height: box.offsetHeight };
        startPointerPos = { x: clientX, y: clientY };
        isDraggingPdf = false; 
        isDraggingBox = false; 
        pinchState.active = false; // Ensure pinch is not active
    }
    
    function handleResizeMove(clientX, clientY) {
        if (!isResizing || !resizeHandleType || !signatureBox) return;

        const deltaX = clientX - startPointerPos.x;
        const deltaY = clientY - startPointerPos.y;
        
        let newWidth = startBoxSize.width;
        let newHeight = startBoxSize.height;
        let newLeft = startBoxPos.x;
        let newTop = startBoxPos.y;

        const minWidth = 50;
        const minHeight = 30;
        const viewerRect = pdfViewer.getBoundingClientRect();

        if (resizeHandleType.includes('w')) { newWidth = Math.max(minWidth, startBoxSize.width - deltaX); newLeft = startBoxPos.x + (startBoxSize.width - newWidth); }
        if (resizeHandleType.includes('e')) { newWidth = Math.max(minWidth, startBoxSize.width + deltaX); }
        if (resizeHandleType.includes('n')) { newHeight = Math.max(minHeight, startBoxSize.height - deltaY); newTop = startBoxPos.y + (startBoxSize.height - newHeight); }
        if (resizeHandleType.includes('s')) { newHeight = Math.max(minHeight, startBoxSize.height + deltaY); }

        if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
        if (newTop < 0) { newHeight += newTop; newTop = 0; }
        if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
        if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }
        
        newWidth = Math.max(minWidth, newWidth);
        newHeight = Math.max(minHeight, newHeight);

        signatureBox.style.width = `${newWidth}px`;
        signatureBox.style.height = `${newHeight}px`;
        signatureBox.style.left = `${newLeft}px`;
        signatureBox.style.top = `${newTop}px`;
    }

    // Arrastre del cuadro de firma (signatureBox)
    function setupBoxDragEvents(box) {
        function initBoxDrag(clientX, clientY) {
            isDraggingBox = true;
            const viewerRect = pdfViewer.getBoundingClientRect();
            signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
            signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;
            isDraggingPdf = false; 
            isResizing = false; 
            pinchState.active = false; // Ensure pinch is not active
        }

        box.addEventListener('mousedown', (e) => {
            if (e.target === box) { 
                e.stopPropagation();
                initBoxDrag(e.clientX, e.clientY);
            }
        });
        box.addEventListener('touchstart', (e) => {
            if (e.target === box && e.touches.length === 1) {
                e.stopPropagation();
                e.preventDefault(); // Prevent page scroll when dragging box
                initBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
    }
    
    function handleBoxDragMove(clientX, clientY) {
        if (!isDraggingBox || !signatureBox) return;
        const viewerRect = pdfViewer.getBoundingClientRect();

        let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
        let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;

        newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBox.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBox.offsetHeight));

        signatureBox.style.left = `${newLeft}px`;
        signatureBox.style.top = `${newTop}px`;
    }

    function openSignatureModal() {
      if (!signatureBox) return;
      
      signatureModal = document.createElement('div');
      signatureModal.className = 'signature-modal';
      
      const container = document.createElement('div');
      container.className = 'signature-container';
      
      const canvasContainer = document.createElement('div');
      canvasContainer.className = 'signature-canvas-container';
      
      signaturePadCanvas = document.createElement('canvas'); 
      signaturePadCanvas.id = 'signature-canvas'; 
      
      canvasContainer.appendChild(signaturePadCanvas);
      container.appendChild(canvasContainer);
      
      signaturePadCtx = signaturePadCanvas.getContext('2d');
      
      const controls = document.createElement('div');
      controls.className = 'signature-controls';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'signature-control-btn cancel';
      cancelBtn.textContent = '❌ Cancelar';
      cancelBtn.onclick = () => { signatureModal.remove(); signatureModal = null; };
      
      const clearBtn = document.createElement('button');
      clearBtn.className = 'signature-control-btn clear';
      clearBtn.textContent = '↩️ Limpiar';
      clearBtn.onclick = () => { signaturePadCtx.clearRect(0, 0, signaturePadCanvas.width, signaturePadCanvas.height); };
      
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'signature-control-btn confirm';
      confirmBtn.textContent = '✔️ Firmar';
      confirmBtn.onclick = embedSignature;
      
      controls.appendChild(cancelBtn);
      controls.appendChild(clearBtn);
      controls.appendChild(confirmBtn);
      container.appendChild(controls);
      
      signatureModal.appendChild(container);
      document.body.appendChild(signatureModal);

      requestAnimationFrame(() => { 
        const rect = canvasContainer.getBoundingClientRect();
        signaturePadCanvas.width = rect.width; 
        signaturePadCanvas.height = rect.height; 
        signaturePadCtx.lineWidth = 2; 
        signaturePadCtx.lineCap = 'round';
        signaturePadCtx.strokeStyle = '#000000';
      });
      
      setupSignaturePadDrawingEvents();
    }

    function setupSignaturePadDrawingEvents() {
      function getPadPosition(e) {
        const rect = signaturePadCanvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.type.startsWith('touch')) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
          x: (clientX - rect.left) * (signaturePadCanvas.width / rect.width),
          y: (clientY - rect.top) * (signaturePadCanvas.height / rect.height)
        };
      }

      function startPadDraw(e) {
        e.preventDefault(); 
        isDrawingOnPad = true;
        lastDrawPadPos = getPadPosition(e);
      }

      function drawOnPad(e) {
        if (!isDrawingOnPad) return;
        e.preventDefault();
        const currentPos = getPadPosition(e);
        signaturePadCtx.beginPath();
        signaturePadCtx.moveTo(lastDrawPadPos.x, lastDrawPadPos.y);
        signaturePadCtx.lineTo(currentPos.x, currentPos.y);
        signaturePadCtx.stroke();
        lastDrawPadPos = currentPos;
      }

      function stopPadDraw() {
        isDrawingOnPad = false;
      }

      signaturePadCanvas.addEventListener('mousedown', startPadDraw);
      signaturePadCanvas.addEventListener('mousemove', drawOnPad);
      signaturePadCanvas.addEventListener('mouseup', stopPadDraw);
      signaturePadCanvas.addEventListener('mouseout', stopPadDraw);
      
      signaturePadCanvas.addEventListener('touchstart', startPadDraw, { passive: false });
      signaturePadCanvas.addEventListener('touchmove', drawOnPad, { passive: false });
      signaturePadCanvas.addEventListener('touchend', stopPadDraw);
    }

    function embedSignature() {
        if (!signatureBox || !signaturePadCanvas || signaturePadCtx.canvas.toDataURL() === document.createElement('canvas').toDataURL()) {
            showMessage("Por favor, dibuja una firma primero.");
            return;
        }

        const dataURL = signaturePadCanvas.toDataURL('image/png');
        const signatureImgElement = document.createElement('img');
        signatureImgElement.className = 'embedded-signature';
        signatureImgElement.src = dataURL;

        const viewerRect = pdfViewer.getBoundingClientRect();
        const pdfCanvasRect = canvas.getBoundingClientRect();

        const boxLeftInViewer = signatureBox.offsetLeft; 
        const boxTopInViewer = signatureBox.offsetTop;

        // Position of the signature box relative to the PDF canvas content (considering its current scale and translation)
        // The canvas itself might be offset (canvas.offsetLeft/Top) if it's centered in the viewer.
        // And then it's translated by translatePos.x/y
        const sigXOnScaledCanvas = boxLeftInViewer - (canvas.offsetLeft + translatePos.x);
        const sigYOnScaledCanvas = boxTopInViewer - (canvas.offsetTop + translatePos.y);


        const sigPageX = sigXOnScaledCanvas / scale;
        const sigPageY = sigYOnScaledCanvas / scale;
        const sigPageWidth = signatureBox.offsetWidth / scale;
        const sigPageHeight = signatureBox.offsetHeight / scale;

        const signatureInfo = {
            element: signatureImgElement, page: currentPage,
            x: sigPageX, y: sigPageY, width: sigPageWidth, height: sigPageHeight,
            dataURL: dataURL
        };
        embeddedSignatures.push(signatureInfo);
        pdfViewer.appendChild(signatureImgElement);

        signatureBox.remove(); signatureBox = null;
        if (signatureModal) { signatureModal.remove(); signatureModal = null; }
        repositionSignatures();
    }

    function repositionSignatures() {
        if (!pdfViewer) return;
        const viewerRect = pdfViewer.getBoundingClientRect();
        const pdfCanvasRect = canvas.getBoundingClientRect(); // Current on-screen position of the PDF canvas

        // The PDF canvas's top-left corner on the screen, relative to the viewer.
        // This includes its own centering (style.left/top) and its transform:translate.
        const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
        const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;

        embeddedSignatures.forEach(sig => {
            if (sig.element) {
                if (sig.page === currentPage) {
                    // Calculate display position based on the PDF canvas's current screen position
                    const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                    const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                    const displayWidth = sig.width * scale;
                    const displayHeight = sig.height * scale;

                    sig.element.style.left = `${displayX}px`;
                    sig.element.style.top = `${displayY}px`;
                    sig.element.style.width = `${displayWidth}px`;
                    sig.element.style.height = `${displayHeight}px`;
                    sig.element.style.display = 'block';
                } else {
                    sig.element.style.display = 'none';
                }
            }
        });
    }

    function adjustViewerHeightAndRender() {
        const headerElement = document.querySelector('header');
        if (headerElement && pdfViewer) {
            const headerHeight = headerElement.offsetHeight;
            pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
        }
        if (pdfDoc) { renderPage(currentPage); }
    }

    window.addEventListener('load', adjustViewerHeightAndRender);
    window.addEventListener('resize', adjustViewerHeightAndRender);

  </script>
</body>
</html>
