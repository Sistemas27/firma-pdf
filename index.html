<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Firmar Documento PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --primary-color: #3B82F6; /* Azul Tailwind 500 */
            --primary-hover-color: #2563EB; /* Azul Tailwind 600 */
            --secondary-color: #6B7280; /* Gris Tailwind 500 */
            --secondary-hover-color: #4B5563; /* Gris Tailwind 600 */
            --header-bg: #2C3E50; /* Azul Pizarra Oscuro */
            --header-text-color: #ECF0F1; /* Nubes (casi blanco) */
            --body-bg-color: #F4F7F9; /* Gris Muy Claro */
            --container-bg-color: #FFFFFF;
            --text-color-dark: #34495E; /* Asfalto Húmedo */
            --text-color-medium: #7F8C8D; /* Gris Plata */
            --text-color-light: #BDC3C7; /* Plata */
            --success-color: #2ECC71; /* Esmeralda */
            --danger-color: #E74C3C; /* Alizarina */
            --warning-color: #F39C12; /* Naranja */
            --info-color: #3498DB; /* Azul Peter River */
            --border-color: #D1D5DB; /* Gris Tailwind 300 */
            --border-radius: 0.375rem; /* 6px */
            --box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --box-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Cambiado para que el header esté arriba */
            min-height: 100vh;
            margin: 0;
            background-color: var(--body-bg-color);
            color: var(--text-color-dark);
            box-sizing: border-box;
            text-align: center;
            overflow: hidden; /* Evita el scroll en el body, el visor lo manejará */
        }
        
        /* Estilos para la página inicial (si se muestra antes de cargar PDF) */
        .initial-container { /* Renombrado de .container para evitar conflictos */
            background-color: var(--container-bg-color);
            padding: 25px 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-lg);
            max-width: 450px;
            width: 90%;
            margin-top: 50px; /* Espacio desde arriba */
        }

        .initial-container h1 {
            color: var(--header-bg);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5rem; /* Un poco más grande */
            font-weight: 600;
        }

        .initial-container p {
            color: var(--text-color-medium);
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        #qr-code-display {
            margin: 20px auto;
            border: 1px solid var(--border-color);
            padding: 8px;
            background-color: var(--container-bg-color);
            display: inline-block;
            box-shadow: var(--box-shadow);
            width: 166px; 
            height: 166px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--border-radius);
        }

        #qr-code-display img {
            max-width: 100%;
            max-height: 100%;
            border-radius: calc(var(--border-radius) - 4px); /* Para que encaje bien */
        }

        .url-section {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .url-section p {
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color-dark);
            font-size: 0.9rem;
        }

        #shareable-url-input { /* Estilo reutilizado en el modal de mensajes */
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            background-color: #F9FAFB; /* Gris Tailwind 50 */
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            margin-bottom: 10px;
            color: var(--text-color-dark);
        }
        #shareable-url-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }


        #status-message { /* Generalmente no visible si se usan modales */
            margin-top: 15px;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--info-color);
        }

        /* Estilos de la aplicación principal de firma */
        * { box-sizing: border-box; }

        header {
            background: var(--header-bg);
            color: var(--header-text-color);
            padding: 0.75rem 1rem; /* Padding ajustado */
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative; 
            z-index: 1000; 
            width: 100%; /* Ocupa todo el ancho */
        }

        header h2 {
            margin-top: 0.2rem;
            margin-bottom: 0.75rem; /* Más espacio */
            font-size: 1.3rem; /* Más prominente */
            font-weight: 600;
        }

        .navigation-toolbar {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 400px; 
            margin: 0 auto 0.5rem auto;
        }

        #page-info {
            margin: 0 1rem; /* Más espacio */
            font-size: 0.85rem;
            white-space: nowrap;
            color: var(--text-color-light);
        }

        #toolbar {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            gap: 0.5rem; /* Espacio entre botones */
            width: 100%;
        }

        .toolbar-btn {
            background: var(--primary-color);
            border: none;
            padding: 0.5rem 1rem; 
            color: white;
            font-size: 0.85rem; 
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            flex-grow: 0; 
            flex-basis: auto;
            font-weight: 500;
        }
        .toolbar-btn:hover {
            background-color: var(--primary-hover-color);
            box-shadow: 0 0 0 0.2rem rgba(59, 130, 246, 0.25);
            transform: translateY(-1px);
        }
        .toolbar-btn.page-nav-btn {
            padding: 0.45rem 0.8rem; 
            background-color: var(--secondary-color); 
        }
        .toolbar-btn.page-nav-btn:hover {
            background-color: var(--secondary-hover-color);
            box-shadow: 0 0 0 0.2rem rgba(107, 114, 128, 0.25);
        }


        #pdf-viewer {
            width: 100vw;
            /* height será ajustado por JS para ocupar el espacio restante */
            overflow: hidden; 
            background: #E5E7EB; /* Gris Tailwind 200 - fondo del visor */
            position: relative; 
            display: flex; 
            justify-content: center;
            align-items: center;
            touch-action: none; 
            flex-grow: 1; /* Para que ocupe el espacio restante */
        }

        .page-usage-counter {
            position: absolute;
            top: 10px; 
            padding: 5px 10px;
            background-color: rgba(44, 62, 80, 0.7); /* Fondo semi-transparente oscuro */
            color: white;
            font-size: 0.75rem; 
            border-radius: var(--border-radius);
            z-index: 50; 
            box-shadow: var(--box-shadow);
        }
        #current-page-visits { left: 10px; }
        #total-page-views { right: 10px; }


        #pdf-canvas {
            cursor: grab; 
            image-rendering: -webkit-optimize-contrast; 
            image-rendering: crisp-edges; 
            box-shadow: var(--box-shadow-lg); /* Sombra más pronunciada */
        }

        #zoom-slider-container {
            position: fixed; 
            right: 10px; 
            top: 50%; 
            transform: translateY(-50%);
            background: rgba(44, 62, 80, 0.85); /* Más opaco */
            padding: 8px;
            border-radius: var(--border-radius);
            z-index: 9999; 
            box-shadow: var(--box-shadow);
        }

        #zoom-slider {
            writing-mode: bt-lr; 
            -webkit-appearance: slider-vertical; 
            width: 18px; 
            height: 120px; 
            transform: rotate(180deg); 
            cursor: pointer;
        }
        /* Estilos para el thumb del slider (navegadores WebKit) */
        #zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px; /* Más grande para mejor agarre */
            height: 24px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
        }
        /* Estilos para el thumb del slider (Firefox) */
        #zoom-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
        }


        input[type="file"]#file-input {
            padding: 0.45rem 0.6rem;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            background-color: var(--container-bg-color);
            color: var(--text-color-dark);
            cursor: pointer;
            font-size: 0.8rem; 
            max-width: 250px; 
            margin: 0.15rem; 
            transition: border-color 0.2s ease;
        }
        input[type="file"]#file-input:hover {
            border-color: var(--primary-color);
        }
        input[type="file"]#file-input::file-selector-button {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: calc(var(--border-radius) - 2px); /* Un poco más pequeño que el input */
            cursor: pointer;
            margin-right: 10px; 
            transition: background-color 0.2s ease;
            font-weight: 500;
        }
        input[type="file"]#file-input::file-selector-button:hover {
            background-color: var(--secondary-hover-color);
        }

        .signature-box {
            position: absolute;
            border: 2px solid var(--primary-color); 
            background-color: rgba(59, 130, 246, 0.1); 
            cursor: move; 
            z-index: 100; 
            touch-action: none; 
            border-radius: var(--border-radius);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3), var(--box-shadow);
        }
        .signature-box.position-confirmed {
            cursor: default; 
            border: 2px dashed var(--secondary-color); 
            background-color: rgba(107, 114, 128, 0.05); 
            box-shadow: none; 
        }

        .signature-box-controls {
            position: absolute;
            top: -42px; /* Ajustado para botones más grandes */
            left: 50%;
            transform: translateX(-50%); 
            display: flex;
            gap: 10px; 
            padding: 6px;
            background-color: var(--container-bg-color); 
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .signature-box-btn {
            width: 32px; 
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px; 
            border: none;
            color: white;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.2s ease;
        }
        .signature-box-btn:hover {
            transform: scale(1.15); /* Más pronunciado */
            box-shadow: 0 3px 8px rgba(0,0,0,0.25);
        }
        .signature-box-btn.confirm { background-color: var(--success-color); } 
        .signature-box-btn.cancel { background-color: var(--danger-color); } 
        .signature-box-btn.edit { background-color: var(--warning-color); color: var(--text-color-dark); } 
        .signature-box-btn.draw { background-color: var(--info-color); } 


        .resize-handle {
            position: absolute;
            width: 14px; 
            height: 14px;
            background-color: var(--container-bg-color); 
            border: 2px solid var(--primary-color); 
            border-radius: 50%; 
            z-index: 101; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .resize-handle.nw { top: -7px; left: -7px; cursor: nwse-resize; }
        .resize-handle.ne { top: -7px; right: -7px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -7px; left: -7px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -7px; right: -7px; cursor: nwse-resize; }

        .signature-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.65); /* Overlay más oscuro */
            display: flex; justify-content: center; align-items: center;
            z-index: 10000; 
            padding: 15px; 
        }

        .signature-container {
            background-color: var(--container-bg-color); 
            padding: 30px; 
            border-radius: var(--border-radius); 
            width: 100%;
            max-width: 600px; /* Un poco más ancho para el pad de firma */
            height: auto;
            max-height: 90vh; 
            display: flex; flex-direction: column;
            box-shadow: var(--box-shadow-lg); 
        }

        .signature-canvas-container {
            flex-grow: 1; 
            border: 1px solid var(--border-color); 
            margin-bottom: 20px; 
            position: relative; 
            min-height: 220px; /* Un poco más alto */
            border-radius: var(--border-radius); 
            overflow: hidden; 
            background-color: #FEFEFE; /* Casi blanco, para el pad */
        }

        #signature-canvas {
            width: 100%; height: 100%;
            background-color: transparent; 
            cursor: crosshair;
            touch-action: none; 
        }

        .signature-controls {
            display: flex; justify-content: space-between; 
            flex-wrap: wrap; 
            gap: 10px; 
        }

        .signature-control-btn {
            padding: 0.7rem 1.2rem; 
            border: none;
            border-radius: var(--border-radius); 
            cursor: pointer;
            font-size: 0.95rem;
            flex-grow: 1; 
            min-width: 120px; /* Ancho mínimo */
            text-align: center;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            font-weight: 500; 
            color: white; /* Texto blanco por defecto */
        }
        .signature-control-btn:hover {
            transform: translateY(-2px); 
            box-shadow: var(--box-shadow);
        }
        .signature-control-btn.cancel { background-color: var(--danger-color); }
        .signature-control-btn.clear { background-color: var(--warning-color); color: var(--text-color-dark); } 
        .signature-control-btn.confirm { background-color: var(--success-color); }


        .embedded-signature {
            position: absolute;
            z-index: 99; 
            pointer-events: none; 
            transform-origin: top left; 
        }

        .message-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.65);
            display: flex; justify-content: center; align-items: center;
            z-index: 20000; 
            padding: 15px;
        }
        .message-modal-content {
            background-color: var(--container-bg-color);
            padding: 30px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--box-shadow-lg);
            max-width: 450px; 
            width: 100%;
        }
        .message-modal-content p {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1rem;
            color: var(--text-color-dark); 
            white-space: pre-wrap; 
            line-height: 1.6;
        }
        .message-modal-content button, .message-modal-content input[type="button"], .message-modal-content input[type="submit"] { 
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6rem 1.5rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
            display: block; 
            width: 100%;
            margin-top: 10px; 
        }
        .message-modal-content button:hover, .message-modal-content input[type="button"]:hover, .message-modal-content input[type="submit"]:hover {
            background-color: var(--primary-hover-color);
        }
        .message-modal-content input[type="text"] { /* Reutiliza estilo de #shareable-url-input */
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            background-color: #F9FAFB;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 10px;
            color: var(--text-color-dark);
        }
         .message-modal-content input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }


        .user-b-signature-area {
            position: absolute;
            border: 2px dashed var(--info-color);
            background-color: rgba(52, 152, 219, 0.1); /* Azul claro transparente */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 98; 
            border-radius: var(--border-radius);
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .user-b-signature-area:hover {
            background-color: rgba(52, 152, 219, 0.15);
            border-color: var(--primary-color);
        }
        .user-b-signature-area span {
            color: var(--info-color);
            font-size:0.9em;
            font-weight: 500;
            padding:5px;
        }

    </style>
</head>
<body>
    <header>
        <h2>Firmar Documento PDF</h2>
        <div class="navigation-toolbar">
            <button class="toolbar-btn page-nav-btn" onclick="prevPage()">⬅️ Anterior</button>
            <div id="page-info">Página <span id="current-page">1</span> de <span id="total-pages">1</span></div>
            <button class="toolbar-btn page-nav-btn" onclick="nextPage()">Siguiente ➡️</button>
        </div>
        <div id="toolbar">
            <input type="file" id="file-input" accept="application/pdf" />
            <button class="toolbar-btn" onclick="addSignatureBox()">✍️ Añadir Firma</button>
            <button class="toolbar-btn" id="save-pdf-btn" onclick="downloadPDF()">📂 Guardar</button>
            <button class="toolbar-btn" id="share-pdf-btn" onclick="sharePDF()">📤 Compartir</button>
            <button class="toolbar-btn" id="check-signatures-btn" onclick="checkSignaturesStatus()" style="display: none;">🔍 Verificar Firmas</button>
        </div>
    </header>

    <div id="pdf-viewer">
        <canvas id="pdf-canvas"></canvas>
        <div id="current-page-visits" class="page-usage-counter" title="Visitas a esta página">P: 0</div>
        <div id="total-page-views" class="page-usage-counter" title="Visitas totales en sesión">T: 0</div>
    </div>

    <div id="zoom-slider-container">
        <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" />
    </div>

    <script>
        // --- Configuración de Supabase ---
        const SUPABASE_URL = 'https://clkxkehypxmcqxcalmwn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa3hrZWh5cHhtY3F4Y2FsbXduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzNzgxMjIsImV4cCI6MjA2Mzk1NDEyMn0.eINgBpLReFf_PJmdsM2SVSD9QmuGs4FJe6jcJkp9wCg';

        let supabaseClient = null;

        function showMessage(message, isUrl = false, urlToCopy = '') {
            const existingModal = document.querySelector('.message-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.className = 'message-modal';
            
            const content = document.createElement('div');
            content.className = 'message-modal-content';
            
            let htmlContent = `<p>${message.replace(/\n/g, '<br>')}</p>`;
            
            if (isUrl && urlToCopy) {
                htmlContent += `<input type="text" value="${urlToCopy}" id="modal-shareable-url-input" readonly>`; // ID único para input en modal
                htmlContent += `<button id="modal-copy-url-btn">Copiar URL</button>`;
            }
            htmlContent += `<button id="modal-ok-message-btn" style="margin-top: ${isUrl && urlToCopy ? '10px' : '0'};">OK</button>`; // Ajuste de margen
            
            content.innerHTML = htmlContent;
            modal.appendChild(content);
            document.body.appendChild(modal);

            content.querySelector('#modal-ok-message-btn').onclick = () => modal.remove();
            
            if (isUrl && urlToCopy) {
                const copyBtn = content.querySelector('#modal-copy-url-btn');
                const urlInput = content.querySelector('#modal-shareable-url-input');
                copyBtn.onclick = () => {
                    urlInput.select();
                    urlInput.setSelectionRange(0, 99999);
                    try {
                        if (navigator.clipboard && window.isSecureContext) {
                            navigator.clipboard.writeText(urlToCopy).then(() => {
                                copyBtn.textContent = '¡Copiado!';
                                setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                            }).catch(err => {    
                                console.warn('navigator.clipboard.writeText falló, intentando execCommand:', err);
                                if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                                copyBtn.textContent = '¡Copiado (fallback)!';
                                setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                            });
                        } else {    
                            if (!document.execCommand('copy')) throw new Error('execCommand no soportado');
                            copyBtn.textContent = '¡Copiado (fallback)!';
                            setTimeout(() => { copyBtn.textContent = 'Copiar URL'; }, 2000);
                        }
                    } catch (err) {
                        console.error('Error al copiar URL:', err);
                        showMessage('Error al copiar. Por favor, copia manualmente.'); // Llama a showMessage recursivamente, podría ser problemático. Mejor un alert o un texto simple.
                    }
                };
            }
        }
        
        try {
            if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'TU_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'TU_SUPABASE_ANON_KEY') {
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    global: {
                        fetch: fetch 
                    }
                });
                console.info("Cliente de Supabase inicializado correctamente.");
            } else {
                const placeholderErrorMsg = "Configuración Incompleta: Supabase URL o Anon Key son incorrectas.\n\nLa función de compartir no funcionará.";
                console.warn(placeholderErrorMsg);
                if (typeof showMessage === 'function') {    
                    showMessage(placeholderErrorMsg);
                }
                supabaseClient = null;    
            }
        } catch (error) {
            console.error("Error CRÍTICO inicializando Supabase:", error);
            let detail = (error && error.message) ? error.message : (typeof error === 'string' ? error : "Error desconocido.");
            const initErrorMsg = `Error CRÍTICO al inicializar Supabase:\n\n${detail}\n\nLa función de compartir no funcionará.`;
            if (typeof showMessage === 'function') {    
                showMessage(initErrorMsg);
            }
            supabaseClient = null;
        }

        let pdfDoc = null;
        let originalFileName = 'documento.pdf';
        let originalPdfFileBlob = null;    
        let currentPage = 1;
        let totalPages = 0;
        let scale = 1;
        let canvas = document.getElementById('pdf-canvas');
        let context = canvas.getContext('2d');
        const pdfViewer = document.getElementById('pdf-viewer');
        let rendering = false;

        let isDraggingPdf = false;
        let startPos = { x: 0, y: 0 };
        let translatePos = { x: 0, y: 0 };
        let isZoomed = false;

        let embeddedSignatures = []; 
        let signatureBoxEl = null;    
        let activeSignatureBoxInfo = null;    
        let isDraggingSigBox = false;
        let isResizingSigBox = false;
        let signatureBoxDragOffset = { x: 0, y: 0 };
        let resizeHandleTypeSigBox = null;
        let startBoxPosSigBox = { x: 0, y: 0 };
        let startBoxSizeSigBox = { width: 0, height: 0 };
        let startPointerPosSigBox = { x: 0, y: 0 };

        let signatureModalEl = null;
        let signaturePadCanvasEl = null;
        let signaturePadCtxEl = null;
        let isDrawingOnPadEl = false;
        let lastDrawPadPosEl = { x: 0, y: 0 };

        let pinchState = {
            active: false, initialDistance: 0, lastScale: 1,
            pdfPointX: 0, pdfPointY: 0,
            screenCenterX: 0, screenCenterY: 0
        };

        let pageVisitCounts = {};
        let totalPageViewsSession = 0;

        let sharedDocIdForUserA = null; 
        let markerDataForUserB = null; 


        document.getElementById('file-input').addEventListener('change', function () {
            const file = this.files[0];
            if (file && file.type === 'application/pdf') {
                originalFileName = file.name;
                originalPdfFileBlob = file;    
                
                sharedDocIdForUserA = null;
                if (realtimeSubscription) {
                    realtimeSubscription.unsubscribe();
                    realtimeSubscription = null;
                    console.log("Realtime: Suscripción anterior cerrada debido a nueva carga de PDF.");
                }

                const checkBtn = document.getElementById('check-signatures-btn');
                if (checkBtn) checkBtn.style.display = 'none';
                markerDataForUserB = null;    
                const userBArea = document.getElementById('user-b-sig-area');
                if(userBArea) userBArea.remove();

                const reader = new FileReader();
                reader.onload = async function (e) {
                    try {
                        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                        }
                        const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
                        pdfDoc = await loadingTask.promise;
                        totalPages = pdfDoc.numPages;
                        currentPage = 1;
                        translatePos = { x: 0, y: 0 };    
                        scale = 1;    
                        document.getElementById('zoom-slider').value = scale;
                        document.getElementById('total-pages').textContent = totalPages;
                        document.getElementById('current-page').textContent = currentPage;
                        
                        embeddedSignatures = [];
                        document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
                        if (signatureBoxEl) {
                            console.log("[file-input] Removing existing signatureBoxEl due to new file load.");
                            signatureBoxEl.remove();
                            signatureBoxEl = null;    
                        }
                        activeSignatureBoxInfo = null;    
                        pageVisitCounts = {};
                        totalPageViewsSession = 0;
                        updatePageUsageCounters();    
                        renderPage(currentPage);
                    } catch (err) {
                        showMessage('Error al cargar el PDF. Asegúrate de que es un archivo PDF válido.');
                        console.error("Error loading PDF:", err);
                        pdfDoc = null;    
                        originalPdfFileBlob = null;
                    }
                };
                reader.readAsArrayBuffer(file);
            } else if (file) {
                showMessage('Por favor, selecciona un archivo PDF.');
                originalPdfFileBlob = null;
            }
                this.value = null;    
        });

        function updatePageUsageCounters() {
            if (!pdfDoc) return;
            pageVisitCounts[currentPage] = (pageVisitCounts[currentPage] || 0) + 1;
            totalPageViewsSession++;
            document.getElementById('current-page-visits').textContent = `P${currentPage}: ${pageVisitCounts[currentPage]}`;
            document.getElementById('total-page-views').textContent = `T: ${totalPageViewsSession}`;
        }

        async function renderPage(num) {    
            if (!pdfDoc || rendering) return;
            rendering = true;
            
            const userBArea = document.getElementById('user-b-sig-area');
            if(userBArea) {
                if (markerDataForUserB && markerDataForUserB.page === num) {
                    userBArea.style.display = 'flex'; 
                } else {
                    userBArea.style.display = 'none'; 
                }
            }
            
            updatePageUsageCounters();    
            
            try {
                const page = await pdfDoc.getPage(num);
                const dpr = window.devicePixelRatio || 1;    
                const viewportForRender = page.getViewport({ scale: scale * dpr });    
                canvas.width = viewportForRender.width;
                canvas.height = viewportForRender.height;
                
                const viewportCss = page.getViewport({ scale: scale });
                canvas.style.width = `${viewportCss.width}px`;
                canvas.style.height = `${viewportCss.height}px`;
                
                const viewerWidth = pdfViewer.clientWidth;
                const viewerHeight = pdfViewer.clientHeight;
                const cssCanvasWidth = viewportCss.width;
                const cssCanvasHeight = viewportCss.height;

                canvas.style.left = (cssCanvasWidth < viewerWidth) ? `${(viewerWidth - cssCanvasWidth) / 2}px` : '0px';
                canvas.style.top = (cssCanvasHeight < viewerHeight) ? `${(viewerHeight - cssCanvasHeight) / 2}px` : '0px';
                canvas.style.position = 'absolute';    
                
                const renderContext = { canvasContext: context, viewport: viewportForRender };
                await page.render(renderContext).promise;

                rendering = false;
                document.getElementById('current-page').textContent = num;
                isZoomed = scale !== 1 || cssCanvasWidth > viewerWidth || cssCanvasHeight > viewerHeight;
                updateCanvasTransform();    

            } catch (err) {
                rendering = false;    
                console.error("Error en renderPage:", err);    
                showMessage("Error al renderizar la página del PDF.");
            }
        }

        function updateCanvasTransform() {
            canvas.style.transform = `translate(${translatePos.x}px, ${translatePos.y}px)`;
            repositionSignatures();    
            repositionActiveSignatureBox();    
            if (markerDataForUserB && markerDataForUserB.page === currentPage && pdfDoc && !rendering) {    
                displayMarkerForUserB(markerDataForUserB);
            }
        }
        
        canvas.addEventListener('mousedown', (e) => {
            if (isDraggingSigBox || isResizingSigBox || pinchState.active) return;    
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            if (!isZoomed && (cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight)) return;
            if (e.target !== canvas && e.target !== pdfViewer) return;    
            isDraggingPdf = true;
            startPos = { x: e.clientX - translatePos.x,     y: e.clientY - translatePos.y };
            canvas.style.cursor = 'grabbing';
        });

        pdfViewer.addEventListener('touchstart', (e) => {
            if (signatureBoxEl && (e.target === signatureBoxEl || signatureBoxEl.contains(e.target))) {
                return;
            }
            const userBArea = document.getElementById('user-b-sig-area');
            if (userBArea && (e.target === userBArea || userBArea.contains(e.target))) {
                return;    
            }

            if (isDraggingSigBox || isResizingSigBox) return;    
            if (e.touches.length === 2) {    
                e.preventDefault();    
                isDraggingPdf = false;    
                pinchState.active = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                pinchState.initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                pinchState.lastScale = scale;    
                const viewerRect = pdfViewer.getBoundingClientRect();
                pinchState.screenCenterX = (touch1.clientX + touch2.clientX) / 2;
                pinchState.screenCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                const canvasRect = canvas.getBoundingClientRect();
                const pdfPointScreenX = pinchState.screenCenterX - canvasRect.left;
                const pdfPointScreenY = pinchState.screenCenterY - canvasRect.top;
                
                pinchState.pdfPointX = pdfPointScreenX / scale;    
                pinchState.pdfPointY = pdfPointScreenY / scale;

            } else if (e.touches.length === 1 && !pinchState.active) {    
                const cssCanvasWidth = parseFloat(canvas.style.width);
                const cssCanvasHeight = parseFloat(canvas.style.height);
                if ((cssCanvasWidth <= pdfViewer.clientWidth && cssCanvasHeight <= pdfViewer.clientHeight && scale === 1) || (e.target !== canvas && e.target !== pdfViewer)) {
                    isDraggingPdf = false; return;
                }
                isDraggingPdf = true;
                const touch = e.touches[0];
                startPos = { x: touch.clientX - translatePos.x, y: touch.clientY - translatePos.y };
            }
        }, { passive: false });    

        function handlePdfMove(clientX, clientY) {
            if (!isDraggingPdf) return;
            let newTranslateX = clientX - startPos.x;
            let newTranslateY = clientY - startPos.y;
            const viewerWidth = pdfViewer.clientWidth;
            const viewerHeight = pdfViewer.clientHeight;
            const cssCanvasWidth = parseFloat(canvas.style.width);
            const cssCanvasHeight = parseFloat(canvas.style.height);
            const overpanMargin = 30;    
            
            if (cssCanvasWidth > viewerWidth) {
                const minX = viewerWidth - cssCanvasWidth - overpanMargin;    
                const maxX = overpanMargin;    
                newTranslateX = Math.max(minX, Math.min(newTranslateX, maxX));
            } else {
                newTranslateX = (viewerWidth - cssCanvasWidth) / 2;    
            }

            if (cssCanvasHeight > viewerHeight) {
                const minY = viewerHeight - cssCanvasHeight - overpanMargin;    
                const maxY = overpanMargin;    
                newTranslateY = Math.max(minY, Math.min(newTranslateY, maxY));
            } else {
                newTranslateY = (viewerHeight - cssCanvasHeight) / 2;    
            }
            translatePos.x = newTranslateX;
            translatePos.y = newTranslateY;
            updateCanvasTransform();
        }

        async function handlePinchMove(touch1, touch2) {    
            if (!pinchState.active || pinchState.initialDistance === 0 || !pdfDoc) return;
            const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            let newScale = pinchState.lastScale * (currentDistance / pinchState.initialDistance);
            newScale = Math.min(3.0, Math.max(0.5, parseFloat(newScale.toFixed(2))));    
            
            if (Math.abs(newScale - scale) < 0.01 && newScale !== 0.5 && newScale !== 3.0) return;    
            
            const oldScale = scale;
            scale = newScale;
            
            const viewerRect = pdfViewer.getBoundingClientRect();    
            let baseCanvasX = 0;
            let baseCanvasY = 0;
            
            try {
                const page = await pdfDoc.getPage(currentPage);
                const viewportCss = page.getViewport({scale: scale});
                if (viewportCss.width < viewerRect.width) {
                    baseCanvasX = (viewerRect.width - viewportCss.width) / 2;
                }
                if (viewportCss.height < viewerRect.height) {
                    baseCanvasY = (viewerRect.height - viewportCss.height) / 2;
                }
                
                translatePos.x = (pinchState.screenCenterX - viewerRect.left - baseCanvasX) - (pinchState.pdfPointX * scale);
                translatePos.y = (pinchState.screenCenterY - viewerRect.top - baseCanvasY) - (pinchState.pdfPointY * scale);
                
                document.getElementById('zoom-slider').value = scale.toFixed(1);
                await renderPage(currentPage);    
            } catch(err) {
                console.error("Error en handlePinchMove al obtener página:", err);
                scale = oldScale;    
            }
        }

        function nextPage() {
            if (!pdfDoc || currentPage >= totalPages) return;
            currentPage++;
            translatePos = { x: 0, y: 0 };    
            renderPage(currentPage);
        }

        function prevPage() {
            if (!pdfDoc || currentPage <= 1) return;
            currentPage--;
            translatePos = { x: 0, y: 0 };    
            renderPage(currentPage);
        }

        document.getElementById('zoom-slider').addEventListener('input', async function () {
            if (!pdfDoc) return;
            const oldScale = scale;
            scale = parseFloat(this.value);
            
            const viewerRect = pdfViewer.getBoundingClientRect();
            // const canvasRect = canvas.getBoundingClientRect(); // No necesitamos canvasRect si recalculamos desde el centro
            
            // Punto de zoom: centro del visor
            const screenCenterX = viewerRect.left + viewerRect.width / 2;
            const screenCenterY = viewerRect.top + viewerRect.height / 2;

            // Convertir el punto de zoom (centro del visor) a coordenadas relativas al canvas PREVIO al zoom
            const canvasRectBeforeZoom = canvas.getBoundingClientRect(); // Coordenadas actuales del canvas
            const pdfPointX = (screenCenterX - canvasRectBeforeZoom.left) / oldScale;
            const pdfPointY = (screenCenterY - canvasRectBeforeZoom.top) / oldScale;
            
            const page = await pdfDoc.getPage(currentPage); // Necesitamos la página para el nuevo viewport
            const newViewportCss = page.getViewport({scale: scale});    
            
            // Calcular la posición base del canvas (centrado si es más pequeño que el visor)
            let expectedCanvasLeft = 0;
            if (newViewportCss.width < viewerRect.width) {
                expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
            }
            let expectedCanvasTop = 0;
            if (newViewportCss.height < viewerRect.height) {
                expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
            }
            
            // Nueva posición de translatePos para mantener el pdfPointX, pdfPointY en el screenCenterX, screenCenterY
            translatePos.x = (screenCenterX - viewerRect.left - expectedCanvasLeft) - (pdfPointX * scale);
            translatePos.y = (screenCenterY - viewerRect.top - expectedCanvasTop) - (pdfPointY * scale);
            
            // document.getElementById('zoom-slider').value = scale.toFixed(1); // Ya está siendo actualizado por el input
            await renderPage(currentPage);    
            pinchState.lastScale = scale; // Actualizar para consistencia con pellizco
        });


        pdfViewer.addEventListener('wheel', async function (e) {
            if (!pdfDoc) return;
            e.preventDefault();    
            const oldScale = scale;
            const delta = e.deltaY > 0 ? -0.1 : 0.1;    
            let newScale = parseFloat((scale + delta).toFixed(2));
            newScale = Math.min(3.0, Math.max(0.5, newScale));    
            
            if (Math.abs(newScale - oldScale) < 0.01 && newScale !==0.5 && newScale !== 3.0) return;    
            
            const viewerRect = pdfViewer.getBoundingClientRect();
            const mouseXViewer = e.clientX - viewerRect.left;    // Posición del mouse relativa al VISOR
            const mouseYViewer = e.clientY - viewerRect.top;    
            
            const canvasRect = canvas.getBoundingClientRect();    // Coordenadas actuales del canvas
            const mouseXOnCanvas = e.clientX - canvasRect.left;    // Posición del mouse relativa al CANVAS
            const mouseYOnCanvas = e.clientY - canvasRect.top;    
            
            // Punto del PDF (coordenadas no escaladas) bajo el cursor
            const pdfPointX = mouseXOnCanvas / oldScale;
            const pdfPointY = mouseYOnCanvas / oldScale;
            
            scale = newScale;    
            
            const page = await pdfDoc.getPage(currentPage);
            const newViewportCss = page.getViewport({ scale: scale });    
            
            // Calcular la posición base del canvas (centrado si es más pequeño que el visor)
            let expectedCanvasLeft = 0;
            if (newViewportCss.width < viewerRect.width) {
                expectedCanvasLeft = (viewerRect.width - newViewportCss.width) / 2;
            }
            let expectedCanvasTop = 0;
            if (newViewportCss.height < viewerRect.height) {
                expectedCanvasTop = (viewerRect.height - newViewportCss.height) / 2;
            }
            
            // Nueva posición de translatePos para mantener el pdfPointX, pdfPointY bajo el cursor (mouseXViewer, mouseYViewer)
            translatePos.x = (mouseXViewer - expectedCanvasLeft) - (pdfPointX * scale);
            translatePos.y = (mouseYViewer - expectedCanvasTop) - (pdfPointY * scale);
            
            document.getElementById('zoom-slider').value = scale.toFixed(1);
            await renderPage(currentPage);    
        }, { passive: false });    

        async function getProcessedPdfBlob() {
            if (!pdfDoc) {
                showMessage("Carga un PDF primero.");
                return null;
            }
            const { jsPDF } = window.jspdf;    
            const newPdfDocGen = new jsPDF();    
            while (newPdfDocGen.getNumberOfPages() > 0) { newPdfDocGen.deletePage(1); }
            
            for (let i = 1; i <= totalPages; i++) {
                const page = await pdfDoc.getPage(i);
                const downloadScale = 2.0;    // Escala alta para buena calidad en el PDF final
                const viewport = page.getViewport({ scale: downloadScale });
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                const signaturesForPage = embeddedSignatures.filter(sig => sig.page === i);
                for (const sigInfo of signaturesForPage) {
                    const img = new Image();
                    try {
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = (errEvent) => {
                                console.error("Error cargando imagen de firma para PDF:", sigInfo.dataURL, errEvent);
                                const syntheticError = new Error("Fallo al cargar imagen de firma: " + sigInfo.dataURL.substring(0,50) + "...");
                                syntheticError.event = errEvent;
                                reject(syntheticError);
                            };
                            img.src = sigInfo.dataURL;
                        });
                        const x = sigInfo.x * downloadScale; // Escalar coordenadas de la firma
                        const y = sigInfo.y * downloadScale;
                        const width = sigInfo.width * downloadScale;
                        const height = sigInfo.height * downloadScale;
                        tempCtx.drawImage(img, x, y, width, height);
                    } catch (imgLoadError) {
                        console.error("Saltando firma debido a error de carga:", imgLoadError);
                    }
                }
                
                const imgData = tempCanvas.toDataURL('image/jpeg', 0.9);    
                newPdfDocGen.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
                newPdfDocGen.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
            }
            return newPdfDocGen.output('blob');
        }

        async function downloadPDF() {
            showMessage("Preparando PDF para descarga...");
            const pdfBlob = await getProcessedPdfBlob();
            if (pdfBlob) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(pdfBlob);
                link.download = originalFileName.replace(/\.pdf$/i, '-firmado.pdf') || 'documento-firmado.pdf';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);    
                showMessage("PDF guardado.");
            } else {
                if(pdfDoc) showMessage("No se pudo generar el PDF para descargar.");
            }
        }

        async function sharePDF() {
            console.log('[sharePDF] INICIO. Estado de signatureBoxEl:', signatureBoxEl, '- Tipo:', typeof signatureBoxEl, '- activeSignatureBoxInfo:', activeSignatureBoxInfo);
            if (signatureBoxEl && typeof signatureBoxEl.classList !== 'undefined') {
                console.log('[sharePDF] signatureBoxEl.classList:', signatureBoxEl.classList);
                console.log('[sharePDF] ¿Está signatureBoxEl en el DOM?:', document.body.contains(signatureBoxEl));
            } else if (signatureBoxEl) {
                console.warn('[sharePDF] signatureBoxEl existe pero no tiene classList. Es:', signatureBoxEl);
            }

            if (!pdfDoc) {
                showMessage("Carga un PDF primero para compartir.");
                return;
            }
            if (!supabaseClient) {
                showMessage("Fallo en Supabase: La función de compartir no está disponible.");
                return;
            }
            if (!originalPdfFileBlob) {
                showMessage("El archivo PDF original no está disponible. Por favor, recarga el PDF.");
                return;
            }

            let markerToShare = null;

            if (signatureBoxEl && signatureBoxEl.classList.contains('position-confirmed') && activeSignatureBoxInfo && activeSignatureBoxInfo.element === signatureBoxEl) {
                console.log("[sharePDF] Usando CUADRO CONFIRMADO (estático) y activeSignatureBoxInfo.");
                
                if (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages) {
                    console.error("[sharePDF] La página del cuadro de firma confirmado (" + activeSignatureBoxInfo.page + ") es inválida.");
                    showMessage("Error: La página registrada para el cuadro de firma confirmado es inválida. Intente editar y confirmar de nuevo el cuadro en una página válida.");
                    return;
                }
                markerToShare = {
                    page: activeSignatureBoxInfo.page,
                    x_coord: activeSignatureBoxInfo.x,
                    y_coord: activeSignatureBoxInfo.y,
                    width_val: activeSignatureBoxInfo.width,
                    height_val: activeSignatureBoxInfo.height,
                    status: 'pending_user_b_signature'
                };
                console.log("[sharePDF] CORRECTO - markerToShare definido desde cuadro CONFIRMADO (estático):", markerToShare);
                
            } else {
                console.warn("[sharePDF] No se cumplió la condición para compartir el cuadro confirmado (estático).");
                if (!signatureBoxEl) console.warn("  - signatureBoxEl es null.");
                else if (!signatureBoxEl.classList.contains('position-confirmed')) console.warn("  - signatureBoxEl existe pero NO está confirmado (es azul). Se requiere el cuadro estático (borde discontinuo).");
                else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) console.warn("  - signatureBoxEl está confirmado, pero activeSignatureBoxInfo es inválido o no coincide.");
            }


            if (!markerToShare) {
                let reason = "No se encontró un cuadro de firma confirmado (estático) para compartir.";    
                
                if (!signatureBoxEl) {
                    reason = "No hay ningún cuadro de firma en la página. Debe añadir uno (✍️) y luego confirmarlo (✔️).";
                } else if (!signatureBoxEl.classList.contains('position-confirmed')) {
                    reason = "El cuadro de firma actual es azul (editable). Primero debe confirmarlo (con ✔️) para que se vuelva de borde discontinuo y pueda ser compartido.";
                } else if (!activeSignatureBoxInfo || activeSignatureBoxInfo.element !== signatureBoxEl) {
                    reason = "El cuadro de firma está confirmado, pero hay una inconsistencia con sus datos internos. Intente editarlo (✏️) y confirmarlo (✔️) de nuevo.";
                } else {    
                    if (activeSignatureBoxInfo && (activeSignatureBoxInfo.page < 1 || activeSignatureBoxInfo.page > totalPages)) {
                                    reason = "La página registrada para el cuadro de firma confirmado es inválida.";
                    } else {
                                    reason = "No se pudo preparar el cuadro de firma confirmado para compartir por una razón desconocida.";
                    }
                }
                
                console.error("SharePDF: FALLO AL PREPARAR MARCADOR. Razón: " + reason,    
                                "signatureBoxEl:", signatureBoxEl,    
                                "activeSignatureBoxInfo:", activeSignatureBoxInfo);
                
                showMessage("Para compartir con Usuario B:\n1. Usa '✍️ Añadir Firma' (aparece cuadro azul).\n2. Posiciona y dimensiona el cuadro azul.\n3. Haz clic en ✔️ sobre el cuadro azul para confirmarlo (se volverá de borde discontinuo).\n4. SOLO ENTONCES, presiona '📤 Compartir'.\n\n" +
                                        "AYUDA: El cuadro que se comparte es el de borde discontinuo (estático). Si solo ves el cuadro azul, primero confírmalo.\n\n" +
                                        "(Diagnóstico: " + reason.split('(')[0].trim() + ")");
                return;
            }
            
            showMessage("Preparando documento para compartir..."); 
            const documentId = `doc_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
            sharedDocIdForUserA = documentId; 
            const sanitizedFileName = originalFileName.replace(/[^a-zA-Z0-9._-]/g, '_');
            const originalPdfStoragePath = `documents/${documentId}/${sanitizedFileName}`;

            try {
                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs')
                    .upload(originalPdfStoragePath, originalPdfFileBlob, {
                        cacheControl: '3600',
                        upsert: false
                    });
                if (uploadError) {
                    console.error("Error subiendo PDF original a Storage:", uploadError);
                    throw new Error(`Error al subir PDF original: ${uploadError.message || JSON.stringify(uploadError)}`);
                }
                console.log("PDF original subido, path:", uploadData.path);

                const markerForDb = {
                    doc_id: documentId,
                    marker_id: `marker_userb_${Date.now()}`,
                    pdf_storage_path: uploadData.path,    
                    ...markerToShare
                };
                console.log("[sharePDF] Intentando insertar en signature_markers:", markerForDb);
                const { error: markersError } = await supabaseClient
                    .from('signature_markers')
                    .insert([markerForDb]);
                
                if (markersError) {
                    console.error("Raw Supabase insert error (signature_markers):", markersError);
                    throw new Error(`Error al guardar marcador: ${markersError.message || 'No message property, ver consola para objeto de error completo.'}`);
                }
                console.log("Información del marcador para Usuario B guardada.");

                const signingPageUrlForUserB = `${window.location.origin}${window.location.pathname}?doc_id=${documentId}&mode=sign_for_user_b`;
                const generatorPageFileName = 'generador_enlace_firma.html';    
                const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
                const generatorPageUrl = `${window.location.origin}${basePath}${generatorPageFileName}?signUrl=${encodeURIComponent(signingPageUrlForUserB)}&docId=${encodeURIComponent(documentId)}`;
                
                if (typeof Storage !== "undefined") {
                    localStorage.setItem('lastSharedDocIdForUserA', documentId);
                }

                const newShareWindow = window.open(generatorPageUrl, '_blank');

                if (newShareWindow) {
                    newShareWindow.focus(); 
                    showMessage("Generando enlace para compartir en una nueva pestaña..."); // Mensaje simplificado
                } else {
                    showMessage("No se pudo abrir la nueva pestaña para compartir.\nPor favor, revisa si tu navegador está bloqueando ventanas emergentes e inténtalo de nuevo.");
                }
                
                const checkBtn = document.getElementById('check-signatures-btn');
                if (checkBtn) checkBtn.style.display = 'inline-block'; 

                setupRealtimeListener();

            } catch (error) {    
                console.error("Excepción detallada en sharePDF (operaciones Supabase):", error);
                let specificMessage = "Error desconocido durante la operación de compartir.";
                if (error && error.message) {
                    specificMessage = error.message;    
                }

                if (specificMessage.includes("No message property, ver consola para objeto de error completo")) {
                    specificMessage += " (El objeto de error original de Supabase no tuvo una propiedad 'message' directa. Revisa la consola del navegador donde dice 'Raw Supabase insert error').";
                }

                let userMessage = `Error al compartir: ${specificMessage}\n\n`;
                
                if (error && error.message && (error.message.includes("guardar marcador") || error.message.includes("signature_markers") || error.message.includes("No message property"))) {
                    userMessage += "POSIBLES CAUSAS DEL FALLO AL GUARDAR MARCADOR:\n" +
                                    "1. Políticas de Seguridad a Nivel de Fila (RLS) en la tabla 'signature_markers' que impiden la inserción. Debes permitir inserciones para el rol 'anon'.\n" +
                                    "2. La tabla 'signature_markers' o sus columnas no están definidas correctamente en Supabase (nombres, tipos de datos, restricciones NOT NULL como 'id', 'created_at', etc.).\n" +
                                    "   Columnas esperadas: doc_id (text), marker_id (text, primary key), pdf_storage_path (text), page (int), x_coord (numeric), y_coord (numeric), width_val (numeric), height_val (numeric), status (text).\n" +
                                    "3. Problema de conexión o con el servicio de Supabase.\n\n" +
                                    "ACCIÓN: Revisa la configuración de tu tabla 'signature_markers' en Supabase Studio (Editor de Tablas y Políticas RLS). Verifica también los Logs de la Base de Datos en Supabase. La consola del navegador tiene más detalles del error original (busca 'Raw Supabase insert error').";
                } else if (error && error.message && (error.message.includes("subir PDF original") || error.message.includes("Storage"))) {
                    userMessage += "POSIBLES CAUSAS DEL FALLO AL SUBIR PDF:\n" +
                                    "1. El bucket 'pdfs' no existe en Supabase Storage.\n" +
                                    "2. Políticas de acceso al bucket 'pdfs' que impiden la subida.\n\n" +
                                    "ACCIÓN: Revisa la configuración de tu bucket 'pdfs' en Supabase Storage.";
                }
                showMessage(userMessage);
            }
        }
        
        function addSignatureBox() {
            console.log('[addSignatureBox] Llamada. Estado actual de signatureBoxEl:', signatureBoxEl);
            if (!pdfDoc) {
                showMessage("Por favor, carga un documento PDF primero.");
                return;
            }
            const userBArea = document.getElementById('user-b-sig-area');
            if (userBArea) {
                userBArea.remove(); 
                markerDataForUserB = null; 
            }

            if (signatureBoxEl) {    
                console.log('[addSignatureBox] Hay un signatureBoxEl existente, se removerá.');
                try {
                    signatureBoxEl.remove();
                } catch(e) {
                    console.warn('[addSignatureBox] Error al remover signatureBoxEl existente del DOM:', e);
                }
            }
            signatureBoxEl = null;    
            activeSignatureBoxInfo = null;    

            try {
                signatureBoxEl = document.createElement('div');    
                signatureBoxEl.className = 'signature-box';
                signatureBoxEl.style.width = '150px';    
                signatureBoxEl.style.height = '75px';
                
                const viewerRect = pdfViewer.getBoundingClientRect();
                if (!pdfViewer || (viewerRect.width === 0 && viewerRect.height === 0 && !pdfViewer.offsetParent)) {    
                    console.error("[addSignatureBox] pdfViewer no está disponible, no tiene dimensiones o no está visible.");
                    showMessage("Error: El visor de PDF no está listo para añadir una firma.");
                    signatureBoxEl = null;    
                    return;
                }
                signatureBoxEl.style.left = `${Math.max(0, (viewerRect.width - 150) / 2)}px`;    
                signatureBoxEl.style.top = `${Math.max(0, (viewerRect.height - 75) / 2)}px`;
                
                pdfViewer.appendChild(signatureBoxEl);    
                console.log('[addSignatureBox] Nuevo signatureBoxEl creado y añadido al DOM. Referencia actual:', signatureBoxEl);

                makeSignatureBoxEditable(signatureBoxEl);    
                console.log('[addSignatureBox] makeSignatureBoxEditable llamado. signatureBoxEl debería ser el nuevo cuadro.');
            } catch (error) {
                console.error('[addSignatureBox] ERROR CRÍTICO durante la creación/configuración del cuadro:', error);
                showMessage('Se produjo un error crítico al intentar añadir el cuadro de firma. Revise la consola.');
                if (signatureBoxEl && signatureBoxEl.parentElement) {
                    signatureBoxEl.remove();    
                }
                signatureBoxEl = null;    
            }
        }
        
        function repositionActiveSignatureBox() {
            if (!activeSignatureBoxInfo || !activeSignatureBoxInfo.element || !pdfViewer || !canvas || !pdfDoc) {
                return;
            }
            const sig = activeSignatureBoxInfo;
            const boxEl = sig.element;    
            if (sig.page === currentPage) {
                const canvasRect = canvas.getBoundingClientRect();    
                const viewerRect = pdfViewer.getBoundingClientRect();
                const displayX = (sig.x * scale) + (canvasRect.left - viewerRect.left);
                const displayY = (sig.y * scale) + (canvasRect.top - viewerRect.top);
                const displayWidth = sig.width * scale;
                const displayHeight = sig.height * scale;
                
                boxEl.style.left = `${displayX}px`;
                boxEl.style.top = `${displayY}px`;
                boxEl.style.width = `${displayWidth}px`;
                boxEl.style.height = `${displayHeight}px`;
                boxEl.style.display = 'block';
            } else {
                boxEl.style.display = 'none';
            }
        }

        function confirmSignatureBoxPlacement(boxEl) {    
            console.log('[confirmSignatureBoxPlacement] Confirmando. El cuadro azul es:', boxEl);
            if (!boxEl || !pdfDoc) return;    
            const handles = boxEl.querySelectorAll('.resize-handle');
            handles.forEach(h => h.remove());
            boxEl.classList.add('position-confirmed');    
            
            const canvasRect = canvas.getBoundingClientRect();
            const boxRect = boxEl.getBoundingClientRect();    
            
            const boxRelToCanvasX = (boxRect.left - canvasRect.left) / scale;    
            const boxRelToCanvasY = (boxRect.top - canvasRect.top) / scale;
            const pdfWidth = boxRect.width / scale;
            const pdfHeight = boxRect.height / scale;
            
            activeSignatureBoxInfo = {    
                element: boxEl,    
                page: currentPage,
                x: boxRelToCanvasX,    
                y: boxRelToCanvasY,    
                width: pdfWidth,    
                height: pdfHeight    
            };
            console.log('[confirmSignatureBoxPlacement] activeSignatureBoxInfo establecido:', activeSignatureBoxInfo);
            console.log('[confirmSignatureBoxPlacement] signatureBoxEl (ahora es el cuadro confirmado/estático) es:', signatureBoxEl);

            repositionActiveSignatureBox();    
            
            let controls = boxEl.querySelector('.signature-box-controls');
            if (!controls) {    
                controls = document.createElement('div');
                controls.className = 'signature-box-controls';
                boxEl.appendChild(controls);
            }
            controls.innerHTML = '';    
            
            const drawBtn = document.createElement('button');
            drawBtn.className = 'signature-box-btn draw';
            drawBtn.innerHTML = '✍️';    
            drawBtn.title = 'Dibujar Firma'; // Corregido
            drawBtn.onclick = (e) => { e.stopPropagation(); openSignatureModal(); };
            
            const editPosBtn = document.createElement('button');
            editPosBtn.className = 'signature-box-btn edit';
            editPosBtn.innerHTML = '✏️';    
            editPosBtn.title = 'Editar Posición'; // Añadido
            editPosBtn.onclick = (e) => { e.stopPropagation(); makeSignatureBoxEditable(boxEl); };    
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-box-btn cancel';
            cancelBtn.innerHTML = '❌';    
            cancelBtn.title = 'Cancelar/Eliminar esta área de firma'; // Añadido
            cancelBtn.onclick = (e) => {    
                e.stopPropagation();    
                console.log('[confirmSignatureBoxPlacement > cancelBtn] Removiendo cuadro confirmado y anulando signatureBoxEl.');
                boxEl.remove();    
                signatureBoxEl = null;    
                activeSignatureBoxInfo = null;    
            };
            controls.appendChild(drawBtn);
            controls.appendChild(editPosBtn);
            controls.appendChild(cancelBtn);
        }

        function makeSignatureBoxEditable(boxEl) {    
            console.log('[makeSignatureBoxEditable] Haciendo editable. El cuadro es:', boxEl);
            if (!boxEl) {
                console.warn('[makeSignatureBoxEditable] boxEl es null, no se puede hacer editable.');
                return;
            }
            activeSignatureBoxInfo = null;    
            boxEl.classList.remove('position-confirmed');    
            boxEl.style.cursor = 'move';    
            boxEl.querySelectorAll('.resize-handle').forEach(h => h.remove());    
            addResizeHandlesToSigBox(boxEl);    
            
            console.log('[makeSignatureBoxEditable] signatureBoxEl (ahora azul) es:', signatureBoxEl);

            let controls = boxEl.querySelector('.signature-box-controls');
            if (!controls) {
                controls = document.createElement('div');
                controls.className = 'signature-box-controls';
                boxEl.appendChild(controls);
            }
            controls.innerHTML = '';    
            
            const confirmPlacementBtn = document.createElement('button');
            confirmPlacementBtn.className = 'signature-box-btn confirm';
            confirmPlacementBtn.innerHTML = '✔️';    
            confirmPlacementBtn.title = 'Confirmar Posición'; // CORREGIDO (antes drawBtn.title)
            confirmPlacementBtn.onclick = (e) => { e.stopPropagation(); confirmSignatureBoxPlacement(boxEl); };
            
            const cancelBtn = document.createElement('button');    
            cancelBtn.className = 'signature-box-btn cancel';
            cancelBtn.innerHTML = '🗑️';    
            cancelBtn.title = 'Eliminar este cuadro azul'; // CORREGIDO (antes drawBtn.title)
            cancelBtn.onclick = (e) => {    
                e.stopPropagation();    
                console.log('[makeSignatureBoxEditable > cancelBtn] Removiendo cuadro azul y anulando signatureBoxEl.');
                boxEl.remove();    
                signatureBoxEl = null;    
                activeSignatureBoxInfo = null;    
            };
            controls.appendChild(confirmPlacementBtn);
            controls.appendChild(cancelBtn);
            setupSigBoxDragEvents(boxEl);    
            console.log('[makeSignatureBoxEditable] Terminado. signatureBoxEl (debería ser azul y editable):', signatureBoxEl);
        }
        
        const _onSigBoxDragMove = (e) => {    
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleSigBoxDragMove(clientX, clientY);
        };
        const _onSigBoxDragEnd = () => {    
            isDraggingSigBox = false;
            window.removeEventListener('mousemove', _onSigBoxDragMove);
            window.removeEventListener('touchmove', _onSigBoxDragMove);
            window.removeEventListener('mouseup', _onSigBoxDragEnd);
            window.removeEventListener('touchend', _onSigBoxDragEnd);
        };
        const _onSigBoxResizeMove = (e) => {    
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleSigBoxResizeMove(clientX, clientY);
        };
        const _onSigBoxResizeEnd = () => {    
            isResizingSigBox = false;
            resizeHandleTypeSigBox = null;
            window.removeEventListener('mousemove', _onSigBoxResizeMove);
            window.removeEventListener('touchmove', _onSigBoxResizeMove);
            window.removeEventListener('mouseup', _onSigBoxResizeEnd);
            window.removeEventListener('touchend', _onSigBoxResizeEnd);
        };

        function addResizeHandlesToSigBox(box) {
            const handles = ['nw', 'ne', 'sw', 'se'];    
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                box.appendChild(handle);
                handle.addEventListener('mousedown', (e) => {
                    e.stopImmediatePropagation();    
                    initSigBoxResize(e.clientX, e.clientY, pos, box);
                });
                handle.addEventListener('touchstart', (e) => {
                    e.stopImmediatePropagation();
                    if (e.touches.length === 1) {
                        e.preventDefault();    
                        initSigBoxResize(e.touches[0].clientX, e.touches[0].clientY, pos, box);
                    }
                }, { passive: false });
            });
        }

        function initSigBoxResize(clientX, clientY, handlePos, box) {
            if (box.classList.contains('position-confirmed')) return;    
            isResizingSigBox = true;
            resizeHandleTypeSigBox = handlePos;
            startBoxPosSigBox = { x: box.offsetLeft, y: box.offsetTop };
            startBoxSizeSigBox = { width: box.offsetWidth, height: box.offsetHeight };
            startPointerPosSigBox = { x: clientX, y: clientY };
            isDraggingPdf = false;
            isDraggingSigBox = false;
            pinchState.active = false;
            window.addEventListener('mousemove', _onSigBoxResizeMove);
            window.addEventListener('touchmove', _onSigBoxResizeMove, { passive: false });
            window.addEventListener('mouseup', _onSigBoxResizeEnd);
            window.addEventListener('touchend', _onSigBoxResizeEnd);
        }

        function handleSigBoxResizeMove(clientX, clientY) {
            if (!isResizingSigBox || !resizeHandleTypeSigBox || !signatureBoxEl) return;
            const deltaX = clientX - startPointerPosSigBox.x;
            const deltaY = clientY - startPointerPosSigBox.y;
            let newWidth = startBoxSizeSigBox.width;
            let newHeight = startBoxSizeSigBox.height;
            let newLeft = startBoxPosSigBox.x;
            let newTop = startBoxPosSigBox.y;
            const minWidth = 50;    
            const minHeight = 30;    
            const viewerRect = pdfViewer.getBoundingClientRect();
            if (resizeHandleTypeSigBox.includes('w')) {    
                newWidth = Math.max(minWidth, startBoxSizeSigBox.width - deltaX);
                newLeft = startBoxPosSigBox.x + (startBoxSizeSigBox.width - newWidth);
            }
            if (resizeHandleTypeSigBox.includes('e')) {    
                newWidth = Math.max(minWidth, startBoxSizeSigBox.width + deltaX);
            }
            if (resizeHandleTypeSigBox.includes('n')) {    
                newHeight = Math.max(minHeight, startBoxSizeSigBox.height - deltaY);
                newTop = startBoxPosSigBox.y + (startBoxSizeSigBox.height - newHeight);
            }
            if (resizeHandleTypeSigBox.includes('s')) {    
                newHeight = Math.max(minHeight, startBoxSizeSigBox.height + deltaY);
            }
            if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }    
            if (newTop < 0) { newHeight += newTop; newTop = 0; }    
            if (newLeft + newWidth > viewerRect.width) { newWidth = viewerRect.width - newLeft; }
            if (newTop + newHeight > viewerRect.height) { newHeight = viewerRect.height - newTop; }
            newWidth = Math.max(minWidth, newWidth);
            newHeight = Math.max(minHeight, newHeight);
            signatureBoxEl.style.width = `${newWidth}px`;
            signatureBoxEl.style.height = `${newHeight}px`;
            signatureBoxEl.style.left = `${newLeft}px`;
            signatureBoxEl.style.top = `${newTop}px`;
        }

        function setupSigBoxDragEvents(box) {
            function initSigBoxDrag(clientX, clientY) {
                if (box.classList.contains('position-confirmed')) return;    
                isDraggingSigBox = true;
                const viewerRect = pdfViewer.getBoundingClientRect();
                signatureBoxDragOffset.x = clientX - viewerRect.left - box.offsetLeft;
                signatureBoxDragOffset.y = clientY - viewerRect.top - box.offsetTop;
                isDraggingPdf = false;    
                isResizingSigBox = false;    
                pinchState.active = false;    
                window.addEventListener('mousemove', _onSigBoxDragMove);
                window.addEventListener('touchmove', _onSigBoxDragMove, { passive: false });
                window.addEventListener('mouseup', _onSigBoxDragEnd);
                window.addEventListener('touchend', _onSigBoxDragEnd);
            }
            box.addEventListener('mousedown', (e) => {
                if (e.target === box && !box.classList.contains('position-confirmed')) {
                    e.stopImmediatePropagation();    
                    initSigBoxDrag(e.clientX, e.clientY);
                }
            });
            box.addEventListener('touchstart', (e) => {
                if (e.target === box && e.touches.length === 1 && !box.classList.contains('position-confirmed')) {
                    e.stopImmediatePropagation();
                    e.preventDefault();    
                    initSigBoxDrag(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });
        }

        function handleSigBoxDragMove(clientX, clientY) {
            if (!isDraggingSigBox || !signatureBoxEl) return;
            const viewerRect = pdfViewer.getBoundingClientRect();
            let newLeft = clientX - viewerRect.left - signatureBoxDragOffset.x;
            let newTop = clientY - viewerRect.top - signatureBoxDragOffset.y;
            newLeft = Math.max(0, Math.min(newLeft, viewerRect.width - signatureBoxEl.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, viewerRect.height - signatureBoxEl.offsetHeight));
            signatureBoxEl.style.left = `${newLeft}px`;
            signatureBoxEl.style.top = `${newTop}px`;
        }

        function openSignatureModal() {    
            if (!activeSignatureBoxInfo) {
                if (signatureBoxEl && !signatureBoxEl.classList.contains('position-confirmed')) {
                    showMessage("Primero debe confirmar la posición del cuadro de firma (botón ✔️ del cuadro azul) antes de poder dibujar en él.");
                } else {
                    showMessage("Error: No hay un área de firma confirmada y activa para dibujar. Añada una firma y confírmela (✔️).");
                }
                return;
            }
            signatureModalEl = document.createElement('div');
            signatureModalEl.className = 'signature-modal';
            const container = document.createElement('div');
            container.className = 'signature-container';
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'signature-canvas-container';
            signaturePadCanvasEl = document.createElement('canvas');
            signaturePadCanvasEl.id = 'signature-canvas';
            canvasContainer.appendChild(signaturePadCanvasEl);
            container.appendChild(canvasContainer);
            signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
            
            const controls = document.createElement('div');
            controls.className = 'signature-controls';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-control-btn cancel';
            cancelBtn.textContent = '❌ Cancelar';
            cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'signature-control-btn clear';
            clearBtn.textContent = '↩️ Limpiar';
            clearBtn.onclick = () => {
                const dpr = window.devicePixelRatio || 1;
                // Clear con el reescalado de dpr
                signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / dpr , signaturePadCanvasEl.height / dpr );

            };
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'signature-control-btn confirm';
            confirmBtn.textContent = '✔️ Firmar';
            confirmBtn.onclick = embedSignature;    
            
            controls.appendChild(cancelBtn);
            controls.appendChild(clearBtn);
            controls.appendChild(confirmBtn);
            container.appendChild(controls);
            signatureModalEl.appendChild(container);
            document.body.appendChild(signatureModalEl);
            
            requestAnimationFrame(() => {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                signaturePadCanvasEl.width = rect.width * dpr;
                signaturePadCanvasEl.height = rect.height * dpr;
                signaturePadCanvasEl.style.width = `${rect.width}px`;
                signaturePadCanvasEl.style.height = `${rect.height}px`;
                signaturePadCtxEl.scale(dpr, dpr);    
                signaturePadCtxEl.lineWidth = 1.8; // Ligeramente más grueso    
                signaturePadCtxEl.lineCap = 'round';    
                signaturePadCtxEl.lineJoin = 'round';    
                signaturePadCtxEl.strokeStyle = '#000000';    
            });
            setupSignaturePadDrawingEventsEl();    
        }

        function setupSignaturePadDrawingEventsEl() {
            function getPadPosition(e) {    
                const rect = signaturePadCanvasEl.getBoundingClientRect();
                let clientX, clientY;
                if (e.type.startsWith('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left),    
                    y: (clientY - rect.top)
                };
            }
            function startPadDraw(e) {
                e.preventDefault();
                isDrawingOnPadEl = true;
                lastDrawPadPosEl = getPadPosition(e);
                signaturePadCtxEl.beginPath();    
                signaturePadCtxEl.moveTo(lastDrawPadPosEl.x, lastDrawPadPosEl.y);
            }
            function drawOnPad(e) {
                if (!isDrawingOnPadEl) return;
                e.preventDefault();
                const currentPos = getPadPosition(e);
                signaturePadCtxEl.lineTo(currentPos.x, currentPos.y);
                signaturePadCtxEl.stroke();    
                lastDrawPadPosEl = currentPos;
            }
            function stopPadDraw() {
                if(isDrawingOnPadEl) {
                    isDrawingOnPadEl = false;
                }
            }
            signaturePadCanvasEl.addEventListener('mousedown', startPadDraw);
            signaturePadCanvasEl.addEventListener('mousemove', drawOnPad);
            signaturePadCanvasEl.addEventListener('mouseup', stopPadDraw);
            signaturePadCanvasEl.addEventListener('mouseout', stopPadDraw);    
            signaturePadCanvasEl.addEventListener('touchstart', startPadDraw, { passive: false });
            signaturePadCanvasEl.addEventListener('touchmove', drawOnPad, { passive: false });
            signaturePadCanvasEl.addEventListener('touchend', stopPadDraw);
        }

        function embedSignature(isUserBSignature = false, markerInfo = null) {    
            const tempCanvasTest = document.createElement('canvas');
            tempCanvasTest.width = signaturePadCanvasEl.width;    
            tempCanvasTest.height = signaturePadCanvasEl.height;
            const blankDataURL = tempCanvasTest.toDataURL();
            
            const targetInfo = isUserBSignature ? markerInfo : activeSignatureBoxInfo;

            if (!targetInfo) {    
                showMessage("Error: No hay información del cuadro de firma activo para incrustar la firma.");
                if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
                return;
            }
            if (!signaturePadCanvasEl || signaturePadCanvasEl.toDataURL() === blankDataURL) {
                showMessage("Por favor, dibuja una firma primero.");
                return;
            }

            const dataURL = signaturePadCanvasEl.toDataURL('image/png');    
            const signatureImgElement = document.createElement('img');
            signatureImgElement.className = 'embedded-signature';    
            signatureImgElement.src = dataURL;
            
            const signatureInfo = {
                element: signatureImgElement,    
                page: targetInfo.page,    
                x: targetInfo.x_coord || targetInfo.x, 
                y: targetInfo.y_coord || targetInfo.y,    
                width: targetInfo.width_val || targetInfo.width,    
                height: targetInfo.height_val || targetInfo.height,    
                dataURL: dataURL,    
                marker_id_ref: isUserBSignature ? targetInfo.marker_id : undefined
            };
            
            // Eliminar firma anterior si existe para el mismo marker_id_ref
            if (signatureInfo.marker_id_ref) {
                const existingSigIndex = embeddedSignatures.findIndex(sig => sig.marker_id_ref === signatureInfo.marker_id_ref);
                if (existingSigIndex > -1) {
                    const oldSigElement = embeddedSignatures[existingSigIndex].element;
                    if (oldSigElement && oldSigElement.parentElement) {
                        oldSigElement.remove();
                    }
                    embeddedSignatures.splice(existingSigIndex, 1);
                }
            }


            signatureImgElement.setAttribute('data-marker-id-ref', signatureInfo.marker_id_ref || `userA_${Date.now()}`); 
            embeddedSignatures.push(signatureInfo);    
            pdfViewer.appendChild(signatureImgElement);    
            
            if (!isUserBSignature && activeSignatureBoxInfo && activeSignatureBoxInfo.element) { 
                console.log('[embedSignature] Removiendo el cuadro de firma confirmado (era signatureBoxEl) y anulando signatureBoxEl.');
                activeSignatureBoxInfo.element.remove();    
                signatureBoxEl = null;    
                activeSignatureBoxInfo = null;    
            } else if (isUserBSignature) {
                const userBArea = document.getElementById('user-b-sig-area');
                if (userBArea) userBArea.remove();
                // No limpiar markerDataForUserB aquí, se usa para la subida a Supabase. 
                // La UI ya no mostrará el area de click porque la firma está embebida.
            }
            
            if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
            repositionSignatures();    
        }


        function repositionSignatures() {
            if (!pdfViewer || !canvas || !pdfDoc) return;    
            const viewerRect = pdfViewer.getBoundingClientRect();
            const pdfCanvasRect = canvas.getBoundingClientRect();    
            if (pdfCanvasRect.width === 0 || pdfCanvasRect.height === 0) return;    

            const pdfCanvasScreenLeftInViewer = pdfCanvasRect.left - viewerRect.left;
            const pdfCanvasScreenTopInViewer = pdfCanvasRect.top - viewerRect.top;
            
            embeddedSignatures.forEach(sig => {
                if (sig.element) {
                    if (sig.page === currentPage) {    
                        const displayX = (sig.x * scale) + pdfCanvasScreenLeftInViewer;
                        const displayY = (sig.y * scale) + pdfCanvasScreenTopInViewer;
                        const displayWidth = sig.width * scale;
                        const displayHeight = sig.height * scale;
                        
                        sig.element.style.left = `${displayX}px`;
                        sig.element.style.top = `${displayY}px`;
                        sig.element.style.width = `${displayWidth}px`;
                        sig.element.style.height = `${displayHeight}px`;
                        sig.element.style.display = 'block';    
                    } else {
                        sig.element.style.display = 'none';    
                    }
                }
            });
        }
        
        function adjustViewerHeightAndRender() {
            const headerElement = document.querySelector('header');
            if (headerElement && pdfViewer) {
                const headerHeight = headerElement.offsetHeight;
                pdfViewer.style.height = `calc(100vh - ${headerHeight}px)`;
            }
            if (pdfDoc) {    
                renderPage(currentPage);    
            } else {
                // Si no hay PDF, ocultar elementos que dependen de él
                if(canvas) context.clearRect(0, 0, canvas.width, canvas.height);
                document.querySelectorAll('.embedded-signature').forEach(el => el.style.display = 'none');
                if (activeSignatureBoxInfo && activeSignatureBoxInfo.element) {
                    activeSignatureBoxInfo.element.style.display = 'none';
                }
                const userBArea = document.getElementById('user-b-sig-area');
                if(userBArea) userBArea.style.display = 'none'; // Ocultar, no remover
            }
        }


        function displayMarkerForUserB(marker) {
            if (!pdfDoc || !marker || marker.page !== currentPage || rendering) return;

            const isMarkerAlreadySignedLocally = embeddedSignatures.some(sig => sig.marker_id_ref === marker.marker_id);
            if (isMarkerAlreadySignedLocally) {
                const existingUserBArea = document.getElementById('user-b-sig-area');
                if (existingUserBArea) existingUserBArea.style.display = 'none'; // Ocultar si ya está firmado
                return;
            }

            let userBSignatureAreaEl = document.getElementById('user-b-sig-area');
            if (!userBSignatureAreaEl) {
                userBSignatureAreaEl = document.createElement('div');
                userBSignatureAreaEl.id = 'user-b-sig-area';
                userBSignatureAreaEl.className = 'user-b-signature-area';
                userBSignatureAreaEl.innerHTML = '<span>Haz clic aquí para firmar</span>';
                pdfViewer.appendChild(userBSignatureAreaEl);
            }
            userBSignatureAreaEl.style.display = 'flex';    

            const canvasRect = canvas.getBoundingClientRect();
            const viewerRect = pdfViewer.getBoundingClientRect();
            if (canvasRect.width === 0 || canvasRect.height === 0) {
                console.warn("Canvas no listo para posicionar área de User B, reintentando...");
                requestAnimationFrame(() => displayMarkerForUserB(marker));    
                return;
            }

            const displayX = (marker.x_coord * scale) + (canvasRect.left - viewerRect.left);
            const displayY = (marker.y_coord * scale) + (canvasRect.top - viewerRect.top);
            const displayWidth = marker.width_val * scale;
            const displayHeight = marker.height_val * scale;

            userBSignatureAreaEl.style.left = `${displayX}px`;
            userBSignatureAreaEl.style.top = `${displayY}px`;
            userBSignatureAreaEl.style.width = `${displayWidth}px`;
            userBSignatureAreaEl.style.height = `${displayHeight}px`;

            userBSignatureAreaEl.onclick = () => {
                openSignatureModalForUserB(marker);
            };
        }

        function openSignatureModalForUserB(markerToSign) {
            signatureModalEl = document.createElement('div');
            signatureModalEl.className = 'signature-modal';
            const container = document.createElement('div');
            container.className = 'signature-container';
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'signature-canvas-container';
            signaturePadCanvasEl = document.createElement('canvas');
            signaturePadCanvasEl.id = 'signature-canvas';
            canvasContainer.appendChild(signaturePadCanvasEl);
            container.appendChild(canvasContainer);
            signaturePadCtxEl = signaturePadCanvasEl.getContext('2d');
            
            const controls = document.createElement('div');
            controls.className = 'signature-controls';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'signature-control-btn cancel';
            cancelBtn.textContent = '❌ Cancelar';
            cancelBtn.onclick = () => { signatureModalEl.remove(); signatureModalEl = null; };
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'signature-control-btn clear';
            clearBtn.textContent = '↩️ Limpiar';
            clearBtn.onclick = () => {
                const dpr = window.devicePixelRatio || 1;
                signaturePadCtxEl.clearRect(0, 0, signaturePadCanvasEl.width / dpr, signaturePadCanvasEl.height / dpr);
            };
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'signature-control-btn confirm';
            confirmBtn.textContent = '✔️ Confirmar y Enviar Firma';
            confirmBtn.onclick = async () => {    
                const signatureDataURL = signaturePadCanvasEl.toDataURL('image/png');
                const tempCanvasTest = document.createElement('canvas'); // Para verificar si está vacío
                tempCanvasTest.width = signaturePadCanvasEl.width;
                tempCanvasTest.height = signaturePadCanvasEl.height;
                if (signatureDataURL === tempCanvasTest.toDataURL()) {
                    showMessage("Por favor, dibuja una firma primero.");
                    return;
                }
                
                // Llamar a embedSignature ANTES de guardar en Supabase para UI inmediata
                embedSignature(true, markerToSign); 
                
                if (signatureModalEl) { signatureModalEl.remove(); signatureModalEl = null; }
                await saveUserBSignatureToSupabase(markerToSign, signatureDataURL);
            };
            
            controls.appendChild(cancelBtn);
            controls.appendChild(clearBtn);
            controls.appendChild(confirmBtn);
            container.appendChild(controls);
            signatureModalEl.appendChild(container);
            document.body.appendChild(signatureModalEl);
            
            requestAnimationFrame(() => {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                signaturePadCanvasEl.width = rect.width * dpr;
                signaturePadCanvasEl.height = rect.height * dpr;
                signaturePadCanvasEl.style.width = `${rect.width}px`;
                signaturePadCanvasEl.style.height = `${rect.height}px`;
                signaturePadCtxEl.scale(dpr, dpr);
                signaturePadCtxEl.lineWidth = 1.8;
                signaturePadCtxEl.lineCap = 'round';
                signaturePadCtxEl.lineJoin = 'round';
                signaturePadCtxEl.strokeStyle = '#000000';
            });
            setupSignaturePadDrawingEventsEl();
        }


        async function saveUserBSignatureToSupabase(marker, signatureDataURL) {
            if (!supabaseClient) {
                showMessage("Error: Cliente Supabase no disponible.");
                return;
            }
            showMessage("Guardando y enviando firma...");

            try {
                const response = await fetch(signatureDataURL);
                const blob = await response.blob();
                const signatureFileName = `signed_sig_${marker.marker_id}.png`;
                const signatureStoragePath = `signed_signatures/${marker.doc_id}/${signatureFileName}`;

                console.log("[saveUserBSignatureToSupabase] Intentando subir firma a Storage con ruta:", signatureStoragePath);

                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs')    // Asegúrate que el bucket sea el correcto para firmas, o usa uno dedicado
                    .upload(signatureStoragePath, blob, {
                        contentType: 'image/png',
                        cacheControl: '3600',
                        upsert: true // Sobrescribir si ya existe para este marker_id
                    });
                if (uploadError) throw new Error(`Error al subir firma a Storage: ${uploadError.message}`);

                const { error: updateError } = await supabaseClient
                    .from('signature_markers')
                    .update({
                        status: 'signed_by_user_b',
                        signed_signature_storage_path: signatureStoragePath,    // Guardar el path de la firma en Storage
                        signed_at: new Date().toISOString()
                    })
                    .eq('marker_id', marker.marker_id)
                    .eq('doc_id', marker.doc_id); // Asegurar que actualizamos el correcto
                if (updateError) throw new Error(`Error al actualizar marcador: ${updateError.message}`);

                showMessage("¡Firma enviada exitosamente!\nPuedes cerrar esta ventana.");
                
                // Habilitar botones de Guardar y Compartir para Usuario B después de firmar
                const savePdfBtn = document.getElementById('save-pdf-btn');
                const sharePdfBtn = document.getElementById('share-pdf-btn');    
                
                if (savePdfBtn) {
                    savePdfBtn.style.display = 'inline-block';
                    savePdfBtn.textContent = '💾 Descargar PDF Final'; 
                    savePdfBtn.onclick = downloadPDF; 
                }
                if (sharePdfBtn) {
                    sharePdfBtn.textContent = '📤 Compartir PDF Final';    
                    sharePdfBtn.onclick = () => shareSignedPdfByB(marker.doc_id, originalFileName);
                    sharePdfBtn.style.display = 'inline-block';
                }

                // Limpiar la URL de la página si se está en el modo de firma de Usuario B
                if (window.history.replaceState) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                }

            } catch (error) {
                console.error("Error guardando firma de Usuario B:", error);
                showMessage(`Error al guardar la firma: ${error.message}`);
            }
        }

        async function shareSignedPdfByB(docId, fileName) {
            if (!pdfDoc || !supabaseClient) {
                showMessage("Error: Documento o cliente Supabase no disponibles para compartir/subir.");
                return;
            }
            showMessage("Preparando PDF firmado para subir...");

            try {
                const pdfBlob = await getProcessedPdfBlob(); 
                if (!pdfBlob) {
                    showMessage("No se pudo generar el PDF firmado para subir.");
                    return;
                }

                const signedFileName = fileName.replace(/\.pdf$/i, '-firmado-final.pdf');
                const storagePath = `signed_documents/${docId}/${signedFileName}`; 

                const { data: uploadData, error: uploadError } = await supabaseClient.storage
                    .from('pdfs') // O el bucket que uses para documentos finales
                    .upload(storagePath, pdfBlob, {
                        contentType: 'application/pdf',
                        cacheControl: '3600',
                        upsert: true // Sobrescribir si ya existe
                    });

                if (uploadError) {
                    console.error("Error al subir el PDF firmado por B a Storage:", uploadError);
                    throw new Error(`Error al subir el PDF firmado: ${uploadError.message}`);
                }

                const { data: publicUrlData } = supabaseClient.storage
                    .from('pdfs') // Mismo bucket
                    .getPublicUrl(storagePath);

                const finalShareUrl = publicUrlData.publicUrl;
                
                showMessage("¡PDF firmado subido a la nube!\n\nEnlace de descarga directa:\n\n" + finalShareUrl, true, finalShareUrl);

            } catch (error) {
                console.error("Error subiendo PDF firmado por Usuario B:", error);
                showMessage(`Error al subir el PDF firmado: ${error.message}`);
            }
        }


        async function checkSignaturesStatus() {
            if (!sharedDocIdForUserA) {
                if (typeof Storage !== "undefined") {
                    const lastShared = localStorage.getItem('lastSharedDocIdForUserA');
                    if (lastShared) {
                        sharedDocIdForUserA = lastShared;
                    } else {
                        showMessage("Primero debes compartir un documento usando 'Compartir'.");
                        return;
                    }
                } else {
                    showMessage("Primero debes compartir un documento usando 'Compartir'.");
                    return;
                }
            }
            if (!supabaseClient || !pdfDoc) { 
                showMessage("Cliente Supabase no disponible o el PDF original no está cargado en esta sesión.");
                return;
            }
            showMessage("Verificando estado de las firmas...");

            try {
                const { data: markers, error } = await supabaseClient
                    .from('signature_markers')
                    .select('*')
                    .eq('doc_id', sharedDocIdForUserA);

                if (error) throw new Error(`Error obteniendo marcadores: ${error.message}`);
                if (!markers || markers.length === 0) {
                    showMessage("No se encontraron marcadores para este documento o aún no hay firmas.");
                    return;
                }

                let newSignaturesLoaded = false;
                for (const marker of markers) {
                    if (marker.status === 'signed_by_user_b' && marker.signed_signature_storage_path) {
                        const existingSignature = embeddedSignatures.find(sig => sig.marker_id_ref === marker.marker_id);
                        if (existingSignature) {
                            // Asegurarse que esté en el DOM si no lo está
                            if(existingSignature.element && !pdfViewer.contains(existingSignature.element)){
                                pdfViewer.appendChild(existingSignature.element);    
                            }
                            console.log(`Firma para ${marker.marker_id} ya está en embeddedSignatures o siendo procesada.`);
                            continue; 
                        }
                        
                        console.log(`Descargando firma para marcador ${marker.marker_id} desde ${marker.signed_signature_storage_path}`);
                        const { data: signatureDownloadData, error: signatureDownloadError } = await supabaseClient.storage
                            .from('pdfs')    // Bucket donde se guardan las firmas PNG
                            .download(marker.signed_signature_storage_path);

                        if (signatureDownloadError) {
                            console.error(`Error descargando firma ${marker.signed_signature_storage_path}:`, signatureDownloadError);
                            showMessage(`Error al descargar una firma: ${signatureDownloadError.message}`);
                            continue;
                        }

                        const signatureDataURL = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(signatureDownloadData);
                        });

                        const signatureImgElement = document.createElement('img');
                        signatureImgElement.className = 'embedded-signature';
                        signatureImgElement.src = signatureDataURL;
                        signatureImgElement.setAttribute('data-marker-id-ref', marker.marker_id); 

                        pdfViewer.appendChild(signatureImgElement);    

                        const signatureInfo = {
                            element: signatureImgElement,
                            page: marker.page,
                            x: marker.x_coord,
                            y: marker.y_coord,
                            width: marker.width_val,
                            height: marker.height_val,
                            dataURL: signatureDataURL,
                            marker_id_ref: marker.marker_id 
                        };
                        embeddedSignatures.push(signatureInfo);
                        newSignaturesLoaded = true;
                    }
                }

                if (newSignaturesLoaded) {
                    showMessage("Firmas actualizadas y cargadas en el documento.");
                } else {
                    const hasPending = markers.some(m => m.status === 'pending_user_b_signature');
                    if (hasPending) {
                        showMessage("El documento aún tiene firmas pendientes por parte del Usuario B.");
                    } else {
                        const allSignedAndPresent = markers
                            .filter(m => m.status === 'signed_by_user_b')
                            .every(m => embeddedSignatures.some(es => es.marker_id_ref === m.marker_id));
                        
                        if (markers.some(m=> m.status === 'signed_by_user_b') && allSignedAndPresent) {
                            showMessage("Todas las firmas disponibles ya han sido cargadas.");
                        } else if (!markers.some(m => m.status === 'signed_by_user_b')) {
                            showMessage("Aún no hay firmas de Usuario B para este documento.");
                        } else {
                            showMessage("No hay nuevas firmas o todas las firmas ya han sido cargadas.");
                        }
                    }
                }
                repositionSignatures();    
                repositionActiveSignatureBox();

            } catch (error) {
                console.error("Error verificando firmas:", error);
                showMessage(`Error al verificar firmas: ${error.message}`);
            }
        }

        window.addEventListener('mousemove', (e) => {
            if (isDraggingSigBox || isResizingSigBox) return;
            if (isDraggingPdf && !pinchState.active) handlePdfMove(e.clientX, e.clientY);
        });
        window.addEventListener('touchmove', (e) => {
            if (isDraggingSigBox || isResizingSigBox) return;
            if (pinchState.active && e.touches.length === 2) { e.preventDefault(); handlePinchMove(e.touches[0], e.touches[1]); }
            else if (isDraggingPdf && e.touches.length === 1 && !pinchState.active) handlePdfMove(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        window.addEventListener('mouseup', () => {    
            if (isDraggingPdf) {
                isDraggingPdf = false;
                canvas.style.cursor = (isZoomed || (parseFloat(canvas.style.width) > pdfViewer.clientWidth || parseFloat(canvas.style.height) > pdfViewer.clientHeight)) ? 'grab' : 'default';
            }
        });
        window.addEventListener('touchend', (e) => {    
            if (isDraggingPdf) isDraggingPdf = false;
            if (pinchState.active && e.touches.length < 2) pinchState.active = false;    
        });
        
        let realtimeSubscription = null;

        async function setupRealtimeListener() {
            if (!supabaseClient) {
                console.warn("Realtime: Cliente Supabase no inicializado, no se puede configurar el listener.");
                return;
            }

            if (realtimeSubscription) {
                console.log("Realtime: Desuscribiendo de la suscripción anterior.");
                await supabaseClient.removeChannel(realtimeSubscription); // Mejor usar removeChannel
                realtimeSubscription = null;
            }

            if (sharedDocIdForUserA) {
                console.log(`Realtime: Intentando suscribir a cambios para doc_id: ${sharedDocIdForUserA}`);
                realtimeSubscription = supabaseClient
                    .channel(`public:signature_markers:doc_id=eq.${sharedDocIdForUserA}`) 
                    .on('postgres_changes', {
                        event: 'UPDATE', 
                        schema: 'public',
                        table: 'signature_markers',
                        filter: `doc_id=eq.${sharedDocIdForUserA}` 
                    }, payload => {
                        console.log('Realtime: Cambio detectado en signature_markers:', payload);
                        if (payload.new && payload.new.status === 'signed_by_user_b' && payload.new.signed_signature_storage_path) {
                            const isAlreadyEmbedded = embeddedSignatures.some(sig => sig.marker_id_ref === payload.new.marker_id);
                            if (!isAlreadyEmbedded) {
                                showMessage('¡Usuario B ha firmado el documento! Actualizando documento...');
                                checkSignaturesStatus();    
                            } else {
                                console.log(`Realtime: Firma para marcador ${payload.new.marker_id} ya incrustada.`);
                            }
                        }
                    })
                    .subscribe((status, err) => {
                        if (status === 'SUBSCRIBED') {
                            console.log(`Realtime: Suscrito con éxito al documento ${sharedDocIdForUserA}`);
                            if (pdfDoc) {    // Solo verificar si el PDF ya está cargado (para Usuario A)
                                checkSignaturesStatus();
                            }
                        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') { // Manejar TIMED_OUT también
                            console.error(`Realtime: Error en el canal (${status}):`, err);
                            showMessage(`Error en la conexión en tiempo real (${status}): ${err ? err.message : 'Error desconocido'}. Intenta refrescar.`);
                        } else if (status === 'CLOSED') {
                            console.log('Realtime: Canal cerrado.');
                        } else {
                                console.log(`Realtime: Estado de suscripción: ${status}`);
                        }
                    });
            } else {
                console.log("Realtime: No hay sharedDocIdForUserA, el listener Realtime no se habilitará.");
            }
        }


        window.addEventListener('load', async () => {    
            adjustViewerHeightAndRender();
            const urlParams = new URLSearchParams(window.location.search);
            const docIdFromUrl = urlParams.get('doc_id');
            const mode = urlParams.get('mode');

            if (docIdFromUrl) {
                sharedDocIdForUserA = docIdFromUrl; 
            } else if (typeof Storage !== "undefined") {
                const lastShared = localStorage.getItem('lastSharedDocIdForUserA');
                if (lastShared) {
                    sharedDocIdForUserA = lastShared;
                }
            }

            const checkBtn = document.getElementById('check-signatures-btn');
            if (checkBtn && sharedDocIdForUserA && mode !== 'sign_for_user_b') { // Mostrar solo si no es User B
                checkBtn.style.display = 'inline-block';
            }
            
            if (docIdFromUrl && mode === 'sign_for_user_b') {    
                console.log(`Modo Firmante (Usuario B): Cargando documento con ID: ${docIdFromUrl}`);
                document.getElementById('file-input').style.display = 'none';
                const addUserASigButton = document.getElementById('toolbar').querySelector('button[onclick="addSignatureBox()"]');
                if(addUserASigButton) addUserASigButton.style.display = 'none';
                
                const savePdfBtn = document.getElementById('save-pdf-btn');
                if(savePdfBtn) savePdfBtn.style.display = 'none';
                const sharePdfBtn = document.getElementById('share-pdf-btn');    
                if(sharePdfBtn) sharePdfBtn.style.display = 'none';
                if(checkBtn) checkBtn.style.display = 'none'; 

                showMessage(`Cargando documento ${docIdFromUrl} para firmar...`);

                if (!supabaseClient) {
                    showMessage("Error: Cliente Supabase no disponible para cargar el documento.");
                    return;
                }

                try {
                    const { data: markers, error: markerError } = await supabaseClient
                        .from('signature_markers')
                        .select('*')
                        .eq('doc_id', docIdFromUrl);

                    if (markerError) throw new Error(`Error obteniendo marcador: ${markerError.message}`);
                    
                    const targetMarker = markers ? markers.find(m => m.status === 'pending_user_b_signature' || m.status === 'signed_by_user_b') : null;

                    if (!targetMarker) {
                        showMessage("Documento no encontrado, ya procesado, o enlace inválido.");
                        if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
                        return;
                    }
                    
                    markerDataForUserB = targetMarker;    
                    let pdfPathInStorage = markerDataForUserB.pdf_storage_path;

                    if (!pdfPathInStorage) {    
                        console.warn("pdf_storage_path no encontrado en el marcador, intentando listar archivos...");
                        const { data: fileList, error: listError } = await supabaseClient.storage
                            .from('pdfs')
                            .list(`documents/${docIdFromUrl}`, { limit: 1, sortBy: { column: 'created_at', order: 'desc' } });
                        if (listError || !fileList || fileList.length === 0) {
                            throw new Error(`No se encontró el archivo PDF en storage para ${docIdFromUrl}: ${listError ? listError.message : 'Lista vacía'}`);
                        }
                        pdfPathInStorage = fileList[0].name;    
                        originalFileName = fileList[0].name;
                        pdfPathInStorage = `documents/${docIdFromUrl}/${pdfPathInStorage}`;    
                    } else {
                        originalFileName = pdfPathInStorage.split('/').pop();    
                    }

                    const { data: pdfBlobData, error: downloadError } = await supabaseClient.storage
                        .from('pdfs')    
                        .download(pdfPathInStorage);

                    if (downloadError) throw new Error(`Error descargando PDF (${pdfPathInStorage}): ${downloadError.message}`);
                    originalPdfFileBlob = pdfBlobData;

                    const reader = new FileReader();
                    reader.onload = async function (e_reader) {
                        try {    
                            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                            }
                            const loadingTask = pdfjsLib.getDocument({ data: e_reader.target.result });
                            pdfDoc = await loadingTask.promise;
                            totalPages = pdfDoc.numPages;
                            currentPage = markerDataForUserB.page; // Ir a la página del marcador
                            translatePos = { x: 0, y: 0 }; scale = 1;
                            document.getElementById('zoom-slider').value = scale;
                            document.getElementById('total-pages').textContent = totalPages;
                            document.getElementById('current-page').textContent = currentPage;
                            
                            embeddedSignatures = [];
                            document.querySelectorAll('.embedded-signature').forEach(el => el.remove());
                            if (signatureBoxEl) { signatureBoxEl.remove(); signatureBoxEl = null; activeSignatureBoxInfo = null;}
                            pageVisitCounts = {}; totalPageViewsSession = 0;

                            await renderPage(currentPage);    

                            if (markerDataForUserB.status === 'signed_by_user_b' && markerDataForUserB.signed_signature_storage_path) {
                                showMessage("Este documento ya ha sido firmado. Mostrando firma...");
                                const { data: sigBlob, error: sigErr } = await supabaseClient.storage.from('pdfs').download(markerDataForUserB.signed_signature_storage_path);
                                if (sigErr) throw new Error("Error descargando la firma existente: " + sigErr.message);
                                const sigDataURL = await new Promise((resolve, reject) => {
                                        const r = new FileReader(); r.onloadend = () => resolve(r.result); r.onerror = reject; r.readAsDataURL(sigBlob);
                                });
                                // Preparar info para embedSignature
                                const signatureToEmbed = {
                                    page: markerDataForUserB.page,
                                    x_coord: markerDataForUserB.x_coord, // usa los nombres de columna de la tabla
                                    y_coord: markerDataForUserB.y_coord,
                                    width_val: markerDataForUserB.width_val,
                                    height_val: markerDataForUserB.height_val,
                                    dataURL: sigDataURL, // El dataURL de la firma descargada
                                    marker_id: markerDataForUserB.marker_id // El ID del marcador original
                                };
                                embedSignature(true, signatureToEmbed); // true para indicar que es de User B

                                // Habilitar botones para User B si el doc ya estaba firmado
                                const savePdfBtnUserB = document.getElementById('save-pdf-btn');
                                const sharePdfBtnUserB = document.getElementById('share-pdf-btn');
                                if (savePdfBtnUserB) {
                                    savePdfBtnUserB.style.display = 'inline-block';
                                    savePdfBtnUserB.textContent = '💾 Descargar PDF Final';
                                    savePdfBtnUserB.onclick = downloadPDF;
                                }
                                if (sharePdfBtnUserB) {
                                    sharePdfBtnUserB.style.display = 'inline-block';
                                    sharePdfBtnUserB.textContent = '📤 Compartir PDF Final';
                                    sharePdfBtnUserB.onclick = () => shareSignedPdfByB(docIdFromUrl, originalFileName);
                                }


                            } else if (markerDataForUserB.status === 'pending_user_b_signature') {
                                    showMessage("Documento cargado. Haz clic en el área indicada para firmar.");
                            }
                        } catch (pdfLoadError) {
                                console.error("Error procesando PDF para Usuario B:", pdfLoadError);
                                showMessage(`Error al procesar el PDF: ${pdfLoadError.message}`);
                        }
                    };
                    reader.readAsArrayBuffer(pdfBlobData);

                } catch (error) {
                    console.error("Error cargando documento para Usuario B:", error);
                    showMessage(`Error al cargar el documento: ${error.message}`);
                    if (window.history.replaceState) { window.history.replaceState({}, document.title, window.location.pathname); }
                }
            } else if (docIdFromUrl && mode === 'sign') {    // Modo antiguo, si aún es necesario
                console.log(`Modo Firmante (Antiguo): Cargando documento con ID: ${docIdFromUrl}`);
                showMessage(`Modo Firmante (Antiguo) detectado.\nID del Documento: ${docIdFromUrl}\n\n(Este modo puede estar obsoleto.)`);
                document.getElementById('file-input').style.display = 'none';
            }
            
            setupRealtimeListener();
        });
        window.addEventListener('resize', adjustViewerHeightAndRender);

    </script>
</body>
</html>
